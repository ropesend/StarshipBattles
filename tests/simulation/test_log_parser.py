"""
Test Log Parser - Parse simulation logs for test verification.

Parses log files generated by ComponentTestLogger and provides
methods for querying specific events and values.
"""
import re
import os
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


@dataclass
class LogEvent:
    """Represents a parsed log event."""
    tick: int
    event_type: str
    data: Dict[str, str]
    raw_line: str


class TestLogParser:
    """
    Parse simulation logs for test verification.
    
    Usage:
        parser = TestLogParser("tests/simulation/output/logs/ENG-001.log")
        parser.parse()
        speed = parser.get_velocity_at_tick("TestShip", 1000)
    """
    
    # Regex pattern for parsing log lines
    # Format: [TICK:N] | EVENT_TYPE | key=value | key=value | ...
    LINE_PATTERN = re.compile(r'\[TICK:(\d+)\]\s*\|\s*(\w+)(?:\s*\|(.*))?')
    KV_PATTERN = re.compile(r'(\w+)=([^|]+)')
    
    def __init__(self, filepath: str):
        """
        Initialize parser with log file path.
        
        Args:
            filepath: Path to the log file
        """
        self.filepath = filepath
        self.events: List[LogEvent] = []
        self._parsed = False
    
    def parse(self) -> None:
        """Parse the log file and populate events list."""
        if not os.path.exists(self.filepath):
            raise FileNotFoundError(f"Log file not found: {self.filepath}")
        
        self.events = []
        
        with open(self.filepath, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                
                event = self._parse_line(line)
                if event:
                    self.events.append(event)
        
        self._parsed = True
    
    def _parse_line(self, line: str) -> Optional[LogEvent]:
        """Parse a single log line into a LogEvent."""
        match = self.LINE_PATTERN.match(line)
        if not match:
            return None
        
        tick = int(match.group(1))
        event_type = match.group(2)
        kv_str = match.group(3) or ""
        
        # Parse key-value pairs
        data = {}
        for kv_match in self.KV_PATTERN.finditer(kv_str):
            key = kv_match.group(1).strip()
            value = kv_match.group(2).strip()
            data[key] = value
        
        return LogEvent(tick=tick, event_type=event_type, data=data, raw_line=line)
    
    def _ensure_parsed(self) -> None:
        """Ensure the file has been parsed."""
        if not self._parsed:
            self.parse()
    
    # =========================================================================
    # Query Methods
    # =========================================================================
    
    def get_events_by_type(self, event_type: str) -> List[LogEvent]:
        """Get all events of a specific type."""
        self._ensure_parsed()
        return [e for e in self.events if e.event_type == event_type]
    
    def get_events_at_tick(self, tick: int) -> List[LogEvent]:
        """Get all events at a specific tick."""
        self._ensure_parsed()
        return [e for e in self.events if e.tick == tick]
    
    def get_velocity_at_tick(self, ship_name: str, tick: int, param: str = "speed") -> Optional[float]:
        """
        Return ship velocity parameter at specified tick.
        
        Args:
            ship_name: Name of the ship
            tick: Tick number to query
            param: Parameter to return ('speed', 'vx', 'vy', 'heading')
            
        Returns:
            Value or None if not found
        """
        self._ensure_parsed()
        
        # Find SHIP_VELOCITY event for this ship at this tick
        for event in self.events:
            if (event.tick == tick and 
                event.event_type == "SHIP_VELOCITY" and
                event.data.get("name") == ship_name):
                val_str = event.data.get(param, "0")
                try:
                    return float(val_str)
                except ValueError:
                    return None
        
        return None
        
    def get_position_at_tick(self, ship_name: str, tick: int) -> Optional[Tuple[float, float]]:
        """
        Return ship position (x, y) at specified tick.
        
        Args:
            ship_name: Name of the ship
            tick: Tick number to query
            
        Returns:
            Tuple (x, y) or None if not found
        """
        self._ensure_parsed()
        
        for event in self.events:
            if (event.tick == tick and 
                event.event_type == "SHIP_POSITION" and
                event.data.get("name") == ship_name):
                try:
                    x = float(event.data.get("x", 0))
                    y = float(event.data.get("y", 0))
                    return (x, y)
                except ValueError:
                    return None
        return None
    
    def get_velocity_history(self, ship_name: str) -> List[Tuple[int, float]]:
        """
        Get velocity history for a ship.
        
        Returns:
            List of (tick, speed) tuples
        """
        self._ensure_parsed()
        
        history = []
        for event in self.events:
            if (event.event_type == "SHIP_VELOCITY" and
                event.data.get("name") == ship_name):
                try:
                    speed = float(event.data.get("speed", 0))
                    history.append((event.tick, speed))
                except ValueError:
                    pass
        
        return history
    
    def get_hit_count(self, attacker: str = None, target: str = None) -> int:
        """
        Count hits between ships.
        
        Args:
            attacker: Filter by attacker name (optional)
            target: Filter by target name (optional)
            
        Returns:
            Number of HIT events matching criteria
        """
        self._ensure_parsed()
        
        count = 0
        for event in self.events:
            if event.event_type != "HIT":
                continue
            if attacker and event.data.get("attacker") != attacker:
                continue
            if target and event.data.get("target") != target:
                continue
            count += 1
        
        return count
    
    def get_miss_count(self, attacker: str = None, target: str = None) -> int:
        """
        Count misses between ships.
        
        Args:
            attacker: Filter by attacker name (optional)
            target: Filter by target name (optional)
            
        Returns:
            Number of MISS events matching criteria
        """
        self._ensure_parsed()
        
        count = 0
        for event in self.events:
            if event.event_type != "MISS":
                continue
            if attacker and event.data.get("attacker") != attacker:
                continue
            if target and event.data.get("target") != target:
                continue
            count += 1
        
        return count
    
    def get_shots_fired(self, ship_name: str = None, 
                        weapon_id: str = None) -> int:
        """
        Count shots fired by a ship.
        
        Args:
            ship_name: Filter by ship name (optional)
            weapon_id: Filter by weapon ID (optional)
            
        Returns:
            Number of WEAPON_FIRE events matching criteria
        """
        self._ensure_parsed()
        
        count = 0
        for event in self.events:
            if event.event_type != "WEAPON_FIRE":
                continue
            if ship_name and event.data.get("ship") != ship_name:
                continue
            if weapon_id and event.data.get("weapon") != weapon_id:
                continue
            count += 1
        
        return count
    
    def get_damage_dealt(self, attacker: str = None, 
                         target: str = None) -> float:
        """
        Sum total damage dealt.
        
        Args:
            attacker: Filter by attacker name (optional)
            target: Filter by target name (optional)
            
        Returns:
            Total damage from matching HIT events
        """
        self._ensure_parsed()
        
        total = 0.0
        for event in self.events:
            if event.event_type != "HIT":
                continue
            if attacker and event.data.get("attacker") != attacker:
                continue
            if target and event.data.get("target") != target:
                continue
            try:
                damage = float(event.data.get("damage", 0))
                total += damage
            except ValueError:
                pass
        
        return total
    
    def get_seeker_impacts(self, target: str = None) -> int:
        """Count seeker impacts on a target."""
        self._ensure_parsed()
        
        count = 0
        for event in self.events:
            if event.event_type != "SEEKER_IMPACT":
                continue
            if target and event.data.get("target") != target:
                continue
            count += 1
        
        return count
    
    def get_seeker_expires(self) -> int:
        """Count seeker expirations."""
        self._ensure_parsed()
        return len([e for e in self.events if e.event_type == "SEEKER_EXPIRE"])
    
    def get_seeker_destroyed_count(self) -> int:
        """Count seekers destroyed by point defense."""
        self._ensure_parsed()
        return len([e for e in self.events if e.event_type == "SEEKER_DESTROYED"])
    
    def get_final_tick(self) -> int:
        """Get the final tick number from the log."""
        self._ensure_parsed()
        
        if not self.events:
            return 0
        
        # Check for SIM_END event first
        for event in reversed(self.events):
            if event.event_type == "SIM_END":
                try:
                    return int(event.data.get("final_tick", event.tick))
                except ValueError:
                    return event.tick
        
        # Otherwise return the last tick seen
        return self.events[-1].tick
    
    def get_accuracy_rate(self, attacker: str = None, 
                          target: str = None) -> float:
        """
        Calculate hit accuracy rate.
        
        Returns:
            hits / (hits + misses), or 0.0 if no shots
        """
        hits = self.get_hit_count(attacker, target)
        misses = self.get_miss_count(attacker, target)
        total = hits + misses
        
        if total == 0:
            return 0.0
        
        return hits / total
    
    def get_max_speed_reached(self, ship_name: str) -> float:
        """Get the maximum speed reached by a ship."""
        history = self.get_velocity_history(ship_name)
        if not history:
            return 0.0
        return max(speed for _, speed in history)
    
    def get_spawned_ships(self) -> List[Dict[str, str]]:
        """Get list of all spawned ships with their properties."""
        self._ensure_parsed()
        
        ships = []
        for event in self.events:
            if event.event_type == "SHIP_SPAWN":
                ships.append(event.data.copy())
        
        return ships
