# INSTRUCTIONS FOR AGENT (Plan_Adjuster)

**ROLE:** Plan_Adjuster
**FOCUS:** Generate DETAILED SPECS for Phase 5 - Legacy Purge & Final Polish

## YOUR GOAL
Analyze the provided code context below.
Isolate issues specifically related to your FOCUS (Generate DETAILED SPECS for Phase 5 - Legacy Purge & Final Polish).
Ignore unrelated issues unless they are critical system failures.

## PHASE STATUS

--- ACTIVE REFACTOR CONTEXT ---
# Active Refactor: Hull Component & Ship Cohesion
**Goal:** Unify Ship stats with V2 Ability System (Hull Component) and eliminate architectural incoherence.

## Status
**Current Phase:** Phase 4 (UI Reconstruction) - AWAITING REVIEW
**Start Date:** 2026-01-05
**Phase 1 Review:** ✅ APPROVED (2026-01-06)
**Phase 2 Review:** ✅ APPROVED (2026-01-06)
**Phase 3 Review:** ✅ APPROVED (2026-01-06)
**Phase 4 Review:** ⏳ PENDING (2026-01-06)
**Status:** [PHASE_4_COMPLETE_PENDING_REVIEW]

---

## Migration Map (The Constitution)

| Concept | Legacy State | Target State | Source of Truth |
| :--- | :--- | :--- | :--- |
| **Hull Definition** | `vehicleclasses.json` (hull_mass, hp) | `components.json` ("type": "Hull") | Component Data |
| **Base Mass** | `Ship.base_mass` (manual float) | Sum of `Hull` component + Systems | `ShipStatsCalculator` |
| **Requirements** | Hardcoded checks & `Ship.requirements` | `CrewRequired`, `FuelStorage` Abilities | Ability System V2 |
| **Resource State** | Reset on Load (Volatile) | Persisted in `Ship.resources` | Save Data |
| **UI Layout** | Hardcoded Pixel Overlaps | Responsive/Grid-based | `builder_utils.py` |

---

## Phased Schedule

### Phase 1: Data & State Foundations (The Bedrock) [Complete]
**Objective:** Fix critical state bugs and prepare data structures.
- [x] **Critical Fix:** Patch `resource_manager.py` clamping bug (resets to 0 on overflow).
- [x] **Data Migration:** Create `Hull` components in `data/components.json` for all 18 classes. [Data Architect]
- [x] **Data Migration:** Add `default_hull_id` to `data/vehicleclasses.json`. [Data Architect]
- [x] **Serialization:** Update `Ship.to_dict`/`from_dict` to persist `ResourceRegistry` values. [Data Architect]
- [x] **Cleanup:** Remove hardcoded ability string maps in `Component._instantiate_abilities`.

---

### Phase 2: Core Logic & Stability (The Engine) [Complete]
**Objective:** Implement the "Hull as Component" logic and fix core simulation loops.
- [x] **Task 2.1:** Update `Ship.__init__` to auto-equip `default_hull_id`. [Core Engineer]
- [ ] **Task 2.2:** Switch `Ship.mass` and `Ship.hp` to cached properties in `ShipStatsCalculator`. (DEFERRED - optimization)
- [x] **Task 2.3:** Implement `CommandAndControl` and `CrewRequired` logic in `update_derelict_status`.
- [x] **Task 2.4:** Remove duplicate To-Hit/Derelict initializations in `Ship.py`.
- [x] **Task 2.5:** Standardize MRO-based identity checks (remove brittle class name checks).
- [x] **Task 2.6:** Fix detail panel rendering test regressions. [UI Specialist]
  - **File:** `tests/unit/ui/test_detail_panel_rendering.py`
  - **Fix:** Added missing `uitextbox_patch_real.stop()` in tearDown to prevent patch leakage causing intermittent failures in parallel execution.

---

## Phase 2 Implementation Specifications

### Task 2.1: Auto-Equip `default_hull_id` in `Ship.__init__`
**File:** `game/simulation/entities/ship.py`
**Method:** `__init__`

**Current State (lines ~223-230):**
```python
class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
self.base_mass: float = class_def.get('hull_mass', 50)  # LEGACY
```

**Target Implementation:**
```python
from game.simulation.components.component import create_component

# In __init__, AFTER _initialize_layers():
class_def = get_vehicle_classes().get(self.ship_class, {})
default_hull_id = class_def.get('default_hull_id')

if default_hull_id:
    hull_component = create_component(default_hull_id)
    if hull_component:
        self.add_component(hull_component, LayerType.CORE)
    else:
        print(f"WARNING: Hull '{default_hull_id}' not found for {self.ship_class}")
```

**Steps:**
1. Import `create_component` from `game.simulation.components.component`.
2. Remove `self.base_mass` assignment from `class_def.get('hull_mass', ...)`.
3. After `_initialize_layers()`, lookup `default_hull_id` and call `create_component()`.
4. Add Hull to `CORE` layer via `add_component()`.

**Edge Cases:**
- Missing `default_hull_id` → Log warning, continue (test-only ships).
- Component registry not loaded → Graceful `None` return from `create_component`.

---

### Task 2.2: Cached `mass` and `hp` Properties
**Files:** `game/simulation/entities/ship.py`, `ship_stats.py`

**Current State:**
- `self.mass: float = 0.0` (direct attribute)
- `@property max_hp` / `hp` → O(n) iteration on every access

**Target Implementation in `Ship.__init__`:**
```python
self._cached_mass: float = 0.0
self._cached_max_hp: int = 0
self._cached_hp: int = 0
```

**Target Properties:**
```python
@property
def mass(self) -> float:
    return self._cached_mass

@property
def max_hp(self) -> int:
    return self._cached_max_hp

@property
def hp(self) -> int:
    return self._cached_hp
```

**In `ShipStatsCalculator.calculate(ship)`:**
```python
# Calculate and cache
total_mass = sum(c.mass for layer in ship.layers.values() for c in layer['components'])
total_max_hp = sum(c.max_hp for layer in ship.layers.values() for c in layer['components'])
total_hp = sum(c.current_hp for layer in ship.layers.values() for c in layer['components'])

ship._cached_mass = total_mass
ship._cached_max_hp = total_max_hp
ship._cached_hp = total_hp
```

---

### Task 2.3: Ability-Based Derelict Logic
**File:** `game/simulation/entities/ship.py`
**Method:** `update_derelict_status`

**New Abilities Required (in `abilities.py`):**
```python
class CommandAndControl(Ability):
    """Marks component as command center (Bridge, CIC)."""
    pass
```

**Target Implementation:**
```python
def update_derelict_status(self) -> None:
    # Check 1: Command and Control
    has_command = any(
        comp.is_operational and comp.has_ability('CommandAndControl')
        for layer in self.layers.values()
        for comp in layer['components']
    )
    
    if not has_command:
        self.is_derelict = True
        self.bridge_destroyed = True
        return
    
    # Check 2: Crew Capacity (optional)
    total_crew_req = self.get_total_ability_value('CrewRequired')
    total_crew_cap = self.get_total_ability_value('CrewCapacity')
    
    if total_crew_req > total_crew_cap:
        self.is_derelict = True
        return
    
    self.is_derelict = False
```

**Data Migration:** Add `"CommandAndControl": true` to Bridge components in `components.json`.

---

### Task 2.4: Remove Duplicate Initializations
**File:** `game/simulation/entities/ship.py`

**Remove (lines ~248-251):**
```python
self.baseline_to_hit_offense = 0.0  # DUPLICATE
self.to_hit_profile = 0.0  # DUPLICATE
```

**Keep (lines ~298-300):**
```python
self.to_hit_profile: float = 1.0       # Defensive Multiplier
self.baseline_to_hit_offense: float = 1.0  # Offensive Multiplier
```

---

### Task 2.5: Standardize Identity Checks
**File:** `game/simulation/entities/ship.py`
**Method:** `max_weapon_range` (lines ~325-355)

**Current (brittle):**
```python
if cls.__name__ == 'WeaponAbility':  # STRING CHECK
```

**Target:**
```python
from game.simulation.components.abilities import WeaponAbility, SeekerWeaponAbility

for ab in comp.ability_instances:
    if isinstance(ab, WeaponAbility):  # POLYMORPHIC
        rng = getattr(ab, 'range', 0.0)
        if isinstance(ab, SeekerWeaponAbility) and rng <= 0:
            rng = ab.projectile_speed * ab.endurance
        max_rng = max(max_rng, rng)
```

### Phase 3: Test Infrastructure & Verification (The Guardrails) [Complete]
**Objective:** Restore test isolation and verify unified stats.
- [x] **Task 3.1:** Restore/Fix `tests/conftest.py` for proper `RegistryManager` isolation. [QA Lead]
  - Added pre-test `mgr.clear()` before marker check
  - Restructured with try/finally for unconditional post-test cleanup
- [x] **Task 3.2:** Create `tests/unit/entities/test_ship_core.py` (Mocked Hull/Stat verification).
  - Created 6 test cases covering Hull auto-equip, legacy fallback, mass/HP aggregation, derelict status
  - All tests passing
- [x] **Task 3.3:** Audit existing Ship tests for `RegistryManager` usage compliance.
  - grep for COMPONENT_REGISTRY → 0 matches ✓
  - grep for VEHICLE_CLASSES → 0 matches ✓

---

## Phase 3 Implementation Specifications

### Task 3.1: Registry Isolation in `conftest.py`
**File:** `tests/conftest.py`
**Root Cause:** `reset_game_state` fixture skips cleanup when `use_custom_data` marker is present.

**Target Implementation:**
```python
@pytest.fixture(autouse=True)
def reset_game_state(monkeypatch, request):
    from game.core.registry import RegistryManager
    mgr = RegistryManager.instance()
    
    # Pre-test cleanup (ALWAYS)
    mgr.clear()

    if "use_custom_data" not in request.keywords:
        # Standard Fast Hydration
        cache = SessionRegistryCache.instance()
        cache.load_all_data()
        mgr.hydrate(...)
        
    yield
    
    # Post-test cleanup (ALWAYS RUNS)
    mgr.clear()
```

**Steps:**
1. Open `tests/conftest.py`.
2. Locate `reset_game_state` fixture.
3. Add `mgr.clear()` call BEFORE the marker check.
4. Ensure `mgr.clear()` is called AFTER `yield` unconditionally.
5. Run `pytest tests/unit/entities/test_sequence_hazard.py` to verify isolation.

---

### Task 3.2: Create `test_ship_core.py`
**File:** `tests/unit/entities/test_ship_core.py`

**Test Cases:**

#### TC-3.2.1: Hull Auto-Equip Verification
```python
def test_hull_auto_equip(registry_with_hull):
    """Verify Ship auto-equips default_hull_id from vehicle class."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="Escort")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 1
    assert core_comps[0].id == "hull_escort"
    assert ship.base_mass == 0.0  # Attribute Shadowing
```

#### TC-3.2.2: Legacy Fallback (No Hull)
```python
def test_no_hull_fallback(registry_no_hull):
    """Verify Ship uses legacy hull_mass when no default_hull_id."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="TestShip")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 0
    assert ship.base_mass == 100.0
```

#### TC-3.2.3: Mass Aggregation
```python
def test_mass_from_components(ship_with_components):
    """Verify Ship.mass equals sum of all component masses + base_mass."""
    ship = ship_with_components
    ship.recalculate_stats()
    
    expected_mass = ship.base_mass + sum(
        c.mass for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.mass == expected_mass
```

#### TC-3.2.4: HP Aggregation
```python
def test_hp_from_components(ship_with_components):
    """Verify Ship.max_hp equals sum of component max_hp values."""
    ship = ship_with_components
    
    expected_hp = sum(
        c.max_hp for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.max_hp == expected_hp
```

#### TC-3.2.5: Derelict Status from CommandAndControl
```python
def test_derelict_on_bridge_destruction(ship_with_bridge):
    """Verify ship becomes derelict when CommandAndControl component destroyed."""
    ship = ship_with_bridge
    bridge = next(c for c in ship.layers[LayerType.CORE]['components'] 
                  if c.has_ability('CommandAndControl'))
    
    bridge.current_hp = 0
    ship.update_derelict_status()
    
    assert ship.is_derelict is True
```

**Fixtures Required:**
- `registry_with_hull`: Populates RegistryManager with Escort class + hull_escort component.
- `registry_no_hull`: Populates RegistryManager with TestShip class (hull_mass=100, no default_hull_id).
- `ship_with_components`: Creates Ship with known components for mass/HP testing.
- `ship_with_bridge`: Creates Ship with Bridge component having CommandAndControl ability.

---

### Task 3.3: Audit Ship Tests for RegistryManager Compliance
**Scope:** `tests/unit/entities/`, `tests/integration/`

**Verification Steps:**
1. `grep -r "COMPONENT_REGISTRY" tests/` → Should return 0 matches.
2. `grep -r "VEHICLE_CLASSES" tests/` → Should return 0 matches.
3. `grep -r "from game.simulation.entities.ship import" tests/` → Verify imports use `get_vehicle_classes`, `get_component_registry`.

**Remediation Pattern:**
```python
# OLD (Direct Import)
from game.simulation.entities.ship import COMPONENT_REGISTRY

# NEW (RegistryManager Access)
from game.core.registry import get_component_registry
components = get_component_registry()
```

**Run Verification:**
```bash
pytest tests/unit/entities/ -v
pytest tests/integration/ -v
```

### Phase 4: UI Reconstruction (The Interface) [Complete]
**Objective:** Resolve layout overlaps and ensure builder compatibility.
- [x] **Task 4.1:** Create `game/ui/screens/builder_utils.py` (Layout constants). [UI Specialist]
  - Created centralized module with `PanelWidths`, `PanelHeights`, `Margins`, and `BuilderEvents` constants
- [x] **Task 4.2:** Implement relative/grid sizing for `builder_screen.py` to fix 1920px overlap.
  - FIXED: Changed `layer_panel_width` from fixed `PANEL_WIDTHS.layer_panel` to dynamic `calculate_dynamic_layer_width(screen_width)`
  - FIXED: `weapons_panel_width` calculation now subtracts `right_panel_width` to prevent overlap
- [x] **Task 4.3:** Resolve vertical collision between Weapons Report and Nav Panels.
  - ANALYZED: `right_panel.py` uses single scroll container, no sub-panels needing `update_layout()`
  - RECLASSIFIED: Issue was horizontal overlap (covered by Task 4.2b), not vertical stacking
- [x] **Task 4.4:** Switch `BuilderSceneGUI` to event-based data sync using `REGISTRY_RELOADED`.
  - Added `REGISTRY_RELOADED` event emission in `_reload_data`
  - Updated `BuilderRightPanel` and `BuilderLeftPanel` to subscribe to event

### Phase 5: Legacy Purge & Final Polish (The Cleanup)
**Objective:** Remove deprecated data and finalize the refactor.
- [ ] **Cleanup:** Remove `hull_mass` and `requirements` from `vehicleclasses.json`.
- [ ] **Cleanup:** Remove hardcoded ship fallback registry in `load_vehicle_classes`.
- [ ] **Final Verification:** Run Full Gauntlet (Target: 100% Pass).
- [ ] **Definition of Done:**
    - `Ship.py` has ZERO hardcoded mass/hp assignments.
    - `vehicleclasses.json` contains NO physical stats.
    - Ship Builder UI renders without overlap on 1080p+.
    - Save/Load persists fuel/ammo levels correctly.

---

## Phase 4 Implementation Specifications

### Task 4.1: Centralize Layout Constants
**File:** `game/ui/screens/builder_utils.py` [NEW]

**Implementation Spec:**
Create a utility module to define the design system's dimensions.

```python
# game/ui/screens/builder_utils.py

PANEL_WIDTHS = {
    'component_palette': 400,
    'structure_list': 400,
    'detail_panel': 500,
    'ship_stats': 750
}

PANEL_HEIGHTS = {
    'bottom_bar': 60,
    'weapons_report': 500,
    'modifier_panel': 360
}

MARGINS = {
    'edge': 20,
    'gutter': 10
}
```

---

### Task 4.2: Relative/Grid Layout for 1920px+
**File:** `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Calculate Available Center Width:** `center_width = screen_width - PANEL_WIDTHS['component_palette'] - PANEL_WIDTHS['ship_stats']`.
2. **Dynamic Layer Panel:** Instead of fixed 450px, the Layer Panel should take `min(400, center_width * 0.3)`.
3. **Schematic View:** Takes the remaining center space.
4. **Detail Panel Overlay:** Position the Detail Panel as a `pygame_gui.elements.UIPanel` with a relative offset from the right.

---

### Task 4.3: Resolve Vertical Panel Collision
**File:** `ui/builder/right_panel.py`

**Implementation Spec:**
The "Weapons Report" and "Navigation Panels" must use a vertical stack instead of fixed Y-offsets.

```python
def update_layout(self):
    current_y = MARGINS['edge']
    for panel in self.sub_panels:
        panel.set_relative_position((0, current_y))
        current_y += panel.rect.height + MARGINS['gutter']
```

---

### Task 4.4: Event-Based UI Synchronization
**Files:** `ui/builder/event_bus.py`, `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Registry Reload Event:** Add `REGISTRY_RELOADED = 'REGISTRY_RELOADED'` to `EventBus`.
2. **Panel Subscriptions:** `BuilderRightPanel` and `BuilderLeftPanel` subscribe to `REGISTRY_RELOADED`.
3. **Internal Refresh:** Update `BuilderRightPanel.refresh_controls()` to update dropdown *options* without killing the object.
4. **Preserve Selection:** Cache `self.ship.ship_class` before reload and re-apply to dropdown after refresh.

---

## Test Triage Table
| Issue | File | Status | Owner | Notes |
| :--- | :--- | :--- | :--- | :--- |
| Task 4.2a: Dynamic Layer Width | `builder_screen.py` | RESOLVED | UI Specialist | Changed to `calculate_dynamic_layer_width(screen_width)` |
| Task 4.2b: Weapons Panel Width | `builder_screen.py` | RESOLVED | UI Specialist | Subtracted `right_panel_width` from calculation |
| Task 4.3: Vertical Stacking | `right_panel.py` | NOT_APPLICABLE | UI Specialist | Reclassified: right_panel uses single scroll container, no sub-panels |

--- END ACTIVE REFACTOR CONTEXT ---


## OUTPUT INSTRUCTIONS
You are an autonomous agent.
1. Perform your analysis.
2. **CRITICAL:** You MUST use the `write_to_file` tool to save your report.
   - **Target File:** `C:\Dev\Starship Battles\Refactoring\swarm_reports\Plan_Adjuster_Report.md`
   - **Do NOT** just print the markdown to the chat. Save it to the file.

## CONTEXT

--- START FILE: data/vehicleclasses.json ---
{
    "classes": {
        "Escort": {
            "type": "Ship",
            "code": "ES",
            "hull_mass": 50,
            "max_mass": 1000,
            "layer_config": "Capital_Escort",
            "default_hull_id": "hull_escort",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Frigate": {
            "type": "Ship",
            "code": "FR",
            "hull_mass": 100,
            "max_mass": 2000,
            "layer_config": "Capital_Escort",
            "default_hull_id": "hull_frigate",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Destroyer": {
            "type": "Ship",
            "code": "DS",
            "hull_mass": 200,
            "max_mass": 4000,
            "layer_config": "Capital_Escort",
            "default_hull_id": "hull_destroyer",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Light Cruiser": {
            "type": "Ship",
            "code": "LC",
            "hull_mass": 300,
            "max_mass": 8000,
            "layer_config": "Capital_Escort",
            "default_hull_id": "hull_light_cruiser",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Cruiser": {
            "type": "Ship",
            "code": "CR",
            "hull_mass": 400,
            "max_mass": 16000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_cruiser",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Heavy Cruiser": {
            "type": "Ship",
            "code": "HC",
            "hull_mass": 600,
            "max_mass": 32000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_heavy_cruiser",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Battle Cruiser": {
            "type": "Ship",
            "code": "BC",
            "hull_mass": 800,
            "max_mass": 64000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_battle_cruiser",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Battleship": {
            "type": "Ship",
            "code": "BS",
            "hull_mass": 1600,
            "max_mass": 128000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_battleship",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Dreadnought": {
            "type": "Ship",
            "code": "DN",
            "hull_mass": 3200,
            "max_mass": 256000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_dreadnought",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Superdreadnaugh": {
            "type": "Ship",
            "code": "SD",
            "hull_mass": 6400,
            "max_mass": 512000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_superdreadnaugh",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Monitor": {
            "type": "Ship",
            "code": "MO",
            "hull_mass": 12800,
            "max_mass": 1024000,
            "layer_config": "Capital_Standard",
            "default_hull_id": "hull_monitor",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Fighter (Small)": {
            "type": "Fighter",
            "code": "SF",
            "hull_mass": 5,
            "max_mass": 25,
            "layer_config": "Fighter_Standard",
            "default_hull_id": "hull_fighter_small",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Fighter (Medium)": {
            "type": "Fighter",
            "code": "MF",
            "hull_mass": 10,
            "max_mass": 35,
            "layer_config": "Fighter_Standard",
            "default_hull_id": "hull_fighter_medium",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Fighter (Large)": {
            "type": "Fighter",
            "code": "LF",
            "hull_mass": 15,
            "max_mass": 50,
            "layer_config": "Fighter_Standard",
            "default_hull_id": "hull_fighter_large",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Fighter (Heavy)": {
            "type": "Fighter",
            "code": "HF",
            "hull_mass": 20,
            "max_mass": 70,
            "layer_config": "Fighter_Standard",
            "default_hull_id": "hull_fighter_heavy",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                },
                "propulsion": {
                    "ability": "CombatPropulsion",
                    "min_value": 1
                },
                "fuel": {
                    "ability": "FuelStorage",
                    "min_value": 1
                }
            }
        },
        "Satellite (Small)": {
            "type": "Satellite",
            "code": "SS",
            "hull_mass": 50,
            "max_mass": 250,
            "layer_config": "Satellite_Standard",
            "default_hull_id": "hull_satellite_small",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Satellite (Medium)": {
            "type": "Satellite",
            "code": "MS",
            "hull_mass": 100,
            "max_mass": 500,
            "layer_config": "Satellite_Standard",
            "default_hull_id": "hull_satellite_medium",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Satellite (Large)": {
            "type": "Satellite",
            "code": "LS",
            "hull_mass": 200,
            "max_mass": 1000,
            "layer_config": "Satellite_Standard",
            "default_hull_id": "hull_satellite_large",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Satellite (Heavy)": {
            "type": "Satellite",
            "code": "HS",
            "hull_mass": 400,
            "max_mass": 2000,
            "layer_config": "Satellite_Standard",
            "default_hull_id": "hull_satellite_heavy",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 1)": {
            "type": "Planetary Complex",
            "code": "PC1",
            "hull_mass": 0,
            "max_mass": 1000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 2)": {
            "type": "Planetary Complex",
            "code": "PC2",
            "hull_mass": 0,
            "max_mass": 2000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 3)": {
            "type": "Planetary Complex",
            "code": "PC3",
            "hull_mass": 0,
            "max_mass": 4000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 4)": {
            "type": "Planetary Complex",
            "code": "PC4",
            "hull_mass": 0,
            "max_mass": 8000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 5)": {
            "type": "Planetary Complex",
            "code": "PC5",
            "hull_mass": 0,
            "max_mass": 16000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 6)": {
            "type": "Planetary Complex",
            "code": "PC6",
            "hull_mass": 0,
            "max_mass": 32000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 7)": {
            "type": "Planetary Complex",
            "code": "PC7",
            "hull_mass": 0,
            "max_mass": 64000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 8)": {
            "type": "Planetary Complex",
            "code": "PC8",
            "hull_mass": 0,
            "max_mass": 128000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 9)": {
            "type": "Planetary Complex",
            "code": "PC9",
            "hull_mass": 0,
            "max_mass": 256000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 10)": {
            "type": "Planetary Complex",
            "code": "PC10",
            "hull_mass": 0,
            "max_mass": 512000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        },
        "Planetary Complex (Tier 11)": {
            "type": "Planetary Complex",
            "code": "PC11",
            "hull_mass": 0,
            "max_mass": 1024000,
            "layer_config": "Planetary_Complex",
            "requirements": {
                "command": {
                    "ability": "CommandAndControl",
                    "min_value": true
                }
            }
        }
    }
}
--- END FILE: data/vehicleclasses.json ---

--- START FILE: data/components.json ---
{
    "components": [
        {
            "id": "bridge",
            "name": "Bridge",
            "type": "Bridge",
            "mass": "=50 * sqrt(ship_class_mass / 1000)",
            "hp": "=200 * sqrt(ship_class_mass / 1000)",
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 3,
            "abilities": {
                "CommandAndControl": true,
                "CrewRequired": "=ceil(5 * sqrt(ship_class_mass / 1000))"
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "central_complex_command",
            "name": "Central Complex Command",
            "type": "Bridge",
            "mass": "=50 * sqrt(ship_class_mass / 1000)",
            "hp": "=500 * sqrt(ship_class_mass / 1000)",
            "allowed_vehicle_types": [
                "Planetary Complex"
            ],
            "sprite_index": 3,
            "abilities": {
                "CommandAndControl": true,
                "CrewRequired": "=ceil(10 * sqrt(ship_class_mass / 1000))"
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "railgun",
            "name": "Railgun",
            "type": "ProjectileWeaponAbility",
            "mass": 100,
            "hp": 150,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 85,
            "abilities": {
                "CrewRequired": 5,
                "ResourceConsumption": [
                    {
                        "resource": "ammo",
                        "amount": 1,
                        "trigger": "activation"
                    }
                ],
                "ProjectileWeaponAbility": {
                    "damage": "=40 - (0.01 * range_to_target)",
                    "range": 2400,
                    "reload": 2.0,
                    "projectile_speed": 20000,
                    "firing_arc": 1
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "standard_engine",
            "name": "Engine",
            "type": "Engine",
            "mass": 80,
            "hp": 100,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 10,
            "abilities": {
                "CombatPropulsion": 150,
                "ResourceConsumption": [
                    {
                        "resource": "fuel",
                        "amount": 0.5,
                        "trigger": "constant"
                    }
                ]
            },
            "major_classification": "Engines"
        },
        {
            "id": "thruster",
            "name": "Thruster",
            "type": "Thruster",
            "mass": 20,
            "hp": 40,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 78,
            "abilities": {
                "ManeuveringThruster": 30
            },
            "major_classification": "Engines"
        },
        {
            "id": "armor_plate",
            "name": "Armor Plate",
            "type": "Armor",
            "mass": 30,
            "hp": 250,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 14,
            "abilities": {
                "Armor": true
            },
            "major_classification": "Armor"
        },
        {
            "id": "emissive_armor",
            "name": "Emissive Armor",
            "type": "Armor",
            "mass": "=40 * (ship_class_mass / 1000)",
            "hp": 200,
            "hp_formula": "=200 * (ship_class_mass / 1000)",
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 15,
            "abilities": {
                "Armor": true,
                "EmissiveArmor": {
                    "value": "=15 * (ship_class_mass / 1000)**(1/3)",
                    "stack_group": "Emissive"
                }
            },
            "modifiers": [],
            "major_classification": "Armor"
        },
        {
            "id": "crystalline_armor",
            "name": "Crystalline Armor",
            "type": "Armor",
            "mass": "=40 * (ship_class_mass / 1000)",
            "hp": 200,
            "hp_formula": "=200 * (ship_class_mass / 1000)",
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 15,
            "abilities": {
                "Armor": true,
                "CrystallineArmor": {
                    "value": "=10 * (ship_class_mass / 1000)**(1/3)",
                    "stack_group": "Crystalline"
                }
            },
            "modifiers": [],
            "major_classification": "Armor"
        },
        {
            "id": "scattering_armor",
            "name": "Scattering Armor",
            "type": "Armor",
            "mass": "=40 * (ship_class_mass / 1000)",
            "hp": 150,
            "hp_formula": "=150 * (ship_class_mass / 1000)",
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 50,
            "abilities": {
                "Armor": true,
                "ToHitDefenseModifier": {
                    "value": 0.2,
                    "stack_group": "Scattering"
                }
            },
            "modifiers": [],
            "major_classification": "Armor"
        },
        {
            "id": "fuel_tank",
            "name": "Fuel Tank",
            "type": "Tank",
            "mass": 40,
            "hp": 80,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 20,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "fuel",
                        "amount": 50000
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "ordnance_tank",
            "name": "Ordnance Tank",
            "type": "Tank",
            "mass": 40,
            "hp": 80,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 19,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "ammo",
                        "amount": 5000
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "battery",
            "name": "Battery",
            "type": "Tank",
            "mass": 30,
            "hp": 50,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 19,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "energy",
                        "amount": 2000
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "generator",
            "name": "Generator",
            "type": "Generator",
            "mass": 50,
            "hp": 80,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 81,
            "abilities": {
                "ResourceGeneration": [
                    {
                        "resource": "energy",
                        "amount": 25
                    }
                ],
                "CrewRequired": 1
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "laser_cannon",
            "name": "Laser Cannon",
            "type": "BeamWeaponAbility",
            "mass": 20,
            "hp": 40,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 87,
            "abilities": {
                "CrewRequired": 1,
                "ResourceConsumption": [
                    {
                        "resource": "energy",
                        "amount": 5,
                        "trigger": "activation"
                    }
                ],
                "BeamWeaponAbility": {
                    "damage": "=15 * (1 - 0.00005 * range_to_target)",
                    "range": 2000,
                    "reload": 0.2,
                    "firing_arc": 1,
                    "base_accuracy": 2.0,
                    "accuracy_falloff": 0.001
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "crew_quarters",
            "name": "Crew Quarters",
            "type": "CrewQuarters",
            "mass": 30,
            "hp": 60,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 5,
            "abilities": {
                "CrewCapacity": 10
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "life_support",
            "name": "Life Support",
            "type": "LifeSupport",
            "mass": 20,
            "hp": 40,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 4,
            "abilities": {
                "LifeSupportCapacity": 25
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "combat_sensor",
            "name": "Combat Sensor",
            "type": "Sensor",
            "mass": 30,
            "hp": 50,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 25,
            "abilities": {
                "ToHitAttackModifier": {
                    "value": 1.0,
                    "stack_group": "Sensor"
                }
            },
            "major_classification": "Sensors"
        },
        {
            "id": "ecm_suite",
            "name": "ECM Suite",
            "type": "Electronics",
            "mass": 40,
            "hp": 40,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 26,
            "abilities": {
                "ToHitDefenseModifier": {
                    "value": 1.0,
                    "stack_group": "ECM"
                }
            },
            "major_classification": "Sensors"
        },
        {
            "id": "multiplex_tracking",
            "name": "Multiplex Tracking",
            "type": "Electronics",
            "mass": 40,
            "hp": 60,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 27,
            "abilities": {
                "MultiplexTracking": 10,
                "CrewRequired": 2
            },
            "major_classification": "Sensors"
        },
        {
            "id": "shield_generator",
            "name": "Shield Projector",
            "type": "Shield",
            "mass": 50,
            "hp": 100,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 16,
            "abilities": {
                "ShieldProjection": 500
            },
            "major_classification": "Shields"
        },
        {
            "id": "shield_regen",
            "name": "Shield Regen",
            "type": "ShieldRegenerator",
            "mass": 40,
            "hp": 80,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 18,
            "abilities": {
                "ShieldRegeneration": 5.0,
                "EnergyConsumption": 2.0
            },
            "major_classification": "Shields"
        },
        {
            "id": "capital_missile",
            "name": "Capital Missile",
            "type": "SeekerWeaponAbility",
            "mass": 60,
            "hp": 10,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 86,
            "abilities": {
                "CrewRequired": 3,
                "ResourceConsumption": [
                    {
                        "resource": "ammo",
                        "amount": 5,
                        "trigger": "activation"
                    }
                ],
                "SeekerWeaponAbility": {
                    "damage": 100,
                    "reload": 4.0,
                    "projectile_speed": 6000,
                    "firing_arc": 1,
                    "endurance": 3.0,
                    "turn_rate": 200,
                    "to_hit_defense": 0.0
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "point_defence_cannon",
            "name": "Point Defence Cannon",
            "type": "BeamWeaponAbility",
            "mass": 10,
            "hp": 30,
            "allowed_vehicle_types": [
                "Ship",
                "Satellite",
                "Planetary Complex"
            ],
            "sprite_index": 151,
            "abilities": {
                "CrewRequired": 1,
                "ResourceConsumption": [
                    {
                        "resource": "energy",
                        "amount": 2,
                        "trigger": "activation"
                    }
                ],
                "BeamWeaponAbility": {
                    "damage": 4,
                    "range": 800,
                    "reload": 0.04,
                    "firing_arc": 180,
                    "base_accuracy": 10.0,
                    "accuracy_falloff": 0.003,
                    "tags": [
                        "pdc"
                    ]
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "fighter_cockpit",
            "name": "Fighter Cockpit",
            "type": "Bridge",
            "mass": 2,
            "hp": 2,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 53,
            "abilities": {
                "CommandAndControl": true,
                "LifeSupportCapacity": 1,
                "CrewCapacity": 1
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "mini_engine",
            "name": "Mini Engine",
            "type": "Engine",
            "mass": 3,
            "hp": 3,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 58,
            "abilities": {
                "CombatPropulsion": 40,
                "ResourceConsumption": [
                    {
                        "resource": "fuel",
                        "amount": 0.2,
                        "trigger": "constant"
                    }
                ]
            },
            "major_classification": "Engines"
        },
        {
            "id": "mini_thruster",
            "name": "Mini Thruster",
            "type": "Thruster",
            "mass": 1,
            "hp": 1,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 79,
            "abilities": {
                "ManeuveringThruster": 50
            },
            "major_classification": "Engines"
        },
        {
            "id": "mini_battery",
            "name": "Mini Battery",
            "type": "Tank",
            "mass": 1,
            "hp": 1,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 192,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "energy",
                        "amount": 200
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "mini_generator",
            "name": "Mini Generator",
            "type": "Generator",
            "mass": 2,
            "hp": 2,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 187,
            "abilities": {
                "ResourceGeneration": [
                    {
                        "resource": "energy",
                        "amount": 10
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "mini_ordnance",
            "name": "Mini Ordnance",
            "type": "Tank",
            "mass": 2,
            "hp": 2,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 19,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "ammo",
                        "amount": 200
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "mini_fuel_tank",
            "name": "Mini Fuel Tank",
            "type": "Tank",
            "mass": 2,
            "hp": 2,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 20,
            "abilities": {
                "ResourceStorage": [
                    {
                        "resource": "fuel",
                        "amount": 2000
                    }
                ]
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "mini_railgun",
            "name": "Mini Railgun",
            "type": "BeamWeaponAbility",
            "mass": 2,
            "hp": 2,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 138,
            "abilities": {
                "BeamWeaponAbility": {
                    "damage": 10,
                    "range": 1000,
                    "reload": 1.0,
                    "firing_arc": 1,
                    "base_accuracy": 2.0,
                    "accuracy_falloff": 0.001
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "mini_laser_cannon",
            "name": "Mini Laser Cannon",
            "type": "BeamWeaponAbility",
            "mass": 1,
            "hp": 1,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 140,
            "abilities": {
                "ResourceConsumption": [
                    {
                        "resource": "energy",
                        "amount": 2,
                        "trigger": "activation"
                    }
                ],
                "BeamWeaponAbility": {
                    "damage": 5,
                    "range": 800,
                    "reload": 0.3,
                    "firing_arc": 1,
                    "base_accuracy": 2.0,
                    "accuracy_falloff": 0.001
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "mini_capital_missile",
            "name": "Mini Capital Missile",
            "type": "BeamWeaponAbility",
            "mass": 3,
            "hp": 3,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 216,
            "abilities": {
                "BeamWeaponAbility": {
                    "damage": 60,
                    "range": 200,
                    "reload": 15.0,
                    "firing_arc": 10,
                    "base_accuracy": 2.0,
                    "accuracy_falloff": 0.0
                }
            },
            "major_classification": "Weapons"
        },
        {
            "id": "mini_armor",
            "name": "Mini Armor",
            "type": "Armor",
            "mass": 1,
            "hp": 5,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 62,
            "abilities": {
                "Armor": true
            },
            "major_classification": "Armor"
        },
        {
            "id": "mini_sensor",
            "name": "Mini Sensor",
            "type": "Sensor",
            "mass": 1,
            "hp": 1,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 25,
            "abilities": {
                "ToHitAttackModifier": {
                    "value": 0.2,
                    "stack_group": "Sensor"
                }
            },
            "major_classification": "Sensors"
        },
        {
            "id": "mini_ecm",
            "name": "Mini ECM",
            "type": "Electronics",
            "mass": 2,
            "hp": 10,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 26,
            "abilities": {
                "ToHitDefenseModifier": {
                    "value": 0.2,
                    "stack_group": "ECM"
                }
            },
            "major_classification": "Sensors"
        },
        {
            "id": "mini_shield_generator",
            "name": "Mini Shield Gen",
            "type": "Shield",
            "mass": 2,
            "hp": 15,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 16,
            "abilities": {
                "ShieldProjection": 50
            },
            "major_classification": "Shields"
        },
        {
            "id": "mini_emissive_armor",
            "name": "Mini Emissive Armor",
            "type": "Armor",
            "mass": 1,
            "hp": 5,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 62,
            "abilities": {
                "Armor": true,
                "EmissiveArmor": {
                    "value": 3,
                    "stack_group": "Emissive"
                }
            },
            "major_classification": "Armor"
        },
        {
            "id": "mini_scattering_armor",
            "name": "Mini Scattering Armor",
            "type": "Armor",
            "mass": 1,
            "hp": 5,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 63,
            "abilities": {
                "Armor": true,
                "ToHitDefenseModifier": {
                    "value": 0.2,
                    "stack_group": "Scattering"
                }
            },
            "major_classification": "Armor"
        },
        {
            "id": "satellite_core",
            "name": "Satellite Core",
            "type": "Bridge",
            "mass": 10,
            "hp": 50,
            "allowed_vehicle_types": [
                "Satellite"
            ],
            "sprite_index": 9,
            "abilities": {
                "CommandAndControl": true
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "fighter_launch_bay",
            "name": "Fighter Launch Bay",
            "type": "Hangar",
            "mass": 500,
            "hp": 500,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 21,
            "abilities": {
                "VehicleStorage": 50,
                "VehicleLaunch": {
                    "max_launch_mass": 50,
                    "cycle_time": 5.0
                },
                "CrewRequired": 5
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "master_computer",
            "name": "Master Computer",
            "type": "Bridge",
            "mass": 50,
            "hp": 100,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 27,
            "abilities": {
                "CommandAndControl": true,
                "ToHitDefenseModifier": {
                    "value": 0.5,
                    "stack_group": "MasterComputer"
                },
                "ToHitAttackModifier": {
                    "value": 0.5,
                    "stack_group": "MasterComputer"
                },
                "EnergyConsumption": 10.0
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "robotic_drone_crew",
            "name": "Robotic Drone Crew",
            "type": "CrewQuarters",
            "mass": 30,
            "hp": 50,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 5,
            "abilities": {
                "CrewCapacity": 10,
                "LifeSupportCapacity": 10,
                "EnergyConsumption": 5.0
            },
            "major_classification": "Crewsupport"
        },
        {
            "id": "emergency_repair_bay",
            "name": "Emergency Repair Bay",
            "type": "Engineering",
            "mass": 50,
            "hp": 100,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 21,
            "abilities": {
                "ShipRepair": 5.0,
                "CrewRequired": 5,
                "EnergyConsumption": 2.0
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "ordnance_vat",
            "name": "Ordnance Vat",
            "type": "Factory",
            "mass": 80,
            "hp": 150,
            "allowed_vehicle_types": [
                "Ship",
                "Planetary Complex"
            ],
            "sprite_index": 19,
            "abilities": {
                "AmmoGeneration": 2.0,
                "CrewRequired": 5,
                "EnergyConsumption": 15.0
            },
            "major_classification": "Infrastructure"
        },
        {
            "id": "hull_escort",
            "name": "Escort Hull",
            "type": "Hull",
            "mass": 50,
            "hp": 200,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_frigate",
            "name": "Frigate Hull",
            "type": "Hull",
            "mass": 100,
            "hp": 400,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_destroyer",
            "name": "Destroyer Hull",
            "type": "Hull",
            "mass": 200,
            "hp": 800,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_light_cruiser",
            "name": "Light Cruiser Hull",
            "type": "Hull",
            "mass": 300,
            "hp": 1200,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_cruiser",
            "name": "Cruiser Hull",
            "type": "Hull",
            "mass": 400,
            "hp": 1600,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_heavy_cruiser",
            "name": "Heavy Cruiser Hull",
            "type": "Hull",
            "mass": 600,
            "hp": 2400,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_battle_cruiser",
            "name": "Battle Cruiser Hull",
            "type": "Hull",
            "mass": 800,
            "hp": 3200,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_battleship",
            "name": "Battleship Hull",
            "type": "Hull",
            "mass": 1600,
            "hp": 6400,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_dreadnought",
            "name": "Dreadnought Hull",
            "type": "Hull",
            "mass": 3200,
            "hp": 12800,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_superdreadnaugh",
            "name": "Superdreadnaugh Hull",
            "type": "Hull",
            "mass": 6400,
            "hp": 25600,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_monitor",
            "name": "Monitor Hull",
            "type": "Hull",
            "mass": 12800,
            "hp": 51200,
            "allowed_vehicle_types": [
                "Ship"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_fighter_small",
            "name": "Small Fighter Hull",
            "type": "Hull",
            "mass": 5,
            "hp": 10,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_fighter_medium",
            "name": "Medium Fighter Hull",
            "type": "Hull",
            "mass": 10,
            "hp": 20,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_fighter_large",
            "name": "Large Fighter Hull",
            "type": "Hull",
            "mass": 15,
            "hp": 30,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_fighter_heavy",
            "name": "Heavy Fighter Hull",
            "type": "Hull",
            "mass": 20,
            "hp": 40,
            "allowed_vehicle_types": [
                "Fighter"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_satellite_small",
            "name": "Small Satellite Hull",
            "type": "Hull",
            "mass": 50,
            "hp": 100,
            "allowed_vehicle_types": [
                "Satellite"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_satellite_medium",
            "name": "Medium Satellite Hull",
            "type": "Hull",
            "mass": 100,
            "hp": 200,
            "allowed_vehicle_types": [
                "Satellite"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_satellite_large",
            "name": "Large Satellite Hull",
            "type": "Hull",
            "mass": 200,
            "hp": 400,
            "allowed_vehicle_types": [
                "Satellite"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        },
        {
            "id": "hull_satellite_heavy",
            "name": "Heavy Satellite Hull",
            "type": "Hull",
            "mass": 400,
            "hp": 800,
            "allowed_vehicle_types": [
                "Satellite"
            ],
            "sprite_index": 0,
            "abilities": {
                "StructuralIntegrity": true
            },
            "major_classification": "Structure"
        }
    ]
}
--- END FILE: data/components.json ---

--- START FILE: game/simulation/entities/ship.py ---
import pygame
import random
import math
import json
import os
import typing
from typing import List, Dict, Tuple, Optional, Any, Union, Set, TYPE_CHECKING

from game.engine.physics import PhysicsBody
from game.simulation.components.component import (
    Component, LayerType, create_component
)
from game.core.logger import log_debug
from game.core.registry import RegistryManager, get_vehicle_classes, get_validator, get_component_registry, get_modifier_registry
from ship_validator import ShipDesignValidator, ValidationResult
from ship_stats import ShipStatsCalculator
from ship_physics import ShipPhysicsMixin
from ship_combat import ShipCombatMixin
from game.simulation.systems.resource_manager import ResourceRegistry

if TYPE_CHECKING:
    pass

def get_or_create_validator():
    val = get_validator()
    if not val:
        val = ShipDesignValidator()
        RegistryManager.instance().set_validator(val)
    return val
 



def load_vehicle_classes(filepath: str = "data/vehicleclasses.json", layers_filepath: Optional[str] = None) -> None:
    """
    Load vehicle class definitions from JSON.
    This should be called explicitly during game initialization.
    """
    
    # Check if we need to resolve path relative to this file
    if not os.path.exists(filepath):
        # Try finding it relative to module
        base_dir = os.path.dirname(os.path.abspath(__file__))
        abs_path = os.path.join(base_dir, filepath)
        if os.path.exists(abs_path):
            filepath = abs_path

    # Try to load layer definitions
    layer_definitions = {}
    
    if layers_filepath:
        layers_path = layers_filepath
    else:
        layers_path = os.path.join(os.path.dirname(filepath), "vehiclelayers.json")
        
    if os.path.exists(layers_path):
        try:
            with open(layers_path, 'r') as f:
                layer_data = json.load(f)
                layer_definitions = layer_data.get('definitions', {})
                print(f"Loaded {len(layer_definitions)} layer configurations from {os.path.basename(layers_path)}.")
        except Exception as e:
            print(f"Error loading layers from {layers_path}: {e}")
            
    try:
        with open(filepath, 'r') as f:
            data = json.load(f)
            # Update in place to preserve references
            classes = get_vehicle_classes()
            classes.clear()
            
            raw_classes = data.get('classes', {})
            
            # Post-process to resolve layer configurations
            for cls_name, cls_def in raw_classes.items():
                if 'layer_config' in cls_def:
                     config_id = cls_def['layer_config']
                     if config_id in layer_definitions:
                         cls_def['layers'] = layer_definitions[config_id]
                     else:
                         print(f"Warning: Class {cls_name} references unknown layer config {config_id}")
            
            classes.update(raw_classes)
            

            print(f"Loaded {len(classes)} vehicle classes.")
    except FileNotFoundError:
        print(f"Warning: {filepath} not found, using defaults")
        defaults = {
            "Escort": {"hull_mass": 50, "max_mass": 1000, "requirements": {}},
            "Frigate": {"hull_mass": 100, "max_mass": 2000, "requirements": {}},
            "Destroyer": {"hull_mass": 200, "max_mass": 4000, "requirements": {}},
            "Cruiser": {"hull_mass": 400, "max_mass": 8000, "requirements": {}},
            "Battlecruiser": {"hull_mass": 800, "max_mass": 16000, "requirements": {}},
            "Battleship": {"hull_mass": 1600, "max_mass": 32000, "requirements": {}},
            "Dreadnought": {"hull_mass": 3200, "max_mass": 64000, "requirements": {}}
        }
        classes = get_vehicle_classes()
        classes.clear()
        classes.update(defaults)
        


def initialize_ship_data(base_path: Optional[str] = None) -> None:
    """Facade for initializing all ship-related data."""
    if base_path:
        path = os.path.join(base_path, "data", "vehicleclasses.json")
        load_vehicle_classes(path)
    else:
        load_vehicle_classes()

class Ship(PhysicsBody, ShipPhysicsMixin, ShipCombatMixin):
    def __init__(self, name: str, x: float, y: float, color: Union[Tuple[int, int, int], List[int]], 
                 team_id: int = 0, ship_class: str = "Escort", theme_id: str = "Federation"):
        super().__init__(x, y)
        self.name: str = name
        self.color: Union[Tuple[int, int, int], List[int]] = color
        self.team_id: int = team_id
        self.current_target: Optional[Any] = None
        self.secondary_targets: List[Any] = []  # List of additional targets
        self.max_targets: int = 1         # Default 1 target (primary only)
        self.ship_class: str = ship_class
        self.theme_id: str = theme_id
        
        # Get class definition
        class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})

        # Initialize Layers dynamically from class definition
        self._initialize_layers()
        
        # Auto-equip default Hull component if defined for this class
        default_hull_id = class_def.get('default_hull_id')
        hull_equipped = False
        if default_hull_id:
            hull_component = create_component(default_hull_id)
            if hull_component:
                # Direct append to avoid validation during init
                self.layers[LayerType.CORE]['components'].append(hull_component)
                hull_component.layer_assigned = LayerType.CORE
                hull_component.ship = self
                hull_equipped = True
        
        # Stats
        self.mass: float = 0.0
        # base_mass is 0 if Hull component equipped (Hull provides mass as component)
        # Otherwise use legacy hull_mass from vehicle class as fallback
        self.base_mass: float = 0.0 if hull_equipped else class_def.get('hull_mass', 50)
        self.vehicle_type: str = class_def.get('type', "Ship")
        self.total_thrust: float = 0.0
        self.max_speed: float = 0.0
        self.turn_speed: float = 0.0
        self.target_speed: float = 0.0 # New Target Speed Control
        
        # Budget
        self.max_mass_budget: float = class_def.get('max_mass', 1000)
        
        self.radius: float = 40.0 # Will be recalculated
        
        # Resources (New System)
        self.resources = ResourceRegistry()
        
        # Resource initialization tracking
        self._resources_initialized: bool = False
        
        # To-Hit stats initialized in canonical block below (lines ~202-203)
        self.total_defense_score = 0.0 # Score (Size + Maneuver + ECM)
        self.emissive_armor = 0
        self.crystalline_armor = 0
        
        # Shield Stats (Still specific for now)
        self.max_shields: int = 0
        self.current_shields: float = 0.0
        self.shield_regen_rate: float = 0.0
        self.shield_regen_cost: float = 0.0
        self.repair_rate: float = 0.0
        
        # New Stats
        self.mass_limits_ok: bool = True
        self.layer_status: Dict[LayerType, Dict[str, Any]] = {}
        self._cached_summary = {}  # Performance optimization for UI
        self._loading_warnings: List[str] = []
        
        # Old init values
        self.current_mass: float = 0.0 
        
        self.is_alive: bool = True
        self.is_derelict: bool = False
        self.bridge_destroyed: bool = False
        
        # AI Strategy
        self.ai_strategy: str = "standard_ranged"
        self.source_file: Optional[str] = None
        
        # Formation Attributes
        self.formation_master: Optional[Any] = None      # Reference to master ship object
        self.formation_offset: Optional[Any] = None      # Vector2 offset relative to master
        self.formation_rotation_mode: str = 'relative' # 'relative' or 'fixed'
        self.formation_members: List[Any] = []       # List of followers (if this is master)
        self.in_formation: bool = True          # Flag to track if ship is currently holding formation
        self.turn_throttle: float = 1.0          # Multiplier for max speed (0.0 to 1.0)
        self.engine_throttle: float = 1.0        # Multiplier for max speed (0.0 to 1.0)
        
        # Arcade Physics
        self.current_speed: float = 0.0
        self.acceleration_rate: float = 0.0
        self.is_thrusting: bool = False
        self.comp_trigger_pulled: bool = False
        
        # Aiming
        self.aim_point: Optional[Any] = None
        self.just_fired_projectiles: List[Any] = []
        self.total_shots_fired: int = 0
        
        # To-Hit Calculation Stats
        self.to_hit_profile: float = 1.0       # Defensive Multiplier
        self.baseline_to_hit_offense: float = 1.0 # Offensive Multiplier
        
        # Initialize helper (lazy or eager)
        self.stats_calculator: Optional[ShipStatsCalculator] = None



    @property
    def max_hp(self) -> int:
        """Total HP of all components."""
        total = 0
        for layer in self.layers.values():
            for c in layer['components']:
                total += c.max_hp
        return total

    @property
    def hp(self) -> int:
        """Current HP of all components."""
        total = 0
        for layer in self.layers.values():
            for c in layer['components']:
                total += c.current_hp
        return total

    @property
    def max_weapon_range(self) -> float:
        """Calculate maximum range of all equipped weapons."""
        from game.simulation.components.abilities import SeekerWeaponAbility, WeaponAbility
        max_rng = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                for ab in comp.ability_instances:
                    # Polymorphic check using isinstance (Phase 2 Task 2.5)
                    if not isinstance(ab, WeaponAbility):
                        continue
                    
                    rng = getattr(ab, 'range', 0.0)
                    # For SeekerWeapons, calculate range from endurance if not set
                    if isinstance(ab, SeekerWeaponAbility):
                        if rng <= 0 and hasattr(ab, 'projectile_speed') and hasattr(ab, 'endurance'):
                            rng = ab.projectile_speed * ab.endurance
                             
                    if rng > max_rng:
                        max_rng = rng

        return max_rng if max_rng > 0 else 0.0

    def update(self, dt: float = 0.01, context: Optional[dict] = None) -> None:
        """
        Update ship state (physics, combat, resources).
        """
        if not self.is_alive:
            return

        # 1. Update Resources (Regeneration) - Tick-based
        if self.resources:
             self.resources.update()

        # 2. Update Components (Consumption, Cooldowns) - Tick-based
        for layer in self.layers.values():
            for comp in layer['components']:
                if comp.is_active:
                    comp.update()
        
        # 3. Physics (Thrust calc handling operational engines)
        self.update_physics_movement()
        
        # PhysicsBody.update() (Applies velocity to position)
        super().update(dt)
        
        # 4. Combat Cooldowns (Shields/Repair/Custom Logic)
        self.update_combat_cooldowns()

        # 5. Firing Logic (Link AI trigger to Combat System)
        if self.comp_trigger_pulled:
            new_attacks = self.fire_weapons(context)
            if new_attacks:
                self.just_fired_projectiles.extend(new_attacks)

    def update_derelict_status(self) -> None:
        """
        Update is_derelict status based on vehicle class requirements.
        If essential components (e.g. Bridge) are destroyed, ship becomes derelict.
        
        Requirements format (from vehicleclasses.json):
        {
            "command": {"ability": "CommandAndControl", "min_value": true},
            "propulsion": {"ability": "CombatPropulsion", "min_value": 1}
        }
        """
        # 1. Get Requirements
        class_def = get_vehicle_classes().get(self.ship_class, {})
        requirements = class_def.get('requirements', {})
        
        # 2. If no requirements, never derelict (unless dead)
        if not requirements:
            self.is_derelict = False
            return

        # 3. Calculate Current Active Abilities
        active_components = [
            c for layer in self.layers.values()
            for c in layer['components']
            if c.is_active and c.current_hp > 0
        ]
        
        if not self.stats_calculator:
            self.stats_calculator = ShipStatsCalculator(get_vehicle_classes())
             
        # Recalculate abilities based on currently living components
        totals = self.stats_calculator.calculate_ability_totals(active_components)
        
        # 5. Check all Requirements (new nested format)
        is_derelict = False
        for req_name, req_spec in requirements.items():
            # Handle new nested format: {"ability": "...", "min_value": ...}
            if isinstance(req_spec, dict) and 'ability' in req_spec:
                ability_name = req_spec['ability']
                min_val = req_spec.get('min_value', 1)
                current_val = totals.get(ability_name, 0)
                
                if isinstance(min_val, bool):
                    if min_val and not current_val:
                        is_derelict = True
                        break
                elif isinstance(min_val, (int, float)):
                    if current_val < min_val:
                        is_derelict = True
                        break
            # Legacy flat format: "AbilityName": min_value
            else:
                current_val = totals.get(req_name, 0)
                min_val = req_spec
                
                if isinstance(min_val, bool):
                    if min_val and not current_val:
                        is_derelict = True
                        break
                elif isinstance(min_val, (int, float)):
                    if current_val < min_val:
                        is_derelict = True
                        break
        
        if is_derelict and not self.is_derelict:
            print(f"{self.name} has become DERELICT (Requirements not met)")
            
        self.is_derelict = is_derelict

    def _initialize_layers(self) -> None:
        """Initialize or Re-initialize layers based on current ship_class."""
        class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
        self.layers = {}
        layer_defs = class_def.get('layers', [])
        
        # Fallback if no layers defined in vehicle class
        if not layer_defs:
            layer_defs = [
                { "type": "CORE", "radius_pct": 0.2, "restrictions": [] },
                { "type": "INNER", "radius_pct": 0.5, "restrictions": [] },
                { "type": "OUTER", "radius_pct": 0.8, "restrictions": [] },
                { "type": "ARMOR", "radius_pct": 1.0, "restrictions": [] }
            ]
            
        for l_def in layer_defs:
            l_type_str = l_def.get('type')
            try:
                l_type = LayerType[l_type_str]
                self.layers[l_type] = {
                    'components': [],
                    'radius_pct': l_def.get('radius_pct', 0.5),
                    'restrictions': l_def.get('restrictions', []),
                    'max_mass_pct': l_def.get('max_mass_pct', 1.0),
                    'hp_pool': 0, 'max_hp_pool': 0, 'mass': 0, 'hp': 0
                }
            except KeyError:
                print(f"Warning: Unknown LayerType {l_type_str} in class {self.ship_class}")

        # Recalculate layer radii based on max_mass_pct (Area proportional to mass capacity)
        # Sort layers: CORE -> INNER -> OUTER -> ARMOR
        layer_order = [LayerType.CORE, LayerType.INNER, LayerType.OUTER, LayerType.ARMOR]
        
        # Filter layers present in this ship
        present_layers = [l for l in layer_order if l in self.layers]
        
        # Calculate total mass capacity (sum of max_mass_pct)
        total_capacity_pct = sum(self.layers[l]['max_mass_pct'] for l in present_layers)
        
        if total_capacity_pct > 0:
            cumulative_mass_pct = 0.0
            for l_type in present_layers:
                cumulative_mass_pct += self.layers[l_type]['max_mass_pct']
                # Area = pi * r^2. Mass proportional to Area.
                # Mass_ratio = Current_Cumulative / Total
                # Radius_ratio = sqrt(Mass_ratio)
                self.layers[l_type]['radius_pct'] = math.sqrt(cumulative_mass_pct / total_capacity_pct)
        else:
            # Fallback if no mass limits defined (shouldn't happen with new data)
            pass

    def change_class(self, new_class: str, migrate_components: bool = False) -> None:
        """
        Change the ship class and optionally migrate components.
        
        Args:
            new_class: The new class name (e.g. "Cruiser")
            migrate_components: If True, attempts to keep components and fit them into new layers.
                                If False, clears all components.
        """
        if new_class not in get_vehicle_classes():
            print(f"Error: Unknown class {new_class}")
            return

        old_components = []
        if migrate_components:
            # Flatten all components with their original layer
            for l_type, data in self.layers.items():
                for comp in data['components']:
                    old_components.append((comp, l_type))
        
        # Update Class
        self.ship_class = new_class
        class_def = get_vehicle_classes()[self.ship_class]
        self.base_mass = class_def.get('hull_mass', 50)
        self.vehicle_type = class_def.get('type', "Ship")
        self.max_mass_budget = class_def.get('max_mass', 1000)
        
        # Re-initialize Layers (clears self.layers)
        self._initialize_layers()
        self.current_mass = 0.0 # Reset mass accumulator
        
        if migrate_components:
            # Attempt to restore components
            for comp, old_layer in old_components:
                added = False
                
                # 1. Try original layer
                if old_layer in self.layers:
                    if self.add_component(comp, old_layer):
                         added = True
                
                # 2. If failed, try all other layers in the new ship
                if not added:
                    for layer_type in self.layers.keys():
                        if layer_type == old_layer: continue 
                        
                        if self.add_component(comp, layer_type):
                            added = True
                            break
                
                if not added:
                    print(f"Warning: Could not fit component {comp.name} during refit to {new_class}")
        
        # Finally recalculate stats
        self.recalculate_stats()

    def add_component(self, component: Component, layer_type: LayerType) -> bool:
        """Validate and add a component to the specified layer."""
        if component is None:
             print("Error: Attempted to add None component to ship")
             return False

        result = get_or_create_validator().validate_addition(self, component, layer_type)
        
        if not result.is_valid:
             for err in result.errors:
                 print(f"Error: {err}")
             return False

        self.layers[layer_type]['components'].append(component)
        component.layer_assigned = layer_type
        component.ship = self
        component.recalculate_stats()
        self.current_mass += component.mass
        self._cached_summary = {}  # Invalidate cache
        
        # Update Stats
        self.recalculate_stats()
        return True

    @property
    def cached_summary(self):
        """Cached dictionary of high-level ship stats (DPS, Speed, etc)."""
        return self._cached_summary

    def add_components_bulk(self, component: Component, layer_type: LayerType, count: int) -> int:
        """
        Add multiple copies of a component to the specified layer.
        Performs validation for each addition but defers full ship stat recalculation until the end.
        Returns the number of components successfully added.
        """
        added_count = 0
        
        # Loop to add
        for _ in range(count):
            # Must clone for each new instance
            new_comp = component.clone()
            
            # Use the global validator
            result = get_or_create_validator().validate_addition(self, new_comp, layer_type)
            if not result.is_valid:
                # Stop adding if we hit a limit
                if added_count == 0:
                    # If the very first one fails, print errors
                    for err in result.errors:
                        print(f"Error: {err}")
                break
                
            self.layers[layer_type]['components'].append(new_comp)
            new_comp.layer_assigned = layer_type
            new_comp.ship = self
            new_comp.recalculate_stats()
            self.current_mass += new_comp.mass
            added_count += 1
            
        if added_count > 0:
            self.recalculate_stats()
            
        return added_count

    def remove_component(self, layer_type: LayerType, index: int) -> Optional[Component]:
        """Remove a component from the specified layer by index."""
        if 0 <= index < len(self.layers[layer_type]['components']):
            comp = self.layers[layer_type]['components'].pop(index)
            self.current_mass -= comp.mass
            self.recalculate_stats()
            return comp
        return None

    def recalculate_stats(self) -> None:
        """
        Recalculates derived stats. Delegates to ShipStatsCalculator.
        """
        # 1. Update Base Class Specs (ensure budget is fresh for scaling modifiers)
        classes = get_vehicle_classes()
        if self.ship_class in classes:
             cdef = classes[self.ship_class]
             self.max_mass_budget = cdef.get('max_mass', 1000)

        # 2. Update components with current ship context
        for layer_data in self.layers.values():
            for comp in layer_data['components']:
                # Ensure ship ref is set
                if not getattr(comp, 'ship', None): comp.ship = self
                comp.recalculate_stats()

        if not self.stats_calculator:
             self.stats_calculator = ShipStatsCalculator(classes)
        
        self.stats_calculator.calculate(self)

    def get_missing_requirements(self) -> List[str]:
        """Check class requirements and return list of missing items based on abilities."""
        # Use centralized validator
        result = get_or_create_validator().validate_design(self)
        if result.is_valid:
            return []
        # Return all errors as list of strings
        return [f"⚠ {err}" for err in result.errors]

    def get_validation_warnings(self) -> List[str]:
        """Check class requirements and return list of warnings (soft requirements)."""
        result = get_or_create_validator().validate_design(self)
        return result.warnings
    
    def _format_ability_name(self, ability_name: str) -> str:
        """Convert ability ID to readable name."""
        import re
        return re.sub(r'(?<!^)(?=[A-Z])', ' ', ability_name)
    
    def get_ability_total(self, ability_name: str) -> Union[float, int, bool]:
        """Get total value of a specific ability across all components."""
        all_components = [c for layer in self.layers.values() for c in layer['components']]
        
        if not self.stats_calculator:
             self.stats_calculator = ShipStatsCalculator(get_vehicle_classes())
             
        totals = self.stats_calculator.calculate_ability_totals(all_components)
        return totals.get(ability_name, 0)
    
    def get_total_ability_value(self, ability_name: str, operational_only: bool = True) -> float:
        """
        Sum values from all matching abilities across all components.
        Uses ability_instances (Phase 3+ API) instead of abilities dict.
        
        Args:
            ability_name: Name of ability class to sum (e.g., 'CombatPropulsion')
            operational_only: If True, only count abilities from operational components
            
        Returns:
            Sum of primary value attribute from all matching abilities
        """
        total = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                if operational_only and not comp.is_operational:
                    continue
                for ab in comp.get_abilities(ability_name):
                    # Get the primary value attribute based on ability type
                    if hasattr(ab, 'thrust_force'):
                        total += ab.thrust_force
                    elif hasattr(ab, 'turn_rate'):
                        total += ab.turn_rate
                    elif hasattr(ab, 'capacity'):
                        total += ab.capacity
                    elif hasattr(ab, 'rate'):
                        total += ab.rate
                    elif hasattr(ab, 'value'):
                        total += ab.value
        return total
    
    def get_total_sensor_score(self) -> float:
        """Calculate total Targeting Score from all active sensors."""
        total_score = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                # Phase 7: Use ability-based check
                for ab in comp.get_abilities('ToHitAttackModifier'):
                    total_score += ab.value
        return total_score

    def get_total_ecm_score(self) -> float:
        """Calculate total Evasion/Defense Score from all active ECM/Electronics."""
        total_score = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                # Phase 7: Use ability-based check
                for ab in comp.get_abilities('ToHitDefenseModifier'):
                    total_score += ab.value
        return total_score

    def check_validity(self) -> bool:
        """Check if the current ship design is valid."""
        self.recalculate_stats()
        result = get_or_create_validator().validate_design(self)
        # Check for mass errors specifically for UI feedback flag
        self.mass_limits_ok = not any("Mass budget exceeded" in e for e in result.errors)
        return result.is_valid

    @property
    def layers_dict(self) -> Dict[str, List[Any]]:
        """Helper for JSON serialization."""
        d = {}
        for l_type, data in self.layers.items():
            d[l_type.name] = []
            for comp in data['components']:
                # Minimal serialization: ID + Modifiers
                c_data = {
                    "id": comp.id,
                    "modifiers": []
                }
                for m_id, m_val in comp.modifiers.items():
                    c_data["modifiers"].append({"id": m_id, "value": m_val})
                d[l_type.name].append(c_data)
        return d

    def to_dict(self) -> Dict[str, Any]:
        """Serialize ship to dictionary."""
        data = {
            "name": self.name,
            "ship_class": self.ship_class,
            "theme_id": self.theme_id,
            "team_id": self.team_id,
            "color": self.color,
            "ai_strategy": self.ai_strategy,
            "layers": {},
            "resources": {
                "fuel": self.resources.get_value("fuel"),
                "energy": self.resources.get_value("energy"),
                "ammo": self.resources.get_value("ammo"),
            },
            "expected_stats": {
                "max_hp": self.max_hp,
                "max_fuel": self.resources.get_max_value("fuel"),
                "max_energy": self.resources.get_max_value("energy"),
                "max_ammo": self.resources.get_max_value("ammo"),
                "max_speed": self.max_speed,
                "acceleration_rate": self.acceleration_rate,
                "turn_speed": self.turn_speed,
                "total_thrust": self.total_thrust,
                "mass": self.mass,
                "armor_hp_pool": self.layers[LayerType.ARMOR]['max_hp_pool'] if LayerType.ARMOR in self.layers else 0
            }
        }
        
        for ltype, layer_data in self.layers.items():
            filter_comps = []
            for comp in layer_data['components']:
                # Skip Hull components - they are auto-equipped on load
                if comp.id.startswith('hull_'):
                    continue
                # Save as dict with modifiers
                c_obj = {"id": comp.id}
                if comp.modifiers:
                    c_obj["modifiers"] = [{"id": k, "value": v} for k, v in comp.modifiers.items()]
                filter_comps.append(c_obj)
                
            data["layers"][ltype.name] = filter_comps
        return data

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Ship':
        """Create ship from dictionary."""
        name = data.get("name", "Unnamed")
        color_val = data.get("color", (200, 200, 200))
        # Ensure color is tuple
        color: tuple
        if isinstance(color_val, list): 
            color = tuple(color_val)
        else:
            color = color_val # type: ignore
        
        s = Ship(name, 0, 0, color, data.get("team_id", 0), ship_class=data.get("ship_class", "Escort"), theme_id=data.get("theme_id", "Federation"))
        s.ai_strategy = data.get("ai_strategy", "standard_ranged")
        
        for l_name, comps_list in data.get("layers", {}).items():
            layer_type = None
            try:
                layer_type = LayerType[l_name]
            except KeyError:
                continue
                
            # Skip if this layer is not defined in the ship's class
            if layer_type not in s.layers:
                 continue
            
            for c_entry in comps_list:
                comp_id = ""
                modifiers_data = []
                
                if isinstance(c_entry, str):
                    comp_id = c_entry
                elif isinstance(c_entry, dict):
                    comp_id = c_entry.get("id", "")
                    modifiers_data = c_entry.get("modifiers", [])
                
                comps = get_component_registry()
                if comp_id in comps:
                    new_comp = comps[comp_id].clone()
                    
                    # Apply Modifiers
                    mods = get_modifier_registry()
                    for m_dat in modifiers_data:
                        mid = m_dat['id']
                        mval = m_dat['value']
                        if mid in mods:
                            new_comp.add_modifier(mid, mval)

                    s.add_component(new_comp, layer_type)
        
        s.recalculate_stats()
    
        # Restore resource values if saved
        saved_resources = data.get('resources', {})
        if saved_resources:
            for resource_name, value in saved_resources.items():
                if value is not None:
                    s.resources.set_value(resource_name, value)
        
        # Verify loaded stats match expected stats (if saved)
        expected = data.get('expected_stats', {})
        if expected:
            mismatches = []
            if expected.get('max_hp') and abs(s.max_hp - expected['max_hp']) > 1:
                mismatches.append(f"max_hp: got {s.max_hp}, expected {expected['max_hp']}")
            
            val = s.resources.get_max_value("fuel")
            if expected.get('max_fuel') and abs(val - expected['max_fuel']) > 1:
                mismatches.append(f"max_fuel: got {val}, expected {expected['max_fuel']}")
            
            val = s.resources.get_max_value("energy")
            if expected.get('max_energy') and abs(val - expected['max_energy']) > 1:
                mismatches.append(f"max_energy: got {val}, expected {expected['max_energy']}")
            
            val = s.resources.get_max_value("ammo")
            if expected.get('max_ammo') and abs(val - expected['max_ammo']) > 1:
                mismatches.append(f"max_ammo: got {val}, expected {expected['max_ammo']}")
            if expected.get('max_speed') and abs(s.max_speed - expected['max_speed']) > 0.1:
                mismatches.append(f"max_speed: got {s.max_speed:.1f}, expected {expected['max_speed']:.1f}")
            if expected.get('acceleration_rate') and abs(s.acceleration_rate - expected['acceleration_rate']) > 0.001:
                mismatches.append(f"acceleration_rate: got {s.acceleration_rate:.3f}, expected {expected['acceleration_rate']:.3f}")
            if expected.get('turn_speed') and abs(s.turn_speed - expected['turn_speed']) > 0.1:
                mismatches.append(f"turn_speed: got {s.turn_speed:.1f}, expected {expected['turn_speed']:.1f}")
            if expected.get('total_thrust') and abs(s.total_thrust - expected['total_thrust']) > 1:
                mismatches.append(f"total_thrust: got {s.total_thrust}, expected {expected['total_thrust']}")
            if expected.get('mass') and abs(s.mass - expected['mass']) > 1:
                mismatches.append(f"mass: got {s.mass}, expected {expected['mass']}")
            armor_hp = s.layers[LayerType.ARMOR]['max_hp_pool'] if LayerType.ARMOR in s.layers else 0
            if expected.get('armor_hp_pool') and abs(armor_hp - expected['armor_hp_pool']) > 1:
                mismatches.append(f"armor_hp_pool: got {armor_hp}, expected {expected['armor_hp_pool']}")
            
            s._loading_warnings = mismatches
            
            if mismatches:
                print(f"WARNING: Ship '{s.name}' stats mismatch after loading!")
                for m in mismatches:
                    print(f"  - {m}")
        
        return s




    


--- END FILE: game/simulation/entities/ship.py ---

[WARNING: File not found: game/data/load_vehicle_classes.py]

--- START FILE: game/simulation/components/component.py ---
import json
import math
from enum import Enum, auto
from formula_system import evaluate_math_formula
from game.core.registry import get_component_registry, get_modifier_registry

class ComponentStatus(Enum):
    ACTIVE = auto()
    DAMAGED = auto() # >50% damage
    NO_CREW = auto()
    NO_POWER = auto()
    NO_FUEL = auto()
    NO_AMMO = auto()

class LayerType(Enum):
    CORE = 1
    INNER = 2
    OUTER = 3
    ARMOR = 4

    @staticmethod
    def from_string(s):
        return getattr(LayerType, s.upper())

class Modifier:
    def __init__(self, data):
        self.id = data['id']
        self.name = data['name']
        self.type_str = data['type'] # 'boolean' or 'linear'
        self.description = data.get('description', '')
        self.effects = data.get('effects', {})
        self.restrictions = data.get('restrictions', {})
        self.param_name = data.get('param_name', 'value')
        self.min_val = data.get('min_val', 0)
        self.max_val = data.get('max_val', 100)
        self.default_val = data.get('default_val', self.min_val)
        self.readonly = data.get('readonly', False)

    def create_modifier(self, value=None):
        return ApplicationModifier(self, value)



class ApplicationModifier:
    """Instance of a modifier applied to a component"""
    def __init__(self, mod_def, value=None):
        self.definition = mod_def
        self.value = value if value is not None else mod_def.default_val

# IMPORTS MOVED TO LOCAL SCOPE TO PREVENT CIRCULAR DEPENDENCY
# from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability

class Component:
    def __init__(self, data):
        import copy
        self.data = copy.deepcopy(data) # Store raw data for reference/cloning
        self.id = data['id']
        self.name = data['name']
        self.base_mass = data['mass']
        self.mass = self.base_mass
        self.base_max_hp = data['hp']
        self.max_hp = self.base_max_hp
        self.current_hp = self.max_hp
        


        # allowed_layers removed in refactor
        # self.allowed_layers = [LayerType.from_string(l) for l in data['allowed_layers']]
        self.allowed_vehicle_types = data.get('allowed_vehicle_types', ["Ship"])
        self.major_classification = data.get('major_classification', "Unknown")
        self.is_active = True
        self.status = ComponentStatus.ACTIVE
        self.layer_assigned = None
        self.type_str = data['type']
        self.sprite_index = data.get('sprite_index', 0)
        self.cost = data.get('cost', 0)
        
        
        # Parse abilities from data
        self.abilities = self.data.get('abilities', {})
        


        
        self.base_abilities = copy.deepcopy(self.abilities)
        
        self.ship = None # Container reference
        
        self.stats = {} # Current stats dictionary (calcualted)
        self.modifiers = [] # list of ApplicationModifier
        
        # Ability Instances (New System)
        self.ability_instances = []
        self._is_operational = True # Tracks if component has resources to operate
        
        # Instantiate Abilities
        self._instantiate_abilities()
        
        # Load default modifiers from data definition
        if 'modifiers' in self.data:
            for mod_data in self.data['modifiers']:
                mod_id = mod_data['id']
                val = mod_data.get('value', None)
                # We need to access modifier registry.
                from game.core.registry import get_modifier_registry
                mods = get_modifier_registry()
                if mod_id in mods:
                    mod_def = mods[mod_id]
                    self.modifiers.append(mod_def.create_modifier(val))
                else:
                    # If modifiers loaded later, this might fail. 
                    # Ideally modifiers are loaded before components.
                    pass
                    
        # Parse Formulas
        self.formulas = {}
        for key, value in self.data.items():
            if isinstance(value, str) and value.startswith("="):
                # It's a formula!
                self.formulas[key] = value[1:] # Store without '='
                # Initialize base value to something safe? Or keep it as is?
                # Probably keep undefined or 0 until recalculated? 
                # Better to set a default if possible, but hard to guess.
                # If it's mass/hp, 0 is safer than crashing.
                if key in ['mass', 'hp', 'cost']:
                     setattr(self, f"base_{key}" if key in ['mass', 'hp'] else key, 0)
                     if key == 'mass': self.mass = 0
                     if key == 'hp': 
                         self.max_hp = 0
                         self.current_hp = 0

    def get_abilities(self, ability_name: str):
        """
        Get all abilities of a specific type (by registry name).
        Supports polymorphism if the registry entry is a class.
        """
        from game.simulation.components.abilities import ABILITY_REGISTRY
        
        target_class = None
        if ability_name in ABILITY_REGISTRY:
            val = ABILITY_REGISTRY[ability_name]
            if isinstance(val, type):
                target_class = val
        
        found = []
        for ab in self.ability_instances:
            # 1. Polymorphic check (preferred)
            if target_class and isinstance(ab, target_class):
                found.append(ab)
            # 2. Hierarchy Name check (Strong fallback for Module Identity Drift in tests)
            else:
                # Check if the ability name matches any class in the inheritance chain
                for cls in ab.__class__.mro():
                    if cls.__name__ == ability_name:
                        found.append(ab)
                        break
        return found

    def get_ability(self, ability_name: str):
        """Get first ability of type."""
        l = self.get_abilities(ability_name)
        return l[0] if l else None

    def has_ability(self, ability_name: str):
        # 1. Direct check (fast)
        if ability_name in self.abilities:
            return True
        # 2. Polymorphic check (e.g. asking for 'WeaponAbility' when we have 'ProjectileWeaponAbility')
        return len(self.get_abilities(ability_name)) > 0

    def has_pdc_ability(self) -> bool:
        """Check if component has a Point Defense weapon ability.
        
        Returns True if any ability has 'pdc' in its tags.
        """
        # 1. Check new tag-based system
        for ab in self.ability_instances:
            if 'pdc' in ab.tags:
                return True
        

        return False



    @property
    def cooldown_timer(self):
        # Map to first weapon ability if present
        ab = self.get_ability('WeaponAbility')
        if ab: return ab.cooldown_timer
        return 0.0
        
    @cooldown_timer.setter
    def cooldown_timer(self, value):
        ab = self.get_ability('WeaponAbility')
        if ab: ab.cooldown_timer = float(value)

    def get_ui_rows(self):
        """Aggregate UI rows from all ability instances.
        
        Returns list of dicts: [{'label': 'Thrust', 'value': '1500 N'}, ...]
        Used by detail panels and capability scanners.
        """
        rows = []
        for ab in self.ability_instances:
            rows.extend(ab.get_ui_rows())
        return rows

    def _instantiate_abilities(self):
        """Instantiate or Sync Ability objects from self.abilities dict."""
        # We want to preserve existing instances to maintain runtime state (cooldowns, energy)
        # but also add new ones or remove obsolete ones.
        
        # 1. Map existing instances for quick lookup
        # Key: (ability_type_name, index_in_that_type)
        existing_map = {}
        for ab in self.ability_instances:
            # We track by class name
            cls_name = ab.__class__.__name__
            if cls_name not in existing_map:
                existing_map[cls_name] = []
            existing_map[cls_name].append(ab)

        new_instances = []
        
        # Standard Loading from abilities dict
        from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability
        
        for name, data in self.abilities.items():
            if name not in ABILITY_REGISTRY:
                continue
            
            items = data if isinstance(data, list) else [data]
            
        # Get the target class for this registry entry (could be class or lambda)
            target = ABILITY_REGISTRY[name]
            target_cls_name = None
            if isinstance(target, type):
                target_cls_name = target.__name__
            else:
                # Use centralized map for shortcut factories (lambdas)
                from game.simulation.components.abilities import ABILITY_CLASS_MAP
                target_cls_name = ABILITY_CLASS_MAP.get(name)

            for item in items:
                # Heuristic: Match by Target Class Name if known, otherwise fallback to registry name
                match_name = target_cls_name or name
                
                found_existing = False
                if match_name in existing_map and existing_map[match_name]:
                    ab = existing_map[match_name].pop(0)
                    # Support live data sync if ability supports it
                    if hasattr(ab, 'sync_data'):
                        ab.sync_data(item)
                    new_instances.append(ab)
                    found_existing = True
                
                if not found_existing:
                    ab = create_ability(name, self, item)
                    if ab: new_instances.append(ab)
        
        self.ability_instances = new_instances
            
    def update(self):
        """Update component state for one tick (resource consumption, cooldowns)."""
        # 1. Update Abilities (Constant Consumption)
        all_satisfied = True
        
        for ability in self.ability_instances:
            if not ability.update():
                from game.simulation.systems.resource_manager import ResourceConsumption
                if isinstance(ability, ResourceConsumption) and ability.trigger == 'constant':
                     all_satisfied = False
        
        self._is_operational = all_satisfied and self.is_active

    @property
    def is_operational(self):
        return self._is_operational and self.is_active

    def can_afford_activation(self):
        """Check if component can afford activation costs."""
        from game.simulation.systems.resource_manager import ResourceConsumption
        for ability in self.ability_instances:
            if isinstance(ability, ResourceConsumption) and ability.trigger == 'activation':
                if not ability.check_available():
                    return False
        return True

    def consume_activation(self):
        """Consume activation costs."""
        for ability in self.get_abilities('ResourceConsumption'):
            if ability.trigger == 'activation':
                ability.check_and_consume()

    def try_activate(self):
        """Check if component can afford activation costs, consume them if available, and return True on success."""
        if self.can_afford_activation():
            self.consume_activation()
            return True
        return False




    def take_damage(self, amount):
        # Defensive check for MagicMock or non-numeric types
        if not isinstance(amount, (int, float)):
            try: amount = float(amount)
            except: amount = 0 # Fallback for pure mocks
            
        self.current_hp -= amount
        
        # Update Status
        if isinstance(self.current_hp, (int, float)) and self.current_hp <= 0:
            self.current_hp = 0
            self.is_active = False
            return True # Destroyed
        
        # Logic Repair: Update status to DAMAGED if below 50%
        # Defensive check for max_hp and current_hp types
        if isinstance(self.current_hp, (int, float)) and isinstance(self.max_hp, (int, float)):
             if self.current_hp < (self.max_hp * 0.5):
                 self.status = ComponentStatus.DAMAGED
            
        return False

    def reset_hp(self):
        self.current_hp = self.max_hp
        self.is_active = True
        self.status = ComponentStatus.ACTIVE

    def add_modifier(self, mod_id, value=None):
        mods = get_modifier_registry()
        if mod_id not in mods: return False
        
        # Check restrictions
        mod_def = mods[mod_id]
        if 'deny_types' in mod_def.restrictions:
            if self.type_str in mod_def.restrictions['deny_types']:
                return False
        if 'allow_types' in mod_def.restrictions:
            if self.type_str not in mod_def.restrictions['allow_types']:
                return False
                
        # Remove existing if any (replace)
        self.remove_modifier(mod_id)
            
        app_mod = ApplicationModifier(mod_def, value)
        self.modifiers.append(app_mod)
        self.recalculate_stats()
        return True

    def remove_modifier(self, mod_id):
        self.modifiers = [m for m in self.modifiers if m.definition.id != mod_id]
        self.recalculate_stats()

    def get_modifier(self, mod_id):
        for m in self.modifiers:
            if m.definition.id == mod_id:
                return m
        return None
        


    def recalculate_stats(self):
        """Recalculate component stats with multiplicative modifier stacking."""
        # Capture old hp for current_hp logic at end
        old_max_hp = self.max_hp

        # 1. Reset and Evaluate Base Formulas
        self._reset_and_evaluate_base_formulas()
        
        # 1.5 Re-instantiate Abilities (Sync instances with new abilities dict)
        self._instantiate_abilities()

        # 2. Calculate Modifier Stats (Accumulate multipliers)
        stats = self._calculate_modifier_stats()
        self.stats = stats # Persist for introspection/ability access

        # 3. Apply Base Stats (Generic attributes)
        self._apply_base_stats(stats, old_max_hp)
        
        # 4. Apply Custom/Subclass Stats
        self._apply_custom_stats(stats)



    def _reset_and_evaluate_base_formulas(self):
        import copy
        # Reset abilities from raw data
        self.abilities = copy.deepcopy(self.data.get('abilities', {}))
        
        # Context building
        context = {
            'ship_class_mass': 1000 # Default fallback
        }
        if self.ship:
             context['ship_class_mass'] = getattr(self.ship, 'max_mass_budget', 1000)

        # Evaluate Formulas for attributes
        for attr, formula in self.formulas.items():
            val = evaluate_math_formula(formula, context)
            if attr == 'mass':
                self.base_mass = float(val)
                self.mass = self.base_mass # Reset to base
            elif attr == 'hp':
                self.base_max_hp = int(val)
                self.max_hp = self.base_max_hp # Reset to base
            else:
                 if hasattr(self, attr):
                     if isinstance(getattr(self, attr), int):
                         setattr(self, attr, int(val))
                     else:
                         setattr(self, attr, val)
        
        # Evaluate formulas in abilities
        for ability_name, val in self.abilities.items():
            if isinstance(val, str) and val.startswith("="):
                new_val = evaluate_math_formula(val[1:], context)
                self.abilities[ability_name] = new_val
            elif isinstance(val, dict):
                 # Phase 7: Generically evaluate formulas in any key of the ability dict
                 for key, sub_val in val.items():
                     if isinstance(sub_val, str) and sub_val.startswith("="):
                         new_val = evaluate_math_formula(sub_val[1:], context)
                         val[key] = new_val

    def _calculate_modifier_stats(self):
        from game.simulation.components.modifiers import apply_modifier_effects
        stats = {
            'mass_mult': 1.0,
            'hp_mult': 1.0,
            'damage_mult': 1.0,
            'range_mult': 1.0,
            'cost_mult': 1.0,
            'thrust_mult': 1.0,
            'turn_mult': 1.0,
            'energy_gen_mult': 1.0,
            'capacity_mult': 1.0,
            'crew_capacity_mult': 1.0,
            'life_support_capacity_mult': 1.0,
            'consumption_mult': 1.0,
            'mass_add': 0.0,
            'arc_add': 0.0,
            'accuracy_add': 0.0,
            'arc_set': None,
            'properties': {},
            # New Modifier Support
            'reload_mult': 1.0,
            'endurance_mult': 1.0,
            'projectile_hp_mult': 1.0,
            'projectile_damage_mult': 1.0,
            'projectile_stealth_level': 0.0,
            'crew_req_mult': 1.0
        }
        
        for m in self.modifiers:
            apply_modifier_effects(m.definition, m.value, stats, component=self)
            
        return stats

    def _apply_base_stats(self, stats, old_max_hp):
        # Apply specific property overrides
        for prop, val in stats['properties'].items():
            if hasattr(self, prop):
                setattr(self, prop, val)

        # Apply Base Multipliers
        self.mass = (self.base_mass + stats['mass_add']) * stats['mass_mult']
        
        # Note: old_max_hp is passed in, captured before base formula reset
        self.max_hp = int(self.base_max_hp * stats['hp_mult'])
        
        if hasattr(self, 'cost'):
            self.cost = int(self.data.get('cost', 0) * stats['cost_mult'])



        # Handle HP update (healing/new component logic)
        if old_max_hp == 0:
            self.current_hp = self.max_hp
        elif self.current_hp >= old_max_hp:
            self.current_hp = self.max_hp
            
        # Ensure cap
        self.current_hp = min(self.current_hp, self.max_hp)

        # Generic Sync: Update Activation Abilities if attributes changed
        from game.simulation.systems.resource_manager import ResourceConsumption, ResourceStorage, ResourceGeneration
        
        for ab in self.ability_instances:
            # General Recalculate (Protocol for active abilities to sync with stats)
            ab.recalculate()
            
            ab_cls = ab.__class__.__name__
            ab_data = ab.data
            
            # Helper to get base value safely from dict or primitive
            def get_base(data, key, default=0.0):
                if isinstance(data, dict):
                    return data.get(key, default)
                if isinstance(data, (int, float)):
                    return float(data)
                return default

            # ResourceConsumption (Base amount * consumption_mult)
            if ab_cls == 'ResourceConsumption':
                 base = get_base(ab_data, 'amount')
                 ab.amount = base * stats.get('consumption_mult', 1.0)
            
            # ResourceStorage (Base amount * capacity_mult)
            elif ab_cls == 'ResourceStorage':
                 base = get_base(ab_data, 'amount')
                 ab.max_amount = base * stats.get('capacity_mult', 1.0)
            
            # ResourceGeneration (Base amount * energy_gen_mult)
            elif ab_cls == 'ResourceGeneration':
                 # Apply energy_gen_mult only if resource is energy, or generic 'generation_mult' if we had one.
                 if getattr(ab, 'resource_type', '') == 'energy':
                     base = get_base(ab_data, 'amount')
                     ab.rate = base * stats.get('energy_gen_mult', 1.0)



    def _apply_custom_stats(self, stats):
        """Hook for subclasses to apply specific stats."""
        # Base implementation handles Crew/LifeSupport as they are somewhat generic in this system
        pass

    def clone(self):
        # Create a new instance with the same data
        # We need a Factory, but since we are refactoring, we can just make a new instance of the same class.
        # But we need to know the class.
        return self.__class__(self.data)


# Phase 7 Simplified: Aliased types now use Component directly
# Types with custom logic (Shield, Hangar, etc.) are now also aliases
# as their logic has been unified into the Ability system.

# Export types for compatibility (Phase 6 Regression Triage)


# Caching for performance (Phase 2 Test Stabilization)
_COMPONENT_CACHE = None
_MODIFIER_CACHE = None
_LAST_COMPONENT_FILE = None
_LAST_MODIFIER_FILE = None

def load_components(filepath="data/components.json"):
    global _COMPONENT_CACHE, _LAST_COMPONENT_FILE
    import os
    import copy
    from game.core.registry import get_component_registry

    # If cache exists and matches filepath, hydrate Registry from cache (Fast Path)
    if _COMPONENT_CACHE is not None and _LAST_COMPONENT_FILE == filepath:
        comps = get_component_registry()
        for c_id, comp in _COMPONENT_CACHE.items():
            comps[c_id] = comp.clone()
        return

    # Slow Path: Load from Disk
    # Try absolute path based on this file if CWD fails
    if not os.path.exists(filepath):
        print(f"WARN: {filepath} not found in CWD ({os.getcwd()}).")
        base_dir = os.path.dirname(os.path.abspath(__file__))
        abs_path = os.path.join(base_dir, filepath)

        if os.path.exists(abs_path):
            filepath = abs_path
        else:
            print(f"ERROR: components file not found at {abs_path}")
            return

    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for comp_def in data['components']:
            c_type = comp_def['type']
            try:
                cls = Component 
                obj = cls(comp_def)
                temp_cache[comp_def['id']] = obj
            except Exception as e:
                print(f"ERROR creating component {comp_def.get('id')}: {e}")
        
        # Populate Cache
        _COMPONENT_CACHE = temp_cache
        _LAST_COMPONENT_FILE = filepath
        
        # Populate Registry from Cache
        comps = get_component_registry()
        for c_id, comp in _COMPONENT_CACHE.items():
            comps[c_id] = comp.clone()
            
    except Exception as e:
        print(f"ERROR loading/parsing components json: {e}")

def load_modifiers(filepath="data/modifiers.json"):
    global _MODIFIER_CACHE, _LAST_MODIFIER_FILE
    import os
    import copy
    from game.core.registry import get_modifier_registry
    
    # Fast Path
    if _MODIFIER_CACHE is not None and _LAST_MODIFIER_FILE == filepath:
        mods = get_modifier_registry()
        for m_id, mod in _MODIFIER_CACHE.items():
            mods[m_id] = copy.deepcopy(mod)
        return
    
    # Slow Path
    if not os.path.exists(filepath):
         base_dir = os.path.dirname(os.path.abspath(__file__))
         filepath = os.path.join(base_dir, filepath)
    
    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for mod_def in data['modifiers']:
            mod = Modifier(mod_def)
            temp_cache[mod.id] = mod
        
        _MODIFIER_CACHE = temp_cache
        _LAST_MODIFIER_FILE = filepath
        
        mods = get_modifier_registry()
        for m_id, mod in _MODIFIER_CACHE.items():
            mods[m_id] = copy.deepcopy(mod)
            
    except Exception as e:
        print(f"ERROR loading modifiers: {e}")

def create_component(component_id):
    """Create a clone of a component from the registry by ID."""
    comps = get_component_registry()
    if component_id in comps:
        return comps[component_id].clone()
    print(f"Error: Component ID {component_id} not found in registry.")
    return None

def get_all_components():
    """Get a list of all components in the registry."""
    return list(get_component_registry().values())


--- END FILE: game/simulation/components/component.py ---

--- START FILE: Refactoring/active_refactor.md ---
# Active Refactor: Hull Component & Ship Cohesion
**Goal:** Unify Ship stats with V2 Ability System (Hull Component) and eliminate architectural incoherence.

## Status
**Current Phase:** Phase 4 (UI Reconstruction) - AWAITING REVIEW
**Start Date:** 2026-01-05
**Phase 1 Review:** ✅ APPROVED (2026-01-06)
**Phase 2 Review:** ✅ APPROVED (2026-01-06)
**Phase 3 Review:** ✅ APPROVED (2026-01-06)
**Phase 4 Review:** ⏳ PENDING (2026-01-06)
**Status:** [PHASE_4_COMPLETE_PENDING_REVIEW]

---

## Migration Map (The Constitution)

| Concept | Legacy State | Target State | Source of Truth |
| :--- | :--- | :--- | :--- |
| **Hull Definition** | `vehicleclasses.json` (hull_mass, hp) | `components.json` ("type": "Hull") | Component Data |
| **Base Mass** | `Ship.base_mass` (manual float) | Sum of `Hull` component + Systems | `ShipStatsCalculator` |
| **Requirements** | Hardcoded checks & `Ship.requirements` | `CrewRequired`, `FuelStorage` Abilities | Ability System V2 |
| **Resource State** | Reset on Load (Volatile) | Persisted in `Ship.resources` | Save Data |
| **UI Layout** | Hardcoded Pixel Overlaps | Responsive/Grid-based | `builder_utils.py` |

---

## Phased Schedule

### Phase 1: Data & State Foundations (The Bedrock) [Complete]
**Objective:** Fix critical state bugs and prepare data structures.
- [x] **Critical Fix:** Patch `resource_manager.py` clamping bug (resets to 0 on overflow).
- [x] **Data Migration:** Create `Hull` components in `data/components.json` for all 18 classes. [Data Architect]
- [x] **Data Migration:** Add `default_hull_id` to `data/vehicleclasses.json`. [Data Architect]
- [x] **Serialization:** Update `Ship.to_dict`/`from_dict` to persist `ResourceRegistry` values. [Data Architect]
- [x] **Cleanup:** Remove hardcoded ability string maps in `Component._instantiate_abilities`.

---

### Phase 2: Core Logic & Stability (The Engine) [Complete]
**Objective:** Implement the "Hull as Component" logic and fix core simulation loops.
- [x] **Task 2.1:** Update `Ship.__init__` to auto-equip `default_hull_id`. [Core Engineer]
- [ ] **Task 2.2:** Switch `Ship.mass` and `Ship.hp` to cached properties in `ShipStatsCalculator`. (DEFERRED - optimization)
- [x] **Task 2.3:** Implement `CommandAndControl` and `CrewRequired` logic in `update_derelict_status`.
- [x] **Task 2.4:** Remove duplicate To-Hit/Derelict initializations in `Ship.py`.
- [x] **Task 2.5:** Standardize MRO-based identity checks (remove brittle class name checks).
- [x] **Task 2.6:** Fix detail panel rendering test regressions. [UI Specialist]
  - **File:** `tests/unit/ui/test_detail_panel_rendering.py`
  - **Fix:** Added missing `uitextbox_patch_real.stop()` in tearDown to prevent patch leakage causing intermittent failures in parallel execution.

---

## Phase 2 Implementation Specifications

### Task 2.1: Auto-Equip `default_hull_id` in `Ship.__init__`
**File:** `game/simulation/entities/ship.py`
**Method:** `__init__`

**Current State (lines ~223-230):**
```python
class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
self.base_mass: float = class_def.get('hull_mass', 50)  # LEGACY
```

**Target Implementation:**
```python
from game.simulation.components.component import create_component

# In __init__, AFTER _initialize_layers():
class_def = get_vehicle_classes().get(self.ship_class, {})
default_hull_id = class_def.get('default_hull_id')

if default_hull_id:
    hull_component = create_component(default_hull_id)
    if hull_component:
        self.add_component(hull_component, LayerType.CORE)
    else:
        print(f"WARNING: Hull '{default_hull_id}' not found for {self.ship_class}")
```

**Steps:**
1. Import `create_component` from `game.simulation.components.component`.
2. Remove `self.base_mass` assignment from `class_def.get('hull_mass', ...)`.
3. After `_initialize_layers()`, lookup `default_hull_id` and call `create_component()`.
4. Add Hull to `CORE` layer via `add_component()`.

**Edge Cases:**
- Missing `default_hull_id` → Log warning, continue (test-only ships).
- Component registry not loaded → Graceful `None` return from `create_component`.

---

### Task 2.2: Cached `mass` and `hp` Properties
**Files:** `game/simulation/entities/ship.py`, `ship_stats.py`

**Current State:**
- `self.mass: float = 0.0` (direct attribute)
- `@property max_hp` / `hp` → O(n) iteration on every access

**Target Implementation in `Ship.__init__`:**
```python
self._cached_mass: float = 0.0
self._cached_max_hp: int = 0
self._cached_hp: int = 0
```

**Target Properties:**
```python
@property
def mass(self) -> float:
    return self._cached_mass

@property
def max_hp(self) -> int:
    return self._cached_max_hp

@property
def hp(self) -> int:
    return self._cached_hp
```

**In `ShipStatsCalculator.calculate(ship)`:**
```python
# Calculate and cache
total_mass = sum(c.mass for layer in ship.layers.values() for c in layer['components'])
total_max_hp = sum(c.max_hp for layer in ship.layers.values() for c in layer['components'])
total_hp = sum(c.current_hp for layer in ship.layers.values() for c in layer['components'])

ship._cached_mass = total_mass
ship._cached_max_hp = total_max_hp
ship._cached_hp = total_hp
```

---

### Task 2.3: Ability-Based Derelict Logic
**File:** `game/simulation/entities/ship.py`
**Method:** `update_derelict_status`

**New Abilities Required (in `abilities.py`):**
```python
class CommandAndControl(Ability):
    """Marks component as command center (Bridge, CIC)."""
    pass
```

**Target Implementation:**
```python
def update_derelict_status(self) -> None:
    # Check 1: Command and Control
    has_command = any(
        comp.is_operational and comp.has_ability('CommandAndControl')
        for layer in self.layers.values()
        for comp in layer['components']
    )
    
    if not has_command:
        self.is_derelict = True
        self.bridge_destroyed = True
        return
    
    # Check 2: Crew Capacity (optional)
    total_crew_req = self.get_total_ability_value('CrewRequired')
    total_crew_cap = self.get_total_ability_value('CrewCapacity')
    
    if total_crew_req > total_crew_cap:
        self.is_derelict = True
        return
    
    self.is_derelict = False
```

**Data Migration:** Add `"CommandAndControl": true` to Bridge components in `components.json`.

---

### Task 2.4: Remove Duplicate Initializations
**File:** `game/simulation/entities/ship.py`

**Remove (lines ~248-251):**
```python
self.baseline_to_hit_offense = 0.0  # DUPLICATE
self.to_hit_profile = 0.0  # DUPLICATE
```

**Keep (lines ~298-300):**
```python
self.to_hit_profile: float = 1.0       # Defensive Multiplier
self.baseline_to_hit_offense: float = 1.0  # Offensive Multiplier
```

---

### Task 2.5: Standardize Identity Checks
**File:** `game/simulation/entities/ship.py`
**Method:** `max_weapon_range` (lines ~325-355)

**Current (brittle):**
```python
if cls.__name__ == 'WeaponAbility':  # STRING CHECK
```

**Target:**
```python
from game.simulation.components.abilities import WeaponAbility, SeekerWeaponAbility

for ab in comp.ability_instances:
    if isinstance(ab, WeaponAbility):  # POLYMORPHIC
        rng = getattr(ab, 'range', 0.0)
        if isinstance(ab, SeekerWeaponAbility) and rng <= 0:
            rng = ab.projectile_speed * ab.endurance
        max_rng = max(max_rng, rng)
```

### Phase 3: Test Infrastructure & Verification (The Guardrails) [Complete]
**Objective:** Restore test isolation and verify unified stats.
- [x] **Task 3.1:** Restore/Fix `tests/conftest.py` for proper `RegistryManager` isolation. [QA Lead]
  - Added pre-test `mgr.clear()` before marker check
  - Restructured with try/finally for unconditional post-test cleanup
- [x] **Task 3.2:** Create `tests/unit/entities/test_ship_core.py` (Mocked Hull/Stat verification).
  - Created 6 test cases covering Hull auto-equip, legacy fallback, mass/HP aggregation, derelict status
  - All tests passing
- [x] **Task 3.3:** Audit existing Ship tests for `RegistryManager` usage compliance.
  - grep for COMPONENT_REGISTRY → 0 matches ✓
  - grep for VEHICLE_CLASSES → 0 matches ✓

---

## Phase 3 Implementation Specifications

### Task 3.1: Registry Isolation in `conftest.py`
**File:** `tests/conftest.py`
**Root Cause:** `reset_game_state` fixture skips cleanup when `use_custom_data` marker is present.

**Target Implementation:**
```python
@pytest.fixture(autouse=True)
def reset_game_state(monkeypatch, request):
    from game.core.registry import RegistryManager
    mgr = RegistryManager.instance()
    
    # Pre-test cleanup (ALWAYS)
    mgr.clear()

    if "use_custom_data" not in request.keywords:
        # Standard Fast Hydration
        cache = SessionRegistryCache.instance()
        cache.load_all_data()
        mgr.hydrate(...)
        
    yield
    
    # Post-test cleanup (ALWAYS RUNS)
    mgr.clear()
```

**Steps:**
1. Open `tests/conftest.py`.
2. Locate `reset_game_state` fixture.
3. Add `mgr.clear()` call BEFORE the marker check.
4. Ensure `mgr.clear()` is called AFTER `yield` unconditionally.
5. Run `pytest tests/unit/entities/test_sequence_hazard.py` to verify isolation.

---

### Task 3.2: Create `test_ship_core.py`
**File:** `tests/unit/entities/test_ship_core.py`

**Test Cases:**

#### TC-3.2.1: Hull Auto-Equip Verification
```python
def test_hull_auto_equip(registry_with_hull):
    """Verify Ship auto-equips default_hull_id from vehicle class."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="Escort")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 1
    assert core_comps[0].id == "hull_escort"
    assert ship.base_mass == 0.0  # Attribute Shadowing
```

#### TC-3.2.2: Legacy Fallback (No Hull)
```python
def test_no_hull_fallback(registry_no_hull):
    """Verify Ship uses legacy hull_mass when no default_hull_id."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="TestShip")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 0
    assert ship.base_mass == 100.0
```

#### TC-3.2.3: Mass Aggregation
```python
def test_mass_from_components(ship_with_components):
    """Verify Ship.mass equals sum of all component masses + base_mass."""
    ship = ship_with_components
    ship.recalculate_stats()
    
    expected_mass = ship.base_mass + sum(
        c.mass for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.mass == expected_mass
```

#### TC-3.2.4: HP Aggregation
```python
def test_hp_from_components(ship_with_components):
    """Verify Ship.max_hp equals sum of component max_hp values."""
    ship = ship_with_components
    
    expected_hp = sum(
        c.max_hp for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.max_hp == expected_hp
```

#### TC-3.2.5: Derelict Status from CommandAndControl
```python
def test_derelict_on_bridge_destruction(ship_with_bridge):
    """Verify ship becomes derelict when CommandAndControl component destroyed."""
    ship = ship_with_bridge
    bridge = next(c for c in ship.layers[LayerType.CORE]['components'] 
                  if c.has_ability('CommandAndControl'))
    
    bridge.current_hp = 0
    ship.update_derelict_status()
    
    assert ship.is_derelict is True
```

**Fixtures Required:**
- `registry_with_hull`: Populates RegistryManager with Escort class + hull_escort component.
- `registry_no_hull`: Populates RegistryManager with TestShip class (hull_mass=100, no default_hull_id).
- `ship_with_components`: Creates Ship with known components for mass/HP testing.
- `ship_with_bridge`: Creates Ship with Bridge component having CommandAndControl ability.

---

### Task 3.3: Audit Ship Tests for RegistryManager Compliance
**Scope:** `tests/unit/entities/`, `tests/integration/`

**Verification Steps:**
1. `grep -r "COMPONENT_REGISTRY" tests/` → Should return 0 matches.
2. `grep -r "VEHICLE_CLASSES" tests/` → Should return 0 matches.
3. `grep -r "from game.simulation.entities.ship import" tests/` → Verify imports use `get_vehicle_classes`, `get_component_registry`.

**Remediation Pattern:**
```python
# OLD (Direct Import)
from game.simulation.entities.ship import COMPONENT_REGISTRY

# NEW (RegistryManager Access)
from game.core.registry import get_component_registry
components = get_component_registry()
```

**Run Verification:**
```bash
pytest tests/unit/entities/ -v
pytest tests/integration/ -v
```

### Phase 4: UI Reconstruction (The Interface) [Complete]
**Objective:** Resolve layout overlaps and ensure builder compatibility.
- [x] **Task 4.1:** Create `game/ui/screens/builder_utils.py` (Layout constants). [UI Specialist]
  - Created centralized module with `PanelWidths`, `PanelHeights`, `Margins`, and `BuilderEvents` constants
- [x] **Task 4.2:** Implement relative/grid sizing for `builder_screen.py` to fix 1920px overlap.
  - FIXED: Changed `layer_panel_width` from fixed `PANEL_WIDTHS.layer_panel` to dynamic `calculate_dynamic_layer_width(screen_width)`
  - FIXED: `weapons_panel_width` calculation now subtracts `right_panel_width` to prevent overlap
- [x] **Task 4.3:** Resolve vertical collision between Weapons Report and Nav Panels.
  - ANALYZED: `right_panel.py` uses single scroll container, no sub-panels needing `update_layout()`
  - RECLASSIFIED: Issue was horizontal overlap (covered by Task 4.2b), not vertical stacking
- [x] **Task 4.4:** Switch `BuilderSceneGUI` to event-based data sync using `REGISTRY_RELOADED`.
  - Added `REGISTRY_RELOADED` event emission in `_reload_data`
  - Updated `BuilderRightPanel` and `BuilderLeftPanel` to subscribe to event

### Phase 5: Legacy Purge & Final Polish (The Cleanup)
**Objective:** Remove deprecated data and finalize the refactor.
- [ ] **Cleanup:** Remove `hull_mass` and `requirements` from `vehicleclasses.json`.
- [ ] **Cleanup:** Remove hardcoded ship fallback registry in `load_vehicle_classes`.
- [ ] **Final Verification:** Run Full Gauntlet (Target: 100% Pass).
- [ ] **Definition of Done:**
    - `Ship.py` has ZERO hardcoded mass/hp assignments.
    - `vehicleclasses.json` contains NO physical stats.
    - Ship Builder UI renders without overlap on 1080p+.
    - Save/Load persists fuel/ammo levels correctly.

---

## Phase 4 Implementation Specifications

### Task 4.1: Centralize Layout Constants
**File:** `game/ui/screens/builder_utils.py` [NEW]

**Implementation Spec:**
Create a utility module to define the design system's dimensions.

```python
# game/ui/screens/builder_utils.py

PANEL_WIDTHS = {
    'component_palette': 400,
    'structure_list': 400,
    'detail_panel': 500,
    'ship_stats': 750
}

PANEL_HEIGHTS = {
    'bottom_bar': 60,
    'weapons_report': 500,
    'modifier_panel': 360
}

MARGINS = {
    'edge': 20,
    'gutter': 10
}
```

---

### Task 4.2: Relative/Grid Layout for 1920px+
**File:** `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Calculate Available Center Width:** `center_width = screen_width - PANEL_WIDTHS['component_palette'] - PANEL_WIDTHS['ship_stats']`.
2. **Dynamic Layer Panel:** Instead of fixed 450px, the Layer Panel should take `min(400, center_width * 0.3)`.
3. **Schematic View:** Takes the remaining center space.
4. **Detail Panel Overlay:** Position the Detail Panel as a `pygame_gui.elements.UIPanel` with a relative offset from the right.

---

### Task 4.3: Resolve Vertical Panel Collision
**File:** `ui/builder/right_panel.py`

**Implementation Spec:**
The "Weapons Report" and "Navigation Panels" must use a vertical stack instead of fixed Y-offsets.

```python
def update_layout(self):
    current_y = MARGINS['edge']
    for panel in self.sub_panels:
        panel.set_relative_position((0, current_y))
        current_y += panel.rect.height + MARGINS['gutter']
```

---

### Task 4.4: Event-Based UI Synchronization
**Files:** `ui/builder/event_bus.py`, `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Registry Reload Event:** Add `REGISTRY_RELOADED = 'REGISTRY_RELOADED'` to `EventBus`.
2. **Panel Subscriptions:** `BuilderRightPanel` and `BuilderLeftPanel` subscribe to `REGISTRY_RELOADED`.
3. **Internal Refresh:** Update `BuilderRightPanel.refresh_controls()` to update dropdown *options* without killing the object.
4. **Preserve Selection:** Cache `self.ship.ship_class` before reload and re-apply to dropdown after refresh.

---

## Test Triage Table
| Issue | File | Status | Owner | Notes |
| :--- | :--- | :--- | :--- | :--- |
| Task 4.2a: Dynamic Layer Width | `builder_screen.py` | RESOLVED | UI Specialist | Changed to `calculate_dynamic_layer_width(screen_width)` |
| Task 4.2b: Weapons Panel Width | `builder_screen.py` | RESOLVED | UI Specialist | Subtracted `right_panel_width` from calculation |
| Task 4.3: Vertical Stacking | `right_panel.py` | NOT_APPLICABLE | UI Specialist | Reclassified: right_panel uses single scroll container, no sub-panels |

--- END FILE: Refactoring/active_refactor.md ---

