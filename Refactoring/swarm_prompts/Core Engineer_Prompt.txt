# INSTRUCTIONS FOR AGENT (Core Engineer)

**ROLE:** Core Engineer
**FOCUS:** Ship.py Core Logic Refactor (Phase 2)

## YOUR GOAL
Analyze the provided code context below.
Isolate issues specifically related to your FOCUS (Ship.py Core Logic Refactor (Phase 2)).
Ignore unrelated issues unless they are critical system failures.

## PHASE STATUS


## OUTPUT INSTRUCTIONS
You are an autonomous agent.
1. Perform your analysis.
2. **CRITICAL:** You MUST use the `write_to_file` tool to save your report.
   - **Target File:** `C:\Dev\Starship Battles\Refactoring\swarm_reports\Core Engineer_Report.md`
   - **Do NOT** just print the markdown to the chat. Save it to the file.

## CONTEXT

--- START FILE: game/simulation/entities/ship.py ---
import pygame
import random
import math
import json
import os
import typing
from typing import List, Dict, Tuple, Optional, Any, Union, Set, TYPE_CHECKING

from game.engine.physics import PhysicsBody
from game.simulation.components.component import (
    Component, LayerType
)
from game.core.logger import log_debug
from game.core.registry import RegistryManager, get_vehicle_classes, get_validator, get_component_registry, get_modifier_registry
from ship_validator import ShipDesignValidator, ValidationResult
from ship_stats import ShipStatsCalculator
from ship_physics import ShipPhysicsMixin
from ship_combat import ShipCombatMixin
from game.simulation.systems.resource_manager import ResourceRegistry

if TYPE_CHECKING:
    pass

def get_or_create_validator():
    val = get_validator()
    if not val:
        val = ShipDesignValidator()
        RegistryManager.instance().set_validator(val)
    return val
 



def load_vehicle_classes(filepath: str = "data/vehicleclasses.json", layers_filepath: Optional[str] = None) -> None:
    """
    Load vehicle class definitions from JSON.
    This should be called explicitly during game initialization.
    """
    
    # Check if we need to resolve path relative to this file
    if not os.path.exists(filepath):
        # Try finding it relative to module
        base_dir = os.path.dirname(os.path.abspath(__file__))
        abs_path = os.path.join(base_dir, filepath)
        if os.path.exists(abs_path):
            filepath = abs_path

    # Try to load layer definitions
    layer_definitions = {}
    
    if layers_filepath:
        layers_path = layers_filepath
    else:
        layers_path = os.path.join(os.path.dirname(filepath), "vehiclelayers.json")
        
    if os.path.exists(layers_path):
        try:
            with open(layers_path, 'r') as f:
                layer_data = json.load(f)
                layer_definitions = layer_data.get('definitions', {})
                print(f"Loaded {len(layer_definitions)} layer configurations from {os.path.basename(layers_path)}.")
        except Exception as e:
            print(f"Error loading layers from {layers_path}: {e}")
            
    try:
        with open(filepath, 'r') as f:
            data = json.load(f)
            # Update in place to preserve references
            classes = get_vehicle_classes()
            classes.clear()
            
            raw_classes = data.get('classes', {})
            
            # Post-process to resolve layer configurations
            for cls_name, cls_def in raw_classes.items():
                if 'layer_config' in cls_def:
                     config_id = cls_def['layer_config']
                     if config_id in layer_definitions:
                         cls_def['layers'] = layer_definitions[config_id]
                     else:
                         print(f"Warning: Class {cls_name} references unknown layer config {config_id}")
            
            classes.update(raw_classes)
            

            print(f"Loaded {len(classes)} vehicle classes.")
    except FileNotFoundError:
        print(f"Warning: {filepath} not found, using defaults")
        defaults = {
            "Escort": {"hull_mass": 50, "max_mass": 1000, "requirements": {}},
            "Frigate": {"hull_mass": 100, "max_mass": 2000, "requirements": {}},
            "Destroyer": {"hull_mass": 200, "max_mass": 4000, "requirements": {}},
            "Cruiser": {"hull_mass": 400, "max_mass": 8000, "requirements": {}},
            "Battlecruiser": {"hull_mass": 800, "max_mass": 16000, "requirements": {}},
            "Battleship": {"hull_mass": 1600, "max_mass": 32000, "requirements": {}},
            "Dreadnought": {"hull_mass": 3200, "max_mass": 64000, "requirements": {}}
        }
        classes = get_vehicle_classes()
        classes.clear()
        classes.update(defaults)
        


def initialize_ship_data(base_path: Optional[str] = None) -> None:
    """Facade for initializing all ship-related data."""
    if base_path:
        path = os.path.join(base_path, "data", "vehicleclasses.json")
        load_vehicle_classes(path)
    else:
        load_vehicle_classes()

class Ship(PhysicsBody, ShipPhysicsMixin, ShipCombatMixin):
    def __init__(self, name: str, x: float, y: float, color: Union[Tuple[int, int, int], List[int]], 
                 team_id: int = 0, ship_class: str = "Escort", theme_id: str = "Federation"):
        super().__init__(x, y)
        self.name: str = name
        self.color: Union[Tuple[int, int, int], List[int]] = color
        self.team_id: int = team_id
        self.current_target: Optional[Any] = None
        self.secondary_targets: List[Any] = []  # List of additional targets
        self.max_targets: int = 1         # Default 1 target (primary only)
        self.ship_class: str = ship_class
        self.theme_id: str = theme_id
        
        # Get class definition
        class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})

        # Initialize Layers dynamically from class definition
        self._initialize_layers()
        
        # Stats
        self.mass: float = 0.0
        self.base_mass: float = class_def.get('hull_mass', 50)  # Hull/Structure mass from class
        self.vehicle_type: str = class_def.get('type', "Ship")
        self.total_thrust: float = 0.0
        self.max_speed: float = 0.0
        self.turn_speed: float = 0.0
        self.target_speed: float = 0.0 # New Target Speed Control
        
        # Budget
        self.max_mass_budget: float = class_def.get('max_mass', 1000)
        
        self.radius: float = 40.0 # Will be recalculated
        
        # Resources (New System)
        self.resources = ResourceRegistry()
        
        # Resource initialization tracking
        self._resources_initialized: bool = False
        
        self.baseline_to_hit_offense = 0.0 # Score
        self.to_hit_profile = 0.0 # Score
        self.total_defense_score = 0.0 # Score (Size + Maneuver + ECM)
        self.emissive_armor = 0
        self.crystalline_armor = 0
        
        # Shield Stats (Still specific for now)
        self.max_shields: int = 0
        self.current_shields: float = 0.0
        self.shield_regen_rate: float = 0.0
        self.shield_regen_cost: float = 0.0
        self.repair_rate: float = 0.0
        
        # New Stats
        self.mass_limits_ok: bool = True
        self.layer_status: Dict[LayerType, Dict[str, Any]] = {}
        self._cached_summary = {}  # Performance optimization for UI
        self._loading_warnings: List[str] = []
        
        # Old init values
        self.current_mass: float = 0.0 
        
        self.is_alive: bool = True
        self.is_derelict: bool = False
        self.bridge_destroyed: bool = False
        
        # AI Strategy
        self.ai_strategy: str = "standard_ranged"
        self.source_file: Optional[str] = None
        
        # Formation Attributes
        self.formation_master: Optional[Any] = None      # Reference to master ship object
        self.formation_offset: Optional[Any] = None      # Vector2 offset relative to master
        self.formation_rotation_mode: str = 'relative' # 'relative' or 'fixed'
        self.formation_members: List[Any] = []       # List of followers (if this is master)
        self.in_formation: bool = True          # Flag to track if ship is currently holding formation
        self.turn_throttle: float = 1.0          # Multiplier for max speed (0.0 to 1.0)
        self.engine_throttle: float = 1.0        # Multiplier for max speed (0.0 to 1.0)
        
        # Arcade Physics
        self.current_speed: float = 0.0
        self.acceleration_rate: float = 0.0
        self.is_thrusting: bool = False
        self.comp_trigger_pulled: bool = False
        
        # Aiming
        self.aim_point: Optional[Any] = None
        self.just_fired_projectiles: List[Any] = []
        self.total_shots_fired: int = 0
        
        # To-Hit Calculation Stats
        self.to_hit_profile: float = 1.0       # Defensive Multiplier
        self.baseline_to_hit_offense: float = 1.0 # Offensive Multiplier
        
        # Initialize helper (lazy or eager)
        self.stats_calculator: Optional[ShipStatsCalculator] = None



    @property
    def max_hp(self) -> int:
        """Total HP of all components."""
        total = 0
        for layer in self.layers.values():
            for c in layer['components']:
                total += c.max_hp
        return total

    @property
    def hp(self) -> int:
        """Current HP of all components."""
        total = 0
        for layer in self.layers.values():
            for c in layer['components']:
                total += c.current_hp
        return total

    @property
    def max_weapon_range(self) -> float:
        """Calculate maximum range of all equipped weapons."""
        from game.simulation.components.abilities import SeekerWeaponAbility, WeaponAbility
        max_rng = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                # 1. Check WeaponAbility instances (new system)
                for ab in comp.ability_instances:
                    # Check for any WeaponAbility variant via MRO-style name check
                    is_weapon = False
                    for cls in ab.__class__.mro():
                        if cls.__name__ == 'WeaponAbility':
                            is_weapon = True
                            break
                    
                    if not is_weapon: continue
                    
                    rng = getattr(ab, 'range', 0.0)
                    # For SeekerWeapons, ensure we use their calculated range if not already reported
                    # SeekerWeaponAbility name check
                    if ab.__class__.__name__ == 'SeekerWeaponAbility' or 'SeekerWeaponAbility' in [c.__name__ for c in ab.__class__.mro()]:
                         # Only override if range is 0 or less, as property might already be correct
                         if rng <= 0 and hasattr(ab, 'projectile_speed') and hasattr(ab, 'endurance'):
                             rng = ab.projectile_speed * ab.endurance
                             
                    if rng > max_rng:
                        max_rng = rng
                

        return max_rng if max_rng > 0 else 0.0

    def update(self, dt: float = 0.01, context: Optional[dict] = None) -> None:
        """
        Update ship state (physics, combat, resources).
        """
        if not self.is_alive:
            return

        # 1. Update Resources (Regeneration) - Tick-based
        if self.resources:
             self.resources.update()

        # 2. Update Components (Consumption, Cooldowns) - Tick-based
        for layer in self.layers.values():
            for comp in layer['components']:
                if comp.is_active:
                    comp.update()
        
        # 3. Physics (Thrust calc handling operational engines)
        self.update_physics_movement()
        
        # PhysicsBody.update() (Applies velocity to position)
        super().update(dt)
        
        # 4. Combat Cooldowns (Shields/Repair/Custom Logic)
        self.update_combat_cooldowns()

        # 5. Firing Logic (Link AI trigger to Combat System)
        if self.comp_trigger_pulled:
            new_attacks = self.fire_weapons(context)
            if new_attacks:
                self.just_fired_projectiles.extend(new_attacks)

    def update_derelict_status(self) -> None:
        """
        Update is_derelict status based on vehicle class requirements.
        If essential components (e.g. Bridge) are destroyed, ship becomes derelict.
        """
        # 1. Get Requirements
        class_def = get_vehicle_classes().get(self.ship_class, {})
        requirements = class_def.get('requirements', {})
        
        # 2. If no requirements, never derelict (unless dead)
        if not requirements:
            self.is_derelict = False
            return

        # 3. Calculate Current Active Abilities
        active_components = []
        for layer in self.layers.values():
            for c in layer['components']:
                if c.is_active and c.current_hp > 0:
                     active_components.append(c)
        
        if not self.stats_calculator:
             self.stats_calculator = ShipStatsCalculator(get_vehicle_classes())
             
        # Recalculate abilities based on currently living components
        totals = self.stats_calculator.calculate_ability_totals(active_components)
        
        # 4. Check Requirements
        is_derelict = False
        for req_ability, min_val in requirements.items():
            # Support boolean requirements (True means > 0)
            current_val = totals.get(req_ability, 0)
            
            if isinstance(min_val, bool):
                if min_val and not current_val:
                    is_derelict = True
                    break
            elif isinstance(min_val, (int, float)):
                 if current_val < min_val:
                     is_derelict = True
                     break
        
        if is_derelict and not self.is_derelict:
            print(f"{self.name} has become DERELICT (Requirements not met)")
            
        self.is_derelict = is_derelict

    def _initialize_layers(self) -> None:
        """Initialize or Re-initialize layers based on current ship_class."""
        class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
        self.layers = {}
        layer_defs = class_def.get('layers', [])
        
        # Fallback if no layers defined in vehicle class
        if not layer_defs:
            layer_defs = [
                { "type": "CORE", "radius_pct": 0.2, "restrictions": [] },
                { "type": "INNER", "radius_pct": 0.5, "restrictions": [] },
                { "type": "OUTER", "radius_pct": 0.8, "restrictions": [] },
                { "type": "ARMOR", "radius_pct": 1.0, "restrictions": [] }
            ]
            
        for l_def in layer_defs:
            l_type_str = l_def.get('type')
            try:
                l_type = LayerType[l_type_str]
                self.layers[l_type] = {
                    'components': [],
                    'radius_pct': l_def.get('radius_pct', 0.5),
                    'restrictions': l_def.get('restrictions', []),
                    'max_mass_pct': l_def.get('max_mass_pct', 1.0),
                    'hp_pool': 0, 'max_hp_pool': 0, 'mass': 0, 'hp': 0
                }
            except KeyError:
                print(f"Warning: Unknown LayerType {l_type_str} in class {self.ship_class}")

        # Recalculate layer radii based on max_mass_pct (Area proportional to mass capacity)
        # Sort layers: CORE -> INNER -> OUTER -> ARMOR
        layer_order = [LayerType.CORE, LayerType.INNER, LayerType.OUTER, LayerType.ARMOR]
        
        # Filter layers present in this ship
        present_layers = [l for l in layer_order if l in self.layers]
        
        # Calculate total mass capacity (sum of max_mass_pct)
        total_capacity_pct = sum(self.layers[l]['max_mass_pct'] for l in present_layers)
        
        if total_capacity_pct > 0:
            cumulative_mass_pct = 0.0
            for l_type in present_layers:
                cumulative_mass_pct += self.layers[l_type]['max_mass_pct']
                # Area = pi * r^2. Mass proportional to Area.
                # Mass_ratio = Current_Cumulative / Total
                # Radius_ratio = sqrt(Mass_ratio)
                self.layers[l_type]['radius_pct'] = math.sqrt(cumulative_mass_pct / total_capacity_pct)
        else:
            # Fallback if no mass limits defined (shouldn't happen with new data)
            pass

    def change_class(self, new_class: str, migrate_components: bool = False) -> None:
        """
        Change the ship class and optionally migrate components.
        
        Args:
            new_class: The new class name (e.g. "Cruiser")
            migrate_components: If True, attempts to keep components and fit them into new layers.
                                If False, clears all components.
        """
        if new_class not in get_vehicle_classes():
            print(f"Error: Unknown class {new_class}")
            return

        old_components = []
        if migrate_components:
            # Flatten all components with their original layer
            for l_type, data in self.layers.items():
                for comp in data['components']:
                    old_components.append((comp, l_type))
        
        # Update Class
        self.ship_class = new_class
        class_def = get_vehicle_classes()[self.ship_class]
        self.base_mass = class_def.get('hull_mass', 50)
        self.vehicle_type = class_def.get('type', "Ship")
        self.max_mass_budget = class_def.get('max_mass', 1000)
        
        # Re-initialize Layers (clears self.layers)
        self._initialize_layers()
        self.current_mass = 0.0 # Reset mass accumulator
        
        if migrate_components:
            # Attempt to restore components
            for comp, old_layer in old_components:
                added = False
                
                # 1. Try original layer
                if old_layer in self.layers:
                    if self.add_component(comp, old_layer):
                         added = True
                
                # 2. If failed, try all other layers in the new ship
                if not added:
                    for layer_type in self.layers.keys():
                        if layer_type == old_layer: continue 
                        
                        if self.add_component(comp, layer_type):
                            added = True
                            break
                
                if not added:
                    print(f"Warning: Could not fit component {comp.name} during refit to {new_class}")
        
        # Finally recalculate stats
        self.recalculate_stats()

    def add_component(self, component: Component, layer_type: LayerType) -> bool:
        """Validate and add a component to the specified layer."""
        if component is None:
             print("Error: Attempted to add None component to ship")
             return False

        result = get_or_create_validator().validate_addition(self, component, layer_type)
        
        if not result.is_valid:
             for err in result.errors:
                 print(f"Error: {err}")
             return False

        self.layers[layer_type]['components'].append(component)
        component.layer_assigned = layer_type
        component.ship = self
        component.recalculate_stats()
        self.current_mass += component.mass
        self._cached_summary = {}  # Invalidate cache
        
        # Update Stats
        self.recalculate_stats()
        return True

    @property
    def cached_summary(self):
        """Cached dictionary of high-level ship stats (DPS, Speed, etc)."""
        return self._cached_summary

    def add_components_bulk(self, component: Component, layer_type: LayerType, count: int) -> int:
        """
        Add multiple copies of a component to the specified layer.
        Performs validation for each addition but defers full ship stat recalculation until the end.
        Returns the number of components successfully added.
        """
        added_count = 0
        
        # Loop to add
        for _ in range(count):
            # Must clone for each new instance
            new_comp = component.clone()
            
            # Use the global validator
            result = get_or_create_validator().validate_addition(self, new_comp, layer_type)
            if not result.is_valid:
                # Stop adding if we hit a limit
                if added_count == 0:
                    # If the very first one fails, print errors
                    for err in result.errors:
                        print(f"Error: {err}")
                break
                
            self.layers[layer_type]['components'].append(new_comp)
            new_comp.layer_assigned = layer_type
            new_comp.ship = self
            new_comp.recalculate_stats()
            self.current_mass += new_comp.mass
            added_count += 1
            
        if added_count > 0:
            self.recalculate_stats()
            
        return added_count

    def remove_component(self, layer_type: LayerType, index: int) -> Optional[Component]:
        """Remove a component from the specified layer by index."""
        if 0 <= index < len(self.layers[layer_type]['components']):
            comp = self.layers[layer_type]['components'].pop(index)
            self.current_mass -= comp.mass
            self.recalculate_stats()
            return comp
        return None

    def recalculate_stats(self) -> None:
        """
        Recalculates derived stats. Delegates to ShipStatsCalculator.
        """
        # 1. Update Base Class Specs (ensure budget is fresh for scaling modifiers)
        classes = get_vehicle_classes()
        if self.ship_class in classes:
             cdef = classes[self.ship_class]
             self.max_mass_budget = cdef.get('max_mass', 1000)

        # 2. Update components with current ship context
        for layer_data in self.layers.values():
            for comp in layer_data['components']:
                # Ensure ship ref is set
                if not getattr(comp, 'ship', None): comp.ship = self
                comp.recalculate_stats()

        if not self.stats_calculator:
             self.stats_calculator = ShipStatsCalculator(classes)
        
        self.stats_calculator.calculate(self)

    def get_missing_requirements(self) -> List[str]:
        """Check class requirements and return list of missing items based on abilities."""
        # Use centralized validator
        result = get_or_create_validator().validate_design(self)
        if result.is_valid:
            return []
        # Return all errors as list of strings
        return [f"âš  {err}" for err in result.errors]

    def get_validation_warnings(self) -> List[str]:
        """Check class requirements and return list of warnings (soft requirements)."""
        result = get_or_create_validator().validate_design(self)
        return result.warnings
    
    def _format_ability_name(self, ability_name: str) -> str:
        """Convert ability ID to readable name."""
        import re
        return re.sub(r'(?<!^)(?=[A-Z])', ' ', ability_name)
    
    def get_ability_total(self, ability_name: str) -> Union[float, int, bool]:
        """Get total value of a specific ability across all components."""
        all_components = [c for layer in self.layers.values() for c in layer['components']]
        
        if not self.stats_calculator:
             self.stats_calculator = ShipStatsCalculator(get_vehicle_classes())
             
        totals = self.stats_calculator.calculate_ability_totals(all_components)
        return totals.get(ability_name, 0)
    
    def get_total_ability_value(self, ability_name: str, operational_only: bool = True) -> float:
        """
        Sum values from all matching abilities across all components.
        Uses ability_instances (Phase 3+ API) instead of abilities dict.
        
        Args:
            ability_name: Name of ability class to sum (e.g., 'CombatPropulsion')
            operational_only: If True, only count abilities from operational components
            
        Returns:
            Sum of primary value attribute from all matching abilities
        """
        total = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                if operational_only and not comp.is_operational:
                    continue
                for ab in comp.get_abilities(ability_name):
                    # Get the primary value attribute based on ability type
                    if hasattr(ab, 'thrust_force'):
                        total += ab.thrust_force
                    elif hasattr(ab, 'turn_rate'):
                        total += ab.turn_rate
                    elif hasattr(ab, 'capacity'):
                        total += ab.capacity
                    elif hasattr(ab, 'rate'):
                        total += ab.rate
                    elif hasattr(ab, 'value'):
                        total += ab.value
        return total
    
    def get_total_sensor_score(self) -> float:
        """Calculate total Targeting Score from all active sensors."""
        total_score = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                # Phase 7: Use ability-based check
                for ab in comp.get_abilities('ToHitAttackModifier'):
                    total_score += ab.value
        return total_score

    def get_total_ecm_score(self) -> float:
        """Calculate total Evasion/Defense Score from all active ECM/Electronics."""
        total_score = 0.0
        for layer in self.layers.values():
            for comp in layer['components']:
                # Phase 7: Use ability-based check
                for ab in comp.get_abilities('ToHitDefenseModifier'):
                    total_score += ab.value
        return total_score

    def check_validity(self) -> bool:
        """Check if the current ship design is valid."""
        self.recalculate_stats()
        result = get_or_create_validator().validate_design(self)
        # Check for mass errors specifically for UI feedback flag
        self.mass_limits_ok = not any("Mass budget exceeded" in e for e in result.errors)
        return result.is_valid

    @property
    def layers_dict(self) -> Dict[str, List[Any]]:
        """Helper for JSON serialization."""
        d = {}
        for l_type, data in self.layers.items():
            d[l_type.name] = []
            for comp in data['components']:
                # Minimal serialization: ID + Modifiers
                c_data = {
                    "id": comp.id,
                    "modifiers": []
                }
                for m_id, m_val in comp.modifiers.items():
                    c_data["modifiers"].append({"id": m_id, "value": m_val})
                d[l_type.name].append(c_data)
        return d

    def to_dict(self) -> Dict[str, Any]:
        """Serialize ship to dictionary."""
        data = {
            "name": self.name,
            "ship_class": self.ship_class,
            "theme_id": self.theme_id,
            "team_id": self.team_id,
            "color": self.color,
            "ai_strategy": self.ai_strategy,
            "layers": {},
            "expected_stats": {
                "max_hp": self.max_hp,
                "max_fuel": self.resources.get_max_value("fuel"),
                "max_energy": self.resources.get_max_value("energy"),
                "max_ammo": self.resources.get_max_value("ammo"),
                "max_speed": self.max_speed,
                "acceleration_rate": self.acceleration_rate,
                "turn_speed": self.turn_speed,
                "total_thrust": self.total_thrust,
                "mass": self.mass,
                "armor_hp_pool": self.layers[LayerType.ARMOR]['max_hp_pool'] if LayerType.ARMOR in self.layers else 0
            }
        }
        
        for ltype, layer_data in self.layers.items():
            filter_comps = []
            for comp in layer_data['components']:
                # Save as dict with modifiers
                c_obj = {"id": comp.id}
                if comp.modifiers:
                    c_obj["modifiers"] = [{"id": k, "value": v} for k, v in comp.modifiers.items()]
                filter_comps.append(c_obj)
                
            data["layers"][ltype.name] = filter_comps
        return data

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Ship':
        """Create ship from dictionary."""
        name = data.get("name", "Unnamed")
        color_val = data.get("color", (200, 200, 200))
        # Ensure color is tuple
        color: tuple
        if isinstance(color_val, list): 
            color = tuple(color_val)
        else:
            color = color_val # type: ignore
        
        s = Ship(name, 0, 0, color, data.get("team_id", 0), ship_class=data.get("ship_class", "Escort"), theme_id=data.get("theme_id", "Federation"))
        s.ai_strategy = data.get("ai_strategy", "standard_ranged")
        
        for l_name, comps_list in data.get("layers", {}).items():
            layer_type = None
            try:
                layer_type = LayerType[l_name]
            except KeyError:
                continue
                
            # Skip if this layer is not defined in the ship's class
            if layer_type not in s.layers:
                 continue
            
            for c_entry in comps_list:
                comp_id = ""
                modifiers_data = []
                
                if isinstance(c_entry, str):
                    comp_id = c_entry
                elif isinstance(c_entry, dict):
                    comp_id = c_entry.get("id", "")
                    modifiers_data = c_entry.get("modifiers", [])
                
                comps = get_component_registry()
                if comp_id in comps:
                    new_comp = comps[comp_id].clone()
                    
                    # Apply Modifiers
                    mods = get_modifier_registry()
                    for m_dat in modifiers_data:
                        mid = m_dat['id']
                        mval = m_dat['value']
                        if mid in mods:
                            new_comp.add_modifier(mid, mval)

                    s.add_component(new_comp, layer_type)
        
        s.recalculate_stats()
        
        # Verify loaded stats match expected stats (if saved)
        expected = data.get('expected_stats', {})
        if expected:
            mismatches = []
            if expected.get('max_hp') and abs(s.max_hp - expected['max_hp']) > 1:
                mismatches.append(f"max_hp: got {s.max_hp}, expected {expected['max_hp']}")
            
            val = s.resources.get_max_value("fuel")
            if expected.get('max_fuel') and abs(val - expected['max_fuel']) > 1:
                mismatches.append(f"max_fuel: got {val}, expected {expected['max_fuel']}")
            
            val = s.resources.get_max_value("energy")
            if expected.get('max_energy') and abs(val - expected['max_energy']) > 1:
                mismatches.append(f"max_energy: got {val}, expected {expected['max_energy']}")
            
            val = s.resources.get_max_value("ammo")
            if expected.get('max_ammo') and abs(val - expected['max_ammo']) > 1:
                mismatches.append(f"max_ammo: got {val}, expected {expected['max_ammo']}")
            if expected.get('max_speed') and abs(s.max_speed - expected['max_speed']) > 0.1:
                mismatches.append(f"max_speed: got {s.max_speed:.1f}, expected {expected['max_speed']:.1f}")
            if expected.get('acceleration_rate') and abs(s.acceleration_rate - expected['acceleration_rate']) > 0.001:
                mismatches.append(f"acceleration_rate: got {s.acceleration_rate:.3f}, expected {expected['acceleration_rate']:.3f}")
            if expected.get('turn_speed') and abs(s.turn_speed - expected['turn_speed']) > 0.1:
                mismatches.append(f"turn_speed: got {s.turn_speed:.1f}, expected {expected['turn_speed']:.1f}")
            if expected.get('total_thrust') and abs(s.total_thrust - expected['total_thrust']) > 1:
                mismatches.append(f"total_thrust: got {s.total_thrust}, expected {expected['total_thrust']}")
            if expected.get('mass') and abs(s.mass - expected['mass']) > 1:
                mismatches.append(f"mass: got {s.mass}, expected {expected['mass']}")
            armor_hp = s.layers[LayerType.ARMOR]['max_hp_pool'] if LayerType.ARMOR in s.layers else 0
            if expected.get('armor_hp_pool') and abs(armor_hp - expected['armor_hp_pool']) > 1:
                mismatches.append(f"armor_hp_pool: got {armor_hp}, expected {expected['armor_hp_pool']}")
            
            s._loading_warnings = mismatches
            
            if mismatches:
                print(f"WARNING: Ship '{s.name}' stats mismatch after loading!")
                for m in mismatches:
                    print(f"  - {m}")
        
        return s




    


--- END FILE: game/simulation/entities/ship.py ---

--- START FILE: game/simulation/components/component.py ---
import json
import math
from enum import Enum, auto
from formula_system import evaluate_math_formula
from game.core.registry import get_component_registry, get_modifier_registry

class ComponentStatus(Enum):
    ACTIVE = auto()
    DAMAGED = auto() # >50% damage
    NO_CREW = auto()
    NO_POWER = auto()
    NO_FUEL = auto()
    NO_AMMO = auto()

class LayerType(Enum):
    CORE = 1
    INNER = 2
    OUTER = 3
    ARMOR = 4

    @staticmethod
    def from_string(s):
        return getattr(LayerType, s.upper())

class Modifier:
    def __init__(self, data):
        self.id = data['id']
        self.name = data['name']
        self.type_str = data['type'] # 'boolean' or 'linear'
        self.description = data.get('description', '')
        self.effects = data.get('effects', {})
        self.restrictions = data.get('restrictions', {})
        self.param_name = data.get('param_name', 'value')
        self.min_val = data.get('min_val', 0)
        self.max_val = data.get('max_val', 100)
        self.default_val = data.get('default_val', self.min_val)
        self.readonly = data.get('readonly', False)

    def create_modifier(self, value=None):
        return ApplicationModifier(self, value)



class ApplicationModifier:
    """Instance of a modifier applied to a component"""
    def __init__(self, mod_def, value=None):
        self.definition = mod_def
        self.value = value if value is not None else mod_def.default_val

# IMPORTS MOVED TO LOCAL SCOPE TO PREVENT CIRCULAR DEPENDENCY
# from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability

class Component:
    def __init__(self, data):
        import copy
        self.data = copy.deepcopy(data) # Store raw data for reference/cloning
        self.id = data['id']
        self.name = data['name']
        self.base_mass = data['mass']
        self.mass = self.base_mass
        self.base_max_hp = data['hp']
        self.max_hp = self.base_max_hp
        self.current_hp = self.max_hp
        


        # allowed_layers removed in refactor
        # self.allowed_layers = [LayerType.from_string(l) for l in data['allowed_layers']]
        self.allowed_vehicle_types = data.get('allowed_vehicle_types', ["Ship"])
        self.major_classification = data.get('major_classification', "Unknown")
        self.is_active = True
        self.status = ComponentStatus.ACTIVE
        self.layer_assigned = None
        self.type_str = data['type']
        self.sprite_index = data.get('sprite_index', 0)
        self.cost = data.get('cost', 0)
        
        
        # Parse abilities from data
        self.abilities = self.data.get('abilities', {})
        


        
        self.base_abilities = copy.deepcopy(self.abilities)
        
        self.ship = None # Container reference
        
        self.stats = {} # Current stats dictionary (calcualted)
        self.modifiers = [] # list of ApplicationModifier
        
        # Ability Instances (New System)
        self.ability_instances = []
        self._is_operational = True # Tracks if component has resources to operate
        
        # Instantiate Abilities
        self._instantiate_abilities()
        
        # Load default modifiers from data definition
        if 'modifiers' in self.data:
            for mod_data in self.data['modifiers']:
                mod_id = mod_data['id']
                val = mod_data.get('value', None)
                # We need to access modifier registry.
                from game.core.registry import get_modifier_registry
                mods = get_modifier_registry()
                if mod_id in mods:
                    mod_def = mods[mod_id]
                    self.modifiers.append(mod_def.create_modifier(val))
                else:
                    # If modifiers loaded later, this might fail. 
                    # Ideally modifiers are loaded before components.
                    pass
                    
        # Parse Formulas
        self.formulas = {}
        for key, value in self.data.items():
            if isinstance(value, str) and value.startswith("="):
                # It's a formula!
                self.formulas[key] = value[1:] # Store without '='
                # Initialize base value to something safe? Or keep it as is?
                # Probably keep undefined or 0 until recalculated? 
                # Better to set a default if possible, but hard to guess.
                # If it's mass/hp, 0 is safer than crashing.
                if key in ['mass', 'hp', 'cost']:
                     setattr(self, f"base_{key}" if key in ['mass', 'hp'] else key, 0)
                     if key == 'mass': self.mass = 0
                     if key == 'hp': 
                         self.max_hp = 0
                         self.current_hp = 0

    def get_abilities(self, ability_name: str):
        """
        Get all abilities of a specific type (by registry name).
        Supports polymorphism if the registry entry is a class.
        """
        from game.simulation.components.abilities import ABILITY_REGISTRY
        
        target_class = None
        if ability_name in ABILITY_REGISTRY:
            val = ABILITY_REGISTRY[ability_name]
            if isinstance(val, type):
                target_class = val
        
        found = []
        for ab in self.ability_instances:
            # 1. Polymorphic check (preferred)
            if target_class and isinstance(ab, target_class):
                found.append(ab)
            # 2. Hierarchy Name check (Strong fallback for Module Identity Drift in tests)
            else:
                # Check if the ability name matches any class in the inheritance chain
                for cls in ab.__class__.mro():
                    if cls.__name__ == ability_name:
                        found.append(ab)
                        break
        return found

    def get_ability(self, ability_name: str):
        """Get first ability of type."""
        l = self.get_abilities(ability_name)
        return l[0] if l else None

    def has_ability(self, ability_name: str):
        # 1. Direct check (fast)
        if ability_name in self.abilities:
            return True
        # 2. Polymorphic check (e.g. asking for 'WeaponAbility' when we have 'ProjectileWeaponAbility')
        return len(self.get_abilities(ability_name)) > 0

    def has_pdc_ability(self) -> bool:
        """Check if component has a Point Defense weapon ability.
        
        Returns True if any ability has 'pdc' in its tags.
        """
        # 1. Check new tag-based system
        for ab in self.ability_instances:
            if 'pdc' in ab.tags:
                return True
        

        return False



    @property
    def cooldown_timer(self):
        # Map to first weapon ability if present
        ab = self.get_ability('WeaponAbility')
        if ab: return ab.cooldown_timer
        return 0.0
        
    @cooldown_timer.setter
    def cooldown_timer(self, value):
        ab = self.get_ability('WeaponAbility')
        if ab: ab.cooldown_timer = float(value)

    def get_ui_rows(self):
        """Aggregate UI rows from all ability instances.
        
        Returns list of dicts: [{'label': 'Thrust', 'value': '1500 N'}, ...]
        Used by detail panels and capability scanners.
        """
        rows = []
        for ab in self.ability_instances:
            rows.extend(ab.get_ui_rows())
        return rows

    def _instantiate_abilities(self):
        """Instantiate or Sync Ability objects from self.abilities dict."""
        # We want to preserve existing instances to maintain runtime state (cooldowns, energy)
        # but also add new ones or remove obsolete ones.
        
        # 1. Map existing instances for quick lookup
        # Key: (ability_type_name, index_in_that_type)
        existing_map = {}
        for ab in self.ability_instances:
            # We track by class name
            cls_name = ab.__class__.__name__
            if cls_name not in existing_map:
                existing_map[cls_name] = []
            existing_map[cls_name].append(ab)

        new_instances = []
        
        # Standard Loading from abilities dict
        from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability
        
        for name, data in self.abilities.items():
            if name not in ABILITY_REGISTRY:
                continue
            
            items = data if isinstance(data, list) else [data]
            
            # Get the target class for this registry entry (could be class or lambda)
            target = ABILITY_REGISTRY[name]
            target_cls_name = None
            if isinstance(target, type):
                target_cls_name = target.__name__
            elif name in ["FuelStorage", "EnergyStorage", "AmmoStorage"]:
                 target_cls_name = "ResourceStorage"
            elif name == "EnergyGeneration":
                 target_cls_name = "ResourceGeneration"
            elif name == "EnergyConsumption":
                 target_cls_name = "ResourceConsumption"

            for item in items:
                # Heuristic: Match by Target Class Name if known, otherwise fallback to registry name
                match_name = target_cls_name or name
                
                found_existing = False
                if match_name in existing_map and existing_map[match_name]:
                    ab = existing_map[match_name].pop(0)
                    # Support live data sync if ability supports it
                    if hasattr(ab, 'sync_data'):
                        ab.sync_data(item)
                    new_instances.append(ab)
                    found_existing = True
                
                if not found_existing:
                    ab = create_ability(name, self, item)
                    if ab: new_instances.append(ab)
        
        self.ability_instances = new_instances
            
    def update(self):
        """Update component state for one tick (resource consumption, cooldowns)."""
        # 1. Update Abilities (Constant Consumption)
        all_satisfied = True
        
        for ability in self.ability_instances:
            if not ability.update():
                from game.simulation.systems.resource_manager import ResourceConsumption
                if isinstance(ability, ResourceConsumption) and ability.trigger == 'constant':
                     all_satisfied = False
        
        self._is_operational = all_satisfied and self.is_active

    @property
    def is_operational(self):
        return self._is_operational and self.is_active

    def can_afford_activation(self):
        """Check if component can afford activation costs."""
        from game.simulation.systems.resource_manager import ResourceConsumption
        for ability in self.ability_instances:
            if isinstance(ability, ResourceConsumption) and ability.trigger == 'activation':
                if not ability.check_available():
                    return False
        return True

    def consume_activation(self):
        """Consume activation costs."""
        for ability in self.get_abilities('ResourceConsumption'):
            if ability.trigger == 'activation':
                ability.check_and_consume()

    def try_activate(self):
        """Check if component can afford activation costs, consume them if available, and return True on success."""
        if self.can_afford_activation():
            self.consume_activation()
            return True
        return False




    def take_damage(self, amount):
        # Defensive check for MagicMock or non-numeric types
        if not isinstance(amount, (int, float)):
            try: amount = float(amount)
            except: amount = 0 # Fallback for pure mocks
            
        self.current_hp -= amount
        
        # Update Status
        if isinstance(self.current_hp, (int, float)) and self.current_hp <= 0:
            self.current_hp = 0
            self.is_active = False
            return True # Destroyed
        
        # Logic Repair: Update status to DAMAGED if below 50%
        # Defensive check for max_hp and current_hp types
        if isinstance(self.current_hp, (int, float)) and isinstance(self.max_hp, (int, float)):
             if self.current_hp < (self.max_hp * 0.5):
                 self.status = ComponentStatus.DAMAGED
            
        return False

    def reset_hp(self):
        self.current_hp = self.max_hp
        self.is_active = True
        self.status = ComponentStatus.ACTIVE

    def add_modifier(self, mod_id, value=None):
        mods = get_modifier_registry()
        if mod_id not in mods: return False
        
        # Check restrictions
        mod_def = mods[mod_id]
        if 'deny_types' in mod_def.restrictions:
            if self.type_str in mod_def.restrictions['deny_types']:
                return False
        if 'allow_types' in mod_def.restrictions:
            if self.type_str not in mod_def.restrictions['allow_types']:
                return False
                
        # Remove existing if any (replace)
        self.remove_modifier(mod_id)
            
        app_mod = ApplicationModifier(mod_def, value)
        self.modifiers.append(app_mod)
        self.recalculate_stats()
        return True

    def remove_modifier(self, mod_id):
        self.modifiers = [m for m in self.modifiers if m.definition.id != mod_id]
        self.recalculate_stats()

    def get_modifier(self, mod_id):
        for m in self.modifiers:
            if m.definition.id == mod_id:
                return m
        return None
        


    def recalculate_stats(self):
        """Recalculate component stats with multiplicative modifier stacking."""
        # Capture old hp for current_hp logic at end
        old_max_hp = self.max_hp

        # 1. Reset and Evaluate Base Formulas
        self._reset_and_evaluate_base_formulas()
        
        # 1.5 Re-instantiate Abilities (Sync instances with new abilities dict)
        self._instantiate_abilities()

        # 2. Calculate Modifier Stats (Accumulate multipliers)
        stats = self._calculate_modifier_stats()
        self.stats = stats # Persist for introspection/ability access

        # 3. Apply Base Stats (Generic attributes)
        self._apply_base_stats(stats, old_max_hp)
        
        # 4. Apply Custom/Subclass Stats
        self._apply_custom_stats(stats)



    def _reset_and_evaluate_base_formulas(self):
        import copy
        # Reset abilities from raw data
        self.abilities = copy.deepcopy(self.data.get('abilities', {}))
        
        # Context building
        context = {
            'ship_class_mass': 1000 # Default fallback
        }
        if self.ship:
             context['ship_class_mass'] = getattr(self.ship, 'max_mass_budget', 1000)

        # Evaluate Formulas for attributes
        for attr, formula in self.formulas.items():
            val = evaluate_math_formula(formula, context)
            if attr == 'mass':
                self.base_mass = float(val)
                self.mass = self.base_mass # Reset to base
            elif attr == 'hp':
                self.base_max_hp = int(val)
                self.max_hp = self.base_max_hp # Reset to base
            else:
                 if hasattr(self, attr):
                     if isinstance(getattr(self, attr), int):
                         setattr(self, attr, int(val))
                     else:
                         setattr(self, attr, val)
        
        # Evaluate formulas in abilities
        for ability_name, val in self.abilities.items():
            if isinstance(val, str) and val.startswith("="):
                new_val = evaluate_math_formula(val[1:], context)
                self.abilities[ability_name] = new_val
            elif isinstance(val, dict):
                 # Phase 7: Generically evaluate formulas in any key of the ability dict
                 for key, sub_val in val.items():
                     if isinstance(sub_val, str) and sub_val.startswith("="):
                         new_val = evaluate_math_formula(sub_val[1:], context)
                         val[key] = new_val

    def _calculate_modifier_stats(self):
        from game.simulation.components.modifiers import apply_modifier_effects
        stats = {
            'mass_mult': 1.0,
            'hp_mult': 1.0,
            'damage_mult': 1.0,
            'range_mult': 1.0,
            'cost_mult': 1.0,
            'thrust_mult': 1.0,
            'turn_mult': 1.0,
            'energy_gen_mult': 1.0,
            'capacity_mult': 1.0,
            'crew_capacity_mult': 1.0,
            'life_support_capacity_mult': 1.0,
            'consumption_mult': 1.0,
            'mass_add': 0.0,
            'arc_add': 0.0,
            'accuracy_add': 0.0,
            'arc_set': None,
            'properties': {},
            # New Modifier Support
            'reload_mult': 1.0,
            'endurance_mult': 1.0,
            'projectile_hp_mult': 1.0,
            'projectile_damage_mult': 1.0,
            'projectile_stealth_level': 0.0,
            'crew_req_mult': 1.0
        }
        
        for m in self.modifiers:
            apply_modifier_effects(m.definition, m.value, stats, component=self)
            
        return stats

    def _apply_base_stats(self, stats, old_max_hp):
        # Apply specific property overrides
        for prop, val in stats['properties'].items():
            if hasattr(self, prop):
                setattr(self, prop, val)

        # Apply Base Multipliers
        self.mass = (self.base_mass + stats['mass_add']) * stats['mass_mult']
        
        # Note: old_max_hp is passed in, captured before base formula reset
        self.max_hp = int(self.base_max_hp * stats['hp_mult'])
        
        if hasattr(self, 'cost'):
            self.cost = int(self.data.get('cost', 0) * stats['cost_mult'])



        # Handle HP update (healing/new component logic)
        if old_max_hp == 0:
            self.current_hp = self.max_hp
        elif self.current_hp >= old_max_hp:
            self.current_hp = self.max_hp
            
        # Ensure cap
        self.current_hp = min(self.current_hp, self.max_hp)

        # Generic Sync: Update Activation Abilities if attributes changed
        from game.simulation.systems.resource_manager import ResourceConsumption, ResourceStorage, ResourceGeneration
        
        for ab in self.ability_instances:
            # General Recalculate (Protocol for active abilities to sync with stats)
            ab.recalculate()
            
            ab_cls = ab.__class__.__name__
            ab_data = ab.data
            
            # Helper to get base value safely from dict or primitive
            def get_base(data, key, default=0.0):
                if isinstance(data, dict):
                    return data.get(key, default)
                if isinstance(data, (int, float)):
                    return float(data)
                return default

            # ResourceConsumption (Base amount * consumption_mult)
            if ab_cls == 'ResourceConsumption':
                 base = get_base(ab_data, 'amount')
                 ab.amount = base * stats.get('consumption_mult', 1.0)
            
            # ResourceStorage (Base amount * capacity_mult)
            elif ab_cls == 'ResourceStorage':
                 base = get_base(ab_data, 'amount')
                 ab.max_amount = base * stats.get('capacity_mult', 1.0)
            
            # ResourceGeneration (Base amount * energy_gen_mult)
            elif ab_cls == 'ResourceGeneration':
                 # Apply energy_gen_mult only if resource is energy, or generic 'generation_mult' if we had one.
                 if getattr(ab, 'resource_type', '') == 'energy':
                     base = get_base(ab_data, 'amount')
                     ab.rate = base * stats.get('energy_gen_mult', 1.0)



    def _apply_custom_stats(self, stats):
        """Hook for subclasses to apply specific stats."""
        # Base implementation handles Crew/LifeSupport as they are somewhat generic in this system
        pass

    def clone(self):
        # Create a new instance with the same data
        # We need a Factory, but since we are refactoring, we can just make a new instance of the same class.
        # But we need to know the class.
        return self.__class__(self.data)


# Phase 7 Simplified: Aliased types now use Component directly
# Types with custom logic (Shield, Hangar, etc.) are now also aliases
# as their logic has been unified into the Ability system.

# Export types for compatibility (Phase 6 Regression Triage)


# Caching for performance (Phase 2 Test Stabilization)
_COMPONENT_CACHE = None
_MODIFIER_CACHE = None
_LAST_COMPONENT_FILE = None
_LAST_MODIFIER_FILE = None

def load_components(filepath="data/components.json"):
    global _COMPONENT_CACHE, _LAST_COMPONENT_FILE
    import os
    import copy
    from game.core.registry import get_component_registry

    # If cache exists and matches filepath, hydrate Registry from cache (Fast Path)
    if _COMPONENT_CACHE is not None and _LAST_COMPONENT_FILE == filepath:
        comps = get_component_registry()
        for c_id, comp in _COMPONENT_CACHE.items():
            comps[c_id] = comp.clone()
        return

    # Slow Path: Load from Disk
    # Try absolute path based on this file if CWD fails
    if not os.path.exists(filepath):
        print(f"WARN: {filepath} not found in CWD ({os.getcwd()}).")
        base_dir = os.path.dirname(os.path.abspath(__file__))
        abs_path = os.path.join(base_dir, filepath)

        if os.path.exists(abs_path):
            filepath = abs_path
        else:
            print(f"ERROR: components file not found at {abs_path}")
            return

    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for comp_def in data['components']:
            c_type = comp_def['type']
            try:
                cls = Component 
                obj = cls(comp_def)
                temp_cache[comp_def['id']] = obj
            except Exception as e:
                print(f"ERROR creating component {comp_def.get('id')}: {e}")
        
        # Populate Cache
        _COMPONENT_CACHE = temp_cache
        _LAST_COMPONENT_FILE = filepath
        
        # Populate Registry from Cache
        comps = get_component_registry()
        for c_id, comp in _COMPONENT_CACHE.items():
            comps[c_id] = comp.clone()
            
    except Exception as e:
        print(f"ERROR loading/parsing components json: {e}")

def load_modifiers(filepath="data/modifiers.json"):
    global _MODIFIER_CACHE, _LAST_MODIFIER_FILE
    import os
    import copy
    from game.core.registry import get_modifier_registry
    
    # Fast Path
    if _MODIFIER_CACHE is not None and _LAST_MODIFIER_FILE == filepath:
        mods = get_modifier_registry()
        for m_id, mod in _MODIFIER_CACHE.items():
            mods[m_id] = copy.deepcopy(mod)
        return
    
    # Slow Path
    if not os.path.exists(filepath):
         base_dir = os.path.dirname(os.path.abspath(__file__))
         filepath = os.path.join(base_dir, filepath)
    
    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for mod_def in data['modifiers']:
            mod = Modifier(mod_def)
            temp_cache[mod.id] = mod
        
        _MODIFIER_CACHE = temp_cache
        _LAST_MODIFIER_FILE = filepath
        
        mods = get_modifier_registry()
        for m_id, mod in _MODIFIER_CACHE.items():
            mods[m_id] = copy.deepcopy(mod)
            
    except Exception as e:
        print(f"ERROR loading modifiers: {e}")

def create_component(component_id):
    """Create a clone of a component from the registry by ID."""
    comps = get_component_registry()
    if component_id in comps:
        return comps[component_id].clone()
    print(f"Error: Component ID {component_id} not found in registry.")
    return None

def get_all_components():
    """Get a list of all components in the registry."""
    return list(get_component_registry().values())


--- END FILE: game/simulation/components/component.py ---

--- START FILE: game/core/registry.py ---
from typing import Dict, Any, Optional
import threading

class RegistryManager:
    """
    Central singleton for managing global game state registries.
    
    Replaces module-level globals to allow for clean state resets in testing.
    
    Thread Safety:
        - Instance creation is thread-safe via double-checked locking
        - All dictionary operations use the same dict instances (no replacement)
        - Individual dict operations are atomic in CPython (GIL)
        - For cross-registry transactions, external synchronization is required
    
    Usage:
        # Preferred: Use utility functions (easier to mock)
        from game.core.registry import get_component_registry, get_modifier_registry
        
        components = get_component_registry()
        modifiers = get_modifier_registry()
        classes = get_vehicle_classes()
        
        # Alternative: Direct access (when needed for special operations)
        mgr = RegistryManager.instance()
        mgr.clear()  # For test isolation
        mgr.freeze() # For production initialization
    
    Testing:
        - Use conftest.py's reset_game_state fixture (auto-applied)
        - Fixture calls clear() before/after each test
        - Never call reset() in production code
    
    Attributes:
        components: Dict of component definitions keyed by ID
        modifiers: Dict of modifier definitions keyed by ID
        vehicle_classes: Dict of vehicle class definitions keyed by name
    """
    _instance: Optional['RegistryManager'] = None
    _lock = threading.Lock()

    def __init__(self):
        """
        Initialize the RegistryManager.
        
        Raises:
            Exception: If called directly instead of via instance()
        """
        if RegistryManager._instance is not None:
             raise Exception("RegistryManager is a singleton. Use RegistryManager.instance()")
        
        self.components: Dict[str, Any] = {}
        self.modifiers: Dict[str, Any] = {}
        self.vehicle_classes: Dict[str, Any] = {}
        self._validator: Any = None 
        self._frozen: bool = False

    @classmethod
    def instance(cls) -> 'RegistryManager':
        """
        Get the singleton instance, creating it if necessary.
        
        Thread-safe via double-checked locking pattern.
        
        Returns:
            The singleton RegistryManager instance
        """
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance
    
    @classmethod
    def reset(cls):
        """
        Completely destroy the singleton instance.
        
        WARNING: For testing only! This can cause stale reference hazards if
        any code is holding references to the old instance's dictionaries.
        
        Prefer clear() for test isolation - it preserves dict identity while
        emptying the contents.
        """
        cls._instance = None

    def freeze(self):
        """
        Prevent further modifications to the registry.
        
        Call this after game initialization to catch accidental mutations
        during gameplay. Useful for detecting bugs where code tries to
        modify registry data at runtime.
        """
        self._frozen = True

    def hydrate(self, components_data: Dict[str, Any], modifiers_data: Dict[str, Any], vehicle_classes_data: Dict[str, Any]):
        """
        Fast hydration from pre-loaded dictionary data.
        
        Used by test fixtures to populate registries from SessionRegistryCache
        without disk I/O. Updates dictionaries in-place to preserve any
        existing references.
        
        Args:
            components_data: Pre-loaded component definitions
            modifiers_data: Pre-loaded modifier definitions  
            vehicle_classes_data: Pre-loaded vehicle class definitions
            
        Raises:
            RuntimeError: If the registry is frozen
        """
        if self._frozen:
            raise RuntimeError("Cannot hydrate a frozen RegistryManager")
            
        # NOTE: We update dictionaries in-place rather than replacing them.
        # This ensures any code holding references to these dicts sees the updates.
        self.components.clear()
        self.components.update(components_data)
        
        self.modifiers.clear()
        self.modifiers.update(modifiers_data)
        
        self.vehicle_classes.clear()
        self.vehicle_classes.update(vehicle_classes_data)

    def clear(self):
        """
        Clear all registries to empty state.
        
        Used by test fixtures to ensure clean state between tests.
        Preserves dict identity, only empties contents.
        
        Raises:
            RuntimeError: If the registry is frozen
        """
        if self._frozen:
             raise RuntimeError("Cannot clear a frozen RegistryManager (Tests must unfreeze or reset if absolutely necessary)")
        self.components.clear()
        self.modifiers.clear()
        self.vehicle_classes.clear()
        self._validator = None

    def get_validator(self):
        """Get the ship design validator (may be None if not initialized)."""
        return self._validator
    
    def set_validator(self, validator):
        """
        Set the ship design validator.
        
        Args:
            validator: ShipDesignValidator instance
            
        Raises:
            RuntimeError: If the registry is frozen
        """
        self._check_frozen()
        self._validator = validator

    def _check_frozen(self):
        """Helper to raise error if modifications are attempted while frozen."""
        if self._frozen:
            raise RuntimeError("RegistryManager is frozen and cannot be modified")

def get_component_registry() -> Dict[str, Any]:
    """Get the component registry dictionary.
    
    Returns a reference to the live dictionary managed by RegistryManager.
    Prefer this over direct RegistryManager.instance().components access.
    """
    return RegistryManager.instance().components

def get_modifier_registry() -> Dict[str, Any]:
    """Get the modifier registry dictionary."""
    return RegistryManager.instance().modifiers

def get_vehicle_classes() -> Dict[str, Any]:
    """Get the vehicle classes dictionary."""
    return RegistryManager.instance().vehicle_classes

def get_validator():
    """Get the ship design validator (lazy-loaded)."""
    return RegistryManager.instance().get_validator()

--- END FILE: game/core/registry.py ---

