# INSTRUCTIONS FOR AGENT (Code_Reviewer)

**ROLE:** Code_Reviewer
**FOCUS:** Verify Phase 4 Implementation Quality & Completeness

## YOUR GOAL
Analyze the provided code context below.
Isolate issues specifically related to your FOCUS (Verify Phase 4 Implementation Quality & Completeness).
Ignore unrelated issues unless they are critical system failures.

## PHASE STATUS

--- ACTIVE REFACTOR CONTEXT ---
# Active Refactor: Hull Component & Ship Cohesion
**Goal:** Unify Ship stats with V2 Ability System (Hull Component) and eliminate architectural incoherence.

## Status
**Current Phase:** Phase 4 (UI Reconstruction) - AWAITING REVIEW
**Start Date:** 2026-01-05
**Phase 1 Review:** ✅ APPROVED (2026-01-06)
**Phase 2 Review:** ✅ APPROVED (2026-01-06)
**Phase 3 Review:** ✅ APPROVED (2026-01-06)
**Phase 4 Review:** ⏳ PENDING (2026-01-06)
**Status:** [PHASE_4_COMPLETE_PENDING_REVIEW]

---

## Migration Map (The Constitution)

| Concept | Legacy State | Target State | Source of Truth |
| :--- | :--- | :--- | :--- |
| **Hull Definition** | `vehicleclasses.json` (hull_mass, hp) | `components.json` ("type": "Hull") | Component Data |
| **Base Mass** | `Ship.base_mass` (manual float) | Sum of `Hull` component + Systems | `ShipStatsCalculator` |
| **Requirements** | Hardcoded checks & `Ship.requirements` | `CrewRequired`, `FuelStorage` Abilities | Ability System V2 |
| **Resource State** | Reset on Load (Volatile) | Persisted in `Ship.resources` | Save Data |
| **UI Layout** | Hardcoded Pixel Overlaps | Responsive/Grid-based | `builder_utils.py` |

---

## Phased Schedule

### Phase 1: Data & State Foundations (The Bedrock) [Complete]
**Objective:** Fix critical state bugs and prepare data structures.
- [x] **Critical Fix:** Patch `resource_manager.py` clamping bug (resets to 0 on overflow).
- [x] **Data Migration:** Create `Hull` components in `data/components.json` for all 18 classes. [Data Architect]
- [x] **Data Migration:** Add `default_hull_id` to `data/vehicleclasses.json`. [Data Architect]
- [x] **Serialization:** Update `Ship.to_dict`/`from_dict` to persist `ResourceRegistry` values. [Data Architect]
- [x] **Cleanup:** Remove hardcoded ability string maps in `Component._instantiate_abilities`.

---

### Phase 2: Core Logic & Stability (The Engine) [Complete]
**Objective:** Implement the "Hull as Component" logic and fix core simulation loops.
- [x] **Task 2.1:** Update `Ship.__init__` to auto-equip `default_hull_id`. [Core Engineer]
- [ ] **Task 2.2:** Switch `Ship.mass` and `Ship.hp` to cached properties in `ShipStatsCalculator`. (DEFERRED - optimization)
- [x] **Task 2.3:** Implement `CommandAndControl` and `CrewRequired` logic in `update_derelict_status`.
- [x] **Task 2.4:** Remove duplicate To-Hit/Derelict initializations in `Ship.py`.
- [x] **Task 2.5:** Standardize MRO-based identity checks (remove brittle class name checks).
- [x] **Task 2.6:** Fix detail panel rendering test regressions. [UI Specialist]
  - **File:** `tests/unit/ui/test_detail_panel_rendering.py`
  - **Fix:** Added missing `uitextbox_patch_real.stop()` in tearDown to prevent patch leakage causing intermittent failures in parallel execution.

---

## Phase 2 Implementation Specifications

### Task 2.1: Auto-Equip `default_hull_id` in `Ship.__init__`
**File:** `game/simulation/entities/ship.py`
**Method:** `__init__`

**Current State (lines ~223-230):**
```python
class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
self.base_mass: float = class_def.get('hull_mass', 50)  # LEGACY
```

**Target Implementation:**
```python
from game.simulation.components.component import create_component

# In __init__, AFTER _initialize_layers():
class_def = get_vehicle_classes().get(self.ship_class, {})
default_hull_id = class_def.get('default_hull_id')

if default_hull_id:
    hull_component = create_component(default_hull_id)
    if hull_component:
        self.add_component(hull_component, LayerType.CORE)
    else:
        print(f"WARNING: Hull '{default_hull_id}' not found for {self.ship_class}")
```

**Steps:**
1. Import `create_component` from `game.simulation.components.component`.
2. Remove `self.base_mass` assignment from `class_def.get('hull_mass', ...)`.
3. After `_initialize_layers()`, lookup `default_hull_id` and call `create_component()`.
4. Add Hull to `CORE` layer via `add_component()`.

**Edge Cases:**
- Missing `default_hull_id` → Log warning, continue (test-only ships).
- Component registry not loaded → Graceful `None` return from `create_component`.

---

### Task 2.2: Cached `mass` and `hp` Properties
**Files:** `game/simulation/entities/ship.py`, `ship_stats.py`

**Current State:**
- `self.mass: float = 0.0` (direct attribute)
- `@property max_hp` / `hp` → O(n) iteration on every access

**Target Implementation in `Ship.__init__`:**
```python
self._cached_mass: float = 0.0
self._cached_max_hp: int = 0
self._cached_hp: int = 0
```

**Target Properties:**
```python
@property
def mass(self) -> float:
    return self._cached_mass

@property
def max_hp(self) -> int:
    return self._cached_max_hp

@property
def hp(self) -> int:
    return self._cached_hp
```

**In `ShipStatsCalculator.calculate(ship)`:**
```python
# Calculate and cache
total_mass = sum(c.mass for layer in ship.layers.values() for c in layer['components'])
total_max_hp = sum(c.max_hp for layer in ship.layers.values() for c in layer['components'])
total_hp = sum(c.current_hp for layer in ship.layers.values() for c in layer['components'])

ship._cached_mass = total_mass
ship._cached_max_hp = total_max_hp
ship._cached_hp = total_hp
```

---

### Task 2.3: Ability-Based Derelict Logic
**File:** `game/simulation/entities/ship.py`
**Method:** `update_derelict_status`

**New Abilities Required (in `abilities.py`):**
```python
class CommandAndControl(Ability):
    """Marks component as command center (Bridge, CIC)."""
    pass
```

**Target Implementation:**
```python
def update_derelict_status(self) -> None:
    # Check 1: Command and Control
    has_command = any(
        comp.is_operational and comp.has_ability('CommandAndControl')
        for layer in self.layers.values()
        for comp in layer['components']
    )
    
    if not has_command:
        self.is_derelict = True
        self.bridge_destroyed = True
        return
    
    # Check 2: Crew Capacity (optional)
    total_crew_req = self.get_total_ability_value('CrewRequired')
    total_crew_cap = self.get_total_ability_value('CrewCapacity')
    
    if total_crew_req > total_crew_cap:
        self.is_derelict = True
        return
    
    self.is_derelict = False
```

**Data Migration:** Add `"CommandAndControl": true` to Bridge components in `components.json`.

---

### Task 2.4: Remove Duplicate Initializations
**File:** `game/simulation/entities/ship.py`

**Remove (lines ~248-251):**
```python
self.baseline_to_hit_offense = 0.0  # DUPLICATE
self.to_hit_profile = 0.0  # DUPLICATE
```

**Keep (lines ~298-300):**
```python
self.to_hit_profile: float = 1.0       # Defensive Multiplier
self.baseline_to_hit_offense: float = 1.0  # Offensive Multiplier
```

---

### Task 2.5: Standardize Identity Checks
**File:** `game/simulation/entities/ship.py`
**Method:** `max_weapon_range` (lines ~325-355)

**Current (brittle):**
```python
if cls.__name__ == 'WeaponAbility':  # STRING CHECK
```

**Target:**
```python
from game.simulation.components.abilities import WeaponAbility, SeekerWeaponAbility

for ab in comp.ability_instances:
    if isinstance(ab, WeaponAbility):  # POLYMORPHIC
        rng = getattr(ab, 'range', 0.0)
        if isinstance(ab, SeekerWeaponAbility) and rng <= 0:
            rng = ab.projectile_speed * ab.endurance
        max_rng = max(max_rng, rng)
```

### Phase 3: Test Infrastructure & Verification (The Guardrails) [Complete]
**Objective:** Restore test isolation and verify unified stats.
- [x] **Task 3.1:** Restore/Fix `tests/conftest.py` for proper `RegistryManager` isolation. [QA Lead]
  - Added pre-test `mgr.clear()` before marker check
  - Restructured with try/finally for unconditional post-test cleanup
- [x] **Task 3.2:** Create `tests/unit/entities/test_ship_core.py` (Mocked Hull/Stat verification).
  - Created 6 test cases covering Hull auto-equip, legacy fallback, mass/HP aggregation, derelict status
  - All tests passing
- [x] **Task 3.3:** Audit existing Ship tests for `RegistryManager` usage compliance.
  - grep for COMPONENT_REGISTRY → 0 matches ✓
  - grep for VEHICLE_CLASSES → 0 matches ✓

---

## Phase 3 Implementation Specifications

### Task 3.1: Registry Isolation in `conftest.py`
**File:** `tests/conftest.py`
**Root Cause:** `reset_game_state` fixture skips cleanup when `use_custom_data` marker is present.

**Target Implementation:**
```python
@pytest.fixture(autouse=True)
def reset_game_state(monkeypatch, request):
    from game.core.registry import RegistryManager
    mgr = RegistryManager.instance()
    
    # Pre-test cleanup (ALWAYS)
    mgr.clear()

    if "use_custom_data" not in request.keywords:
        # Standard Fast Hydration
        cache = SessionRegistryCache.instance()
        cache.load_all_data()
        mgr.hydrate(...)
        
    yield
    
    # Post-test cleanup (ALWAYS RUNS)
    mgr.clear()
```

**Steps:**
1. Open `tests/conftest.py`.
2. Locate `reset_game_state` fixture.
3. Add `mgr.clear()` call BEFORE the marker check.
4. Ensure `mgr.clear()` is called AFTER `yield` unconditionally.
5. Run `pytest tests/unit/entities/test_sequence_hazard.py` to verify isolation.

---

### Task 3.2: Create `test_ship_core.py`
**File:** `tests/unit/entities/test_ship_core.py`

**Test Cases:**

#### TC-3.2.1: Hull Auto-Equip Verification
```python
def test_hull_auto_equip(registry_with_hull):
    """Verify Ship auto-equips default_hull_id from vehicle class."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="Escort")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 1
    assert core_comps[0].id == "hull_escort"
    assert ship.base_mass == 0.0  # Attribute Shadowing
```

#### TC-3.2.2: Legacy Fallback (No Hull)
```python
def test_no_hull_fallback(registry_no_hull):
    """Verify Ship uses legacy hull_mass when no default_hull_id."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="TestShip")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 0
    assert ship.base_mass == 100.0
```

#### TC-3.2.3: Mass Aggregation
```python
def test_mass_from_components(ship_with_components):
    """Verify Ship.mass equals sum of all component masses + base_mass."""
    ship = ship_with_components
    ship.recalculate_stats()
    
    expected_mass = ship.base_mass + sum(
        c.mass for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.mass == expected_mass
```

#### TC-3.2.4: HP Aggregation
```python
def test_hp_from_components(ship_with_components):
    """Verify Ship.max_hp equals sum of component max_hp values."""
    ship = ship_with_components
    
    expected_hp = sum(
        c.max_hp for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.max_hp == expected_hp
```

#### TC-3.2.5: Derelict Status from CommandAndControl
```python
def test_derelict_on_bridge_destruction(ship_with_bridge):
    """Verify ship becomes derelict when CommandAndControl component destroyed."""
    ship = ship_with_bridge
    bridge = next(c for c in ship.layers[LayerType.CORE]['components'] 
                  if c.has_ability('CommandAndControl'))
    
    bridge.current_hp = 0
    ship.update_derelict_status()
    
    assert ship.is_derelict is True
```

**Fixtures Required:**
- `registry_with_hull`: Populates RegistryManager with Escort class + hull_escort component.
- `registry_no_hull`: Populates RegistryManager with TestShip class (hull_mass=100, no default_hull_id).
- `ship_with_components`: Creates Ship with known components for mass/HP testing.
- `ship_with_bridge`: Creates Ship with Bridge component having CommandAndControl ability.

---

### Task 3.3: Audit Ship Tests for RegistryManager Compliance
**Scope:** `tests/unit/entities/`, `tests/integration/`

**Verification Steps:**
1. `grep -r "COMPONENT_REGISTRY" tests/` → Should return 0 matches.
2. `grep -r "VEHICLE_CLASSES" tests/` → Should return 0 matches.
3. `grep -r "from game.simulation.entities.ship import" tests/` → Verify imports use `get_vehicle_classes`, `get_component_registry`.

**Remediation Pattern:**
```python
# OLD (Direct Import)
from game.simulation.entities.ship import COMPONENT_REGISTRY

# NEW (RegistryManager Access)
from game.core.registry import get_component_registry
components = get_component_registry()
```

**Run Verification:**
```bash
pytest tests/unit/entities/ -v
pytest tests/integration/ -v
```

### Phase 4: UI Reconstruction (The Interface) [Complete]
**Objective:** Resolve layout overlaps and ensure builder compatibility.
- [x] **Task 4.1:** Create `game/ui/screens/builder_utils.py` (Layout constants). [UI Specialist]
  - Created centralized module with `PanelWidths`, `PanelHeights`, `Margins`, and `BuilderEvents` constants
- [x] **Task 4.2:** Implement relative/grid sizing for `builder_screen.py` to fix 1920px overlap.
  - FIXED: Changed `layer_panel_width` from fixed `PANEL_WIDTHS.layer_panel` to dynamic `calculate_dynamic_layer_width(screen_width)`
  - FIXED: `weapons_panel_width` calculation now subtracts `right_panel_width` to prevent overlap
- [x] **Task 4.3:** Resolve vertical collision between Weapons Report and Nav Panels.
  - ANALYZED: `right_panel.py` uses single scroll container, no sub-panels needing `update_layout()`
  - RECLASSIFIED: Issue was horizontal overlap (covered by Task 4.2b), not vertical stacking
- [x] **Task 4.4:** Switch `BuilderSceneGUI` to event-based data sync using `REGISTRY_RELOADED`.
  - Added `REGISTRY_RELOADED` event emission in `_reload_data`
  - Updated `BuilderRightPanel` and `BuilderLeftPanel` to subscribe to event

### Phase 5: Legacy Purge & Final Polish (The Cleanup)
**Objective:** Remove deprecated data and finalize the refactor.
- [ ] **Cleanup:** Remove `hull_mass` and `requirements` from `vehicleclasses.json`.
- [ ] **Cleanup:** Remove hardcoded ship fallback registry in `load_vehicle_classes`.
- [ ] **Final Verification:** Run Full Gauntlet (Target: 100% Pass).
- [ ] **Definition of Done:**
    - `Ship.py` has ZERO hardcoded mass/hp assignments.
    - `vehicleclasses.json` contains NO physical stats.
    - Ship Builder UI renders without overlap on 1080p+.
    - Save/Load persists fuel/ammo levels correctly.

---

## Phase 4 Implementation Specifications

### Task 4.1: Centralize Layout Constants
**File:** `game/ui/screens/builder_utils.py` [NEW]

**Implementation Spec:**
Create a utility module to define the design system's dimensions.

```python
# game/ui/screens/builder_utils.py

PANEL_WIDTHS = {
    'component_palette': 400,
    'structure_list': 400,
    'detail_panel': 500,
    'ship_stats': 750
}

PANEL_HEIGHTS = {
    'bottom_bar': 60,
    'weapons_report': 500,
    'modifier_panel': 360
}

MARGINS = {
    'edge': 20,
    'gutter': 10
}
```

---

### Task 4.2: Relative/Grid Layout for 1920px+
**File:** `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Calculate Available Center Width:** `center_width = screen_width - PANEL_WIDTHS['component_palette'] - PANEL_WIDTHS['ship_stats']`.
2. **Dynamic Layer Panel:** Instead of fixed 450px, the Layer Panel should take `min(400, center_width * 0.3)`.
3. **Schematic View:** Takes the remaining center space.
4. **Detail Panel Overlay:** Position the Detail Panel as a `pygame_gui.elements.UIPanel` with a relative offset from the right.

---

### Task 4.3: Resolve Vertical Panel Collision
**File:** `ui/builder/right_panel.py`

**Implementation Spec:**
The "Weapons Report" and "Navigation Panels" must use a vertical stack instead of fixed Y-offsets.

```python
def update_layout(self):
    current_y = MARGINS['edge']
    for panel in self.sub_panels:
        panel.set_relative_position((0, current_y))
        current_y += panel.rect.height + MARGINS['gutter']
```

---

### Task 4.4: Event-Based UI Synchronization
**Files:** `ui/builder/event_bus.py`, `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Registry Reload Event:** Add `REGISTRY_RELOADED = 'REGISTRY_RELOADED'` to `EventBus`.
2. **Panel Subscriptions:** `BuilderRightPanel` and `BuilderLeftPanel` subscribe to `REGISTRY_RELOADED`.
3. **Internal Refresh:** Update `BuilderRightPanel.refresh_controls()` to update dropdown *options* without killing the object.
4. **Preserve Selection:** Cache `self.ship.ship_class` before reload and re-apply to dropdown after refresh.

---

## Test Triage Table
| Issue | File | Status | Owner | Notes |
| :--- | :--- | :--- | :--- | :--- |
| Task 4.2a: Dynamic Layer Width | `builder_screen.py` | RESOLVED | UI Specialist | Changed to `calculate_dynamic_layer_width(screen_width)` |
| Task 4.2b: Weapons Panel Width | `builder_screen.py` | RESOLVED | UI Specialist | Subtracted `right_panel_width` from calculation |
| Task 4.3: Vertical Stacking | `right_panel.py` | NOT_APPLICABLE | UI Specialist | Reclassified: right_panel uses single scroll container, no sub-panels |

--- END ACTIVE REFACTOR CONTEXT ---


## OUTPUT INSTRUCTIONS
You are an autonomous agent.
1. Perform your analysis.
2. **CRITICAL:** You MUST use the `write_to_file` tool to save your report.
   - **Target File:** `C:\Dev\Starship Battles\Refactoring\swarm_reports\Code_Reviewer_Report.md`
   - **Do NOT** just print the markdown to the chat. Save it to the file.

## CONTEXT

--- START FILE: game/ui/screens/builder_utils.py ---
# game/ui/screens/builder_utils.py
"""
Centralized layout constants for Ship Builder UI.

This module provides a single source of truth for all panel dimensions,
spacing, and layout configuration across the Ship Builder screen.
"""
from dataclasses import dataclass


@dataclass(frozen=True)
class PanelWidths:
    """Fixed panel widths (in pixels)."""
    component_palette: int = 400   # Left panel - component selection
    layer_panel: int = 400         # Layer/structure view
    right_panel: int = 750         # Ship stats and portrait
    detail_panel: int = 500        # Component detail overlay


@dataclass(frozen=True)
class PanelHeights:
    """Fixed panel heights (in pixels)."""
    bottom_bar: int = 60           # Bottom button bar
    weapons_report: int = 500      # Weapons report panel
    modifier_panel: int = 360      # Modifier editor at bottom


@dataclass(frozen=True)
class Margins:
    """Standard spacing values."""
    edge: int = 20                 # Edge padding from screen borders
    gutter: int = 10               # Gap between adjacent panels
    section: int = 20              # Space between logical sections


# Singleton instances for easy import
PANEL_WIDTHS = PanelWidths()
PANEL_HEIGHTS = PanelHeights()
MARGINS = Margins()


def calculate_center_width(screen_width: int) -> int:
    """
    Calculate available width for center content area.
    
    Args:
        screen_width: Total screen width in pixels
        
    Returns:
        Available width between left palette and right stats panel
    """
    return screen_width - PANEL_WIDTHS.component_palette - PANEL_WIDTHS.right_panel


def calculate_schematic_rect(screen_width: int, screen_height: int):
    """
    Calculate the rect for the schematic view.
    
    Args:
        screen_width: Total screen width
        screen_height: Total screen height
        
    Returns:
        pygame.Rect for the schematic view area
    """
    import pygame
    
    x = PANEL_WIDTHS.component_palette + PANEL_WIDTHS.layer_panel
    y = 0
    width = screen_width - x - PANEL_WIDTHS.right_panel
    height = screen_height - PANEL_HEIGHTS.bottom_bar - PANEL_HEIGHTS.weapons_report
    
    return pygame.Rect(x, y, width, height)


def calculate_dynamic_layer_width(screen_width: int) -> int:
    """
    Calculate a responsive layer panel width based on available space.
    
    For very wide screens (>1920px), the layer panel can grow slightly.
    For narrower screens, it maintains minimum usability.
    
    Args:
        screen_width: Total screen width
        
    Returns:
        Dynamic layer panel width
    """
    center = calculate_center_width(screen_width)
    
    # Layer panel takes 30% of center, capped between 300-500px
    dynamic_width = int(center * 0.3)
    return max(300, min(500, dynamic_width))


# Event types for UI synchronization
class BuilderEvents:
    """Event type constants for the Builder EventBus."""
    SHIP_UPDATED = 'SHIP_UPDATED'
    SELECTION_CHANGED = 'SELECTION_CHANGED'
    REGISTRY_RELOADED = 'REGISTRY_RELOADED'

--- END FILE: game/ui/screens/builder_utils.py ---

--- START FILE: game/ui/screens/builder_screen.py ---
import json
import math
import tkinter
from tkinter import simpledialog, filedialog
import os

import pygame
import pygame_gui
from pygame_gui.elements import (
    UIPanel, UILabel, UIButton, UIDropDownMenu, 
    UITextEntryLine, UISelectionList, UIWindow
)
from pygame_gui.windows import UIConfirmationDialog

from game.core.profiling import profile_action, profile_block

from game.simulation.entities.ship import Ship, LayerType
from game.core.registry import RegistryManager, get_component_registry, get_modifier_registry, get_vehicle_classes
from game.simulation.components.component import (
    get_all_components
)
from game.ui.renderer.sprites import SpriteManager
from preset_manager import PresetManager
from game.simulation.systems.persistence import ShipIO
from game.ui.panels.builder_widgets import ModifierEditorPanel
from ship_theme import ShipThemeManager
from ui.builder import BuilderLeftPanel, BuilderRightPanel, WeaponsReportPanel, LayerPanel
from ui.builder.schematic_view import SchematicView
from ui.builder.interaction_controller import InteractionController
from ui.builder.event_bus import EventBus
from game.ui.screens.builder_utils import PANEL_WIDTHS, PANEL_HEIGHTS, MARGINS, BuilderEvents, calculate_dynamic_layer_width
from game.core.screenshot_manager import ScreenshotManager

# Initialize Tkinter root and hide it (for simpledialog)
# Initialize Tkinter root and hide it (for simpledialog)
try:
    if os.environ.get("SDL_VIDEODRIVER") == "dummy":
        tk_root = None
    else:
        tk_root = tkinter.Tk()
        tk_root.withdraw()
except:
    tk_root = None


# Colors
from ui.colors import COLORS
BG_COLOR = COLORS['bg_deep']
PANEL_BG = '#14181f'

import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

from ui.builder.detail_panel import ComponentDetailPanel








class BuilderSceneGUI:
    def __init__(self, screen_width, screen_height, on_start_battle):
        self.width = screen_width
        self.height = screen_height
        self.on_start_battle = on_start_battle
        
        self.event_bus = EventBus()
        self.screenshot_manager = ScreenshotManager.get_instance()
        
        # UI Manager
        from game.core.constants import ROOT_DIR, DATA_DIR, ASSET_DIR
        theme_path = os.path.join(ROOT_DIR, 'builder_theme.json')
        with profile_block("Builder: Init UIManager"):
            self.ui_manager = pygame_gui.UIManager(
                (screen_width, screen_height),
                theme_path=theme_path if os.path.exists(theme_path) else None
            )
        
        # Ship
        self.ship = Ship("Custom Ship", screen_width // 2, screen_height // 2, (100, 100, 255))
        self.ship.recalculate_stats()
        
        # Managers
        self.available_components = get_all_components()
        self.template_modifiers = {}
        self.sprite_mgr = SpriteManager.get_instance()
        
        with profile_block("Builder: Init Managers"):
            self.preset_manager = PresetManager(os.path.join(DATA_DIR, "presets.json"))
            self.theme_manager = ShipThemeManager.get_instance()
            self.theme_manager.initialize() # No path needed anymore
        
        # Layout (from centralized constants)
        self.left_panel_width = PANEL_WIDTHS.component_palette
        self.right_panel_width = PANEL_WIDTHS.right_panel
        self.layer_panel_width = calculate_dynamic_layer_width(screen_width)
        self.detail_panel_width = PANEL_WIDTHS.detail_panel
        self.bottom_bar_height = PANEL_HEIGHTS.bottom_bar
        self.weapons_report_height = PANEL_HEIGHTS.weapons_report
        
        # MVC Lite
        # Schematic View shifted right
        sch_x = self.left_panel_width + self.layer_panel_width
        rect = pygame.Rect(
            sch_x, 0,
            self.width - sch_x - self.right_panel_width,
            self.height - self.bottom_bar_height - self.weapons_report_height
        )
        self.view = SchematicView(rect, self.sprite_mgr, self.theme_manager)
        self.controller = InteractionController(self, self.view)
        
        self.error_message = ""
        self.error_timer = 0
        self.show_firing_arcs = False
        
        self.show_firing_arcs = False
        
        # New Selection System
        self.selected_components = [] # List of (layer_type, index, component) tuples or wrapped components

        
        self._create_ui()
        
    def _create_ui(self):
        # New Layout Dimensions
        self.modifier_panel_height = 360
        avail_height = self.height - self.bottom_bar_height
        panels_height = avail_height - self.modifier_panel_height
        
        with profile_block("Builder: Init Panels (Left/Right/Layer)"):
            self.left_panel = BuilderLeftPanel(
                self, self.ui_manager,
                pygame.Rect(0, 0, self.left_panel_width, panels_height),
                event_bus=self.event_bus
            )
            
            # New Layer Panel
            self.layer_panel = LayerPanel(
                self, self.ui_manager,
                pygame.Rect(self.left_panel_width, 0, self.layer_panel_width, panels_height)
            )
            # Register Drop Target
            self.controller.register_drop_target(self.layer_panel)
            
            self.right_panel = BuilderRightPanel(
                self, self.ui_manager,
                pygame.Rect(self.width - self.right_panel_width, 0, 
                            self.right_panel_width, self.height - self.bottom_bar_height - self.weapons_report_height),
                event_bus=self.event_bus
            )
            
            # Modifier Panel (Bottom Spanning Left+Layer)
            mod_panel_rect = pygame.Rect(
                0, panels_height,
                self.left_panel_width + self.layer_panel_width,
                self.modifier_panel_height
            )
            
            # We need a wrapper panel for the modifier editor to draw into? 
            # ModifierEditorPanel expects a 'container' (UIPanel). 
            # Let's create one.
            self.modifier_container_panel = UIPanel(
                relative_rect=mod_panel_rect,
                manager=self.ui_manager,
                object_id='#modifier_panel_container'
            )
            
            self.modifier_panel = ModifierEditorPanel(
                manager=self.ui_manager,
                container=self.modifier_container_panel,
                width=mod_panel_rect.width,
                preset_manager=self.preset_manager,
                on_change_callback=self._on_modifier_change
            )
        
        weapons_panel_y = self.height - self.bottom_bar_height - self.weapons_report_height
        # Shifted weapons panel
        weapons_panel_x = self.left_panel_width + self.layer_panel_width
        weapons_panel_width = self.width - weapons_panel_x - self.right_panel_width
        with profile_block("Builder: Init Weapons Panel"):
            self.weapons_report_panel = WeaponsReportPanel(
                self, self.ui_manager,
                pygame.Rect(weapons_panel_x, weapons_panel_y, weapons_panel_width, self.weapons_report_height),
                self.sprite_mgr
            )

        # Detail Panel
        detail_x = self.width - self.right_panel_width - self.detail_panel_width
        avail_height = self.height - self.bottom_bar_height - self.weapons_report_height
        
        # Component Image Path
        from game.core.constants import ASSET_DIR
        comp_img_path = os.path.join(ASSET_DIR, "Images", "Components")
        
        with profile_block("Builder: Init Detail Panel"):
            self.detail_panel = ComponentDetailPanel(
                self.ui_manager,
                pygame.Rect(detail_x, 0, self.detail_panel_width, avail_height),
                comp_img_path,
                event_bus=self.event_bus
            )
        
        # Bottom Bar Buttons
        btn_y = self.height - self.bottom_bar_height + 10
        btn_w = 140
        btn_h = 40
        spacing = 10
        
        # Define buttons to create in order
        # (Attribute Name, Text, Width)
        button_defs = [
            ('clear_btn', "Clear Design", 110),
            ('save_btn', "Save", 80),
            ('load_btn', "Load", 80),
            ('arc_toggle_btn', "Show Firing Arcs", 140),
            ('target_btn', "Select Target", 110),
            ('std_data_btn', "Standard Data", 110),
            ('test_data_btn', "Test Data", 90),
            ('select_data_btn', "Select Data...", 110),
            ('verbose_btn', "Toggle Verbose", 120),
            ('start_btn', "Return", 100)
        ]
        
        total_width = sum(b[2] for b in button_defs) + spacing * (len(button_defs) - 1)
        start_x = (self.width - total_width) // 2
        
        current_x = start_x
        for attr_name, text, w in button_defs:
            btn = UIButton(pygame.Rect(current_x, btn_y, w, btn_h), text, self.ui_manager)
            setattr(self, attr_name, btn)
            current_x += w + spacing
        
        self.confirm_dialog = None
        
        self.update_stats()
        self.left_panel.update_component_list()
        self.rebuild_modifier_ui()


    def update_stats(self):
        # self.right_panel.update_stats_display(self.ship) # Now handled by event
        self.layer_panel.rebuild()
        self.event_bus.emit('SHIP_UPDATED', self.ship)
        
    def on_selection_changed(self, new_selection, append=False, toggle=False):
        """
        Handle selection changes.
        new_selection: can be a single component tuple (layer, idx, comp), a list of them, or None.
        append: If True, add to existing selection instead of replacing.
        toggle: If True, toggles selection state of existing items (Ctrl+Click behavior).
        """
        if new_selection is None:
            if not append:
                self.selected_components = []
        else:
            if not isinstance(new_selection, list):
                new_selection = [new_selection]
            
            # Normalize to tuples if possible, or wrapping objects
            # Ideally we want (layer, index, comp)
            # If we get just component, we'll have to find it or wrap it
            
            norm_selection = []
            for item in new_selection:
                if isinstance(item, tuple) and len(item) == 3:
                    norm_selection.append(item)
                elif hasattr(item, 'id'): # It's a component
                     # Find it in ship?
                     found = False
                     for l_type, l_data in self.ship.layers.items():
                         try:
                             idx = l_data['components'].index(item)
                             norm_selection.append((l_type, idx, item))
                             found = True
                             break
                         except ValueError:
                             continue
                     if not found:
                         # Maybe it's a template (dragged)
                         norm_selection.append((None, -1, item))
            
            if append:
                # 1. Enforce Homogeneity
                # Check if new items match the type (definition ID) of existing selection
                if self.selected_components and norm_selection:
                    # Get definition ID of currently selected items (assuming they are homogeneous)
                    # We can check the first one.
                    current_def_id = self.selected_components[0][2].id
                    
                    # Check if all new items match this ID
                    matches_type = all(item[2].id == current_def_id for item in norm_selection)
                    
                    if not matches_type:
                        # User clicked a different type. Standard behavior: Replace selection.
                        # This feels cleaner than ignoring it.
                        self.selected_components = norm_selection
                        append = False # Treat as replace
                    else:
                        # Add unique items (Uniqueness based on OBJECT IDENTITY, not Def ID)
                        current_objs = {c[2] for c in self.selected_components}
                        for item in norm_selection:
                            if item[2] in current_objs:
                                if toggle:
                                    # Toggle OFF
                                    self.selected_components = [x for x in self.selected_components if x[2] is not item[2]]
                                else:
                                    # Ensure selected (do nothing if already there)
                                    pass
                            else:
                                self.selected_components.append(item)
                else:
                    # Nothing currently selected, just append (which effectively is a set)
                     self.selected_components = norm_selection
            else:
                self.selected_components = norm_selection

        # Update dependent UI
        # For properties panel, we generally show the LAST selected item (or first?)
        # Let's show the last one added to selection as "primary"
        self.selected_component = self.selected_components[-1] if self.selected_components else None
        
        # Update Builder State for Panel
        if self.selected_components:
             # If we have a group selected, layer panel needs to know?
             # Layer panel now highlights based on builder.selected_components check in its rebuild
             pass

        self.rebuild_modifier_ui()
        self.event_bus.emit('SELECTION_CHANGED', self.selected_component)

    def _on_modifier_change(self):
        # Propagate to ALL selected components
        if self.selected_components:
            # The modifier panel edits "editing_component".
            # We need to sync that to others.
            editing_comp = self.selected_component[2]
            
            for item in self.selected_components:
                comp = item[2]
                if comp is editing_comp: continue
                
                # Apply modifiers from editing_comp to comp
                # Copy modifiers
                comp.modifiers = []
                for m in editing_comp.modifiers:
                    new_m = m.__class__(m.definition, m.value)
                    comp.modifiers.append(new_m)
                comp.recalculate_stats()
                
            editing_comp.recalculate_stats()
            
        self.ship.recalculate_stats()
        # self.right_panel.update_stats_display(self.ship) # Now handled by event
        self.event_bus.emit('SHIP_UPDATED', self.ship)

    def rebuild_modifier_ui(self):
        editing_component = self.selected_component[2] if self.selected_component else None
        # Start Y is 0 relative to the modifier container panel
        self.modifier_panel.rebuild(editing_component, self.template_modifiers)
        self.modifier_panel.layout(0)
        
    @property
    def selected_component(self):
        return self.controller.selected_component
        
    @selected_component.setter
    def selected_component(self, value):
        self.controller.selected_component = value
        
    @property
    def dragged_item(self):
        return self.controller.dragged_item
        
    @dragged_item.setter
    def dragged_item(self, value):
        self.controller.dragged_item = value

    def show_error(self, msg):
        self.error_message = msg
        self.error_timer = 3.0
        
    def _show_error(self, msg):
        self.show_error(msg)
        
    def handle_event(self, event):
        self.ui_manager.process_events(event)
        
         # Pass to modifier panel
        action = self.left_panel.handle_event(event)
        if not action:
            # Pass to layer panel (headers and items)
            action = self.layer_panel.handle_event(event)
            
        if not action:
            # Pass to relocated modifier panel
            action = self.modifier_panel.handle_event(event)

        if action:
            if isinstance(action, bool):
                 # Just consumed event, no data
                 return

            act_type, data = action
            if act_type == 'refresh_ui': 
                self.update_stats()
                
                
            elif act_type == 'select_component_type':
                with profile_block("Builder: Select Component Type"):
                    c = data
                    # Clear Layer Panel Selection (avoid confusion)
                    self.layer_panel.selected_group_key = None
                    self.layer_panel.selected_component_id = None
                    self.on_selection_changed(None) # Clear
                    self.layer_panel.rebuild()
                    
                    self.controller.dragged_item = c.clone()
                    # Apply template modifiers
                    mods = get_modifier_registry()
                    for m_id, val in self.template_modifiers.items():
                       if m_id in mods:
                           mod_def = mods[m_id]
                           allow = True
                           if mod_def.restrictions:
                               if 'allow_types' in mod_def.restrictions and c.type_str not in mod_def.restrictions['allow_types']:
                                   allow = False
                           if allow:
                               self.controller.dragged_item.add_modifier(m_id)
                               m = self.controller.dragged_item.get_modifier(m_id)
                               if m: m.value = val
                    self.controller.dragged_item.recalculate_stats()
                    
                    # Set as selected so modifiers panel updates
                    self.on_selection_changed(self.controller.dragged_item)
                
            elif act_type == 'select_group':
                with profile_block("Builder: Select Group"):
                    # Check modifier keys for multi-select
                    keys = pygame.key.get_pressed()
                    append = keys[pygame.K_LCTRL] or keys[pygame.K_RCTRL] or keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]
                    
                    if not append:
                        self.left_panel.deselect_all()
                    
                    # data is group_key
                    comps = []
                    from ui.builder.grouping_strategies import get_component_group_key
                    for layers in self.ship.layers.values():
                        for c in layers['components']:
                             if get_component_group_key(c) == data:
                                 comps.append(c)
                    
                    self.on_selection_changed(comps, append=append)
                    
                    # Rebuild layer panel now that builder state is updated
                    self.layer_panel.rebuild()
                
            elif act_type == 'select_individual':
                with profile_block("Builder: Select Individual"):
                    keys = pygame.key.get_pressed()
                    is_ctrl = keys[pygame.K_LCTRL] or keys[pygame.K_RCTRL]
                    is_shift = keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]
                    
                    if not (is_ctrl or is_shift):
                        self.left_panel.deselect_all()
                        
                    if is_shift and self.selected_component:
                        # Range Selection
                        start_comp = self.selected_component[2]
                        end_comp = data
                        range_comps = self.layer_panel.get_range_selection(start_comp, end_comp)
                        self.on_selection_changed(range_comps, append=is_ctrl, toggle=False)
                    else:
                        # Single Click (Toggle if Ctrl)
                        self.on_selection_changed(data, append=is_ctrl, toggle=is_ctrl)
                    
                    # Rebuild layer panel now that builder state is updated
                    self.layer_panel.rebuild()
                
            elif act_type == 'remove_group':
                 # User requested delete on group.
                 # Updated Requirement: Pressing - should delete ONE of the components.
                 
                 # data is group_key
                 from ui.builder.grouping_strategies import get_component_group_key
                 
                 # Find Last Component in this group to remove
                 found_layer = None
                 found_idx = -1
                 
                 # Iterate backwards to find one instance
                 for l_type, layers in self.ship.layers.items():
                    # Check safe iteration
                    comps = layers['components']
                    for idx in range(len(comps)-1, -1, -1):
                         c = comps[idx]
                         if get_component_group_key(c) == data:
                             found_layer = l_type
                             found_idx = idx
                             break
                    if found_layer: break
                 
                 if found_layer:
                     self.ship.remove_component(found_layer, found_idx)
                     # self.on_selection_changed(None) # Don't clear selection on partial remove?
                     # Better to clear if we removed the selected one.
                     self.update_stats()
                 
            elif act_type == 'remove_individual':
                 # data is component
                 removed = False
                 for l_type, layers in self.ship.layers.items():
                     for idx, c in enumerate(layers['components']):
                         if c is data:
                             self.ship.remove_component(l_type, idx)
                             removed = True
                             break
                     if removed:
                         break
                 
                 # Remove from selection list if present
                 if self.selected_components:
                      self.selected_components = [x for x in self.selected_components if x[2] is not data]
                      self.on_selection_changed(self.selected_components) # Update primary
                 
                 self.update_stats()
                 
            elif act_type == 'add_group' or act_type == 'add_individual':
                 # Clone and Add one instance
                 # data is group_key (for group) or component (for individual)
                 
                 target_comp = None
                 
                 if act_type == 'add_individual':
                     target_comp = data
                 else:
                     # Find first component of group
                     from ui.builder.grouping_strategies import get_component_group_key
                     for layers in self.ship.layers.values():
                         for c in layers['components']:
                             if get_component_group_key(c) == data:
                                 target_comp = c
                                 break
                         if target_comp: break
                         
                 if target_comp:
                     # Clone
                     new_comp = target_comp.clone()
                     for m in target_comp.modifiers:
                        new_comp.add_modifier(m.definition.id)
                        nm = new_comp.get_modifier(m.definition.id)
                        if nm: nm.value = m.value
                     new_comp.recalculate_stats()
                     
                     # Find layer of original
                     target_layer = None
                     for l_type, layers in self.ship.layers.items():
                         if target_comp in layers['components']:
                             target_layer = l_type
                             break
                             
                     if target_layer:
                         from game.simulation.entities.ship import get_or_create_validator
                         validation = get_or_create_validator().validate_addition(self.ship, new_comp, target_layer)
                         if validation.is_valid:
                             self.ship.add_component(new_comp, target_layer)
                             self.update_stats()
                         else:
                             self.show_error(f"Cannot add: {', '.join(validation.errors)}")

            elif act_type == 'apply_preset':
                self.template_modifiers = data
                self.rebuild_modifier_ui()
            elif act_type == 'clear_settings':
                with profile_block("Builder: Clear Settings"):
                    self.controller.selected_component = None
                    self.template_modifiers = {}
                    self.on_selection_changed(None)
                    self.rebuild_modifier_ui()
                    logger.debug("Cleared settings or deselected component")
            elif act_type == 'toggle_layer':
                # Layer header toggle - already handled by callback
                pass
            return
        
        # Pass to weapons panel
        self.weapons_report_panel.handle_event(event)
        
        self.controller.handle_event(event)
        
        if event.type == pygame_gui.UI_BUTTON_PRESSED:
            if event.ui_element == self.start_btn:
                self.on_start_battle(None)
            elif event.ui_element == self.save_btn:
                self._save_ship()
            elif event.ui_element == self.load_btn:
                self._load_ship()
            elif event.ui_element == self.clear_btn:
                self._show_clear_confirmation()
            elif event.ui_element == self.arc_toggle_btn:
                self.show_firing_arcs = not self.show_firing_arcs
                self.arc_toggle_btn.set_text("Hide Firing Arcs" if self.show_firing_arcs else "Show Firing Arcs")
            elif event.ui_element == self.target_btn:
                self._on_select_target_pressed()
            elif event.ui_element == self.std_data_btn:
                self._load_standard_data()
            elif event.ui_element == self.test_data_btn:
                self._load_test_data()
            elif event.ui_element == self.select_data_btn:
                self._on_select_data_pressed()
            elif event.ui_element == self.verbose_btn:
                 self.weapons_report_panel.verbose_tooltip = not self.weapons_report_panel.verbose_tooltip
            elif event.ui_element == self.detail_panel.details_btn:
                self.detail_panel.show_details_popup()
                 
        elif event.type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:
            if event.ui_element == self.right_panel.class_dropdown:
                new_class = event.text
                if new_class == self.ship.ship_class: return
                
                self.pending_action = ('change_class', new_class)
                
                # Check if ship has components
                has_components = sum(len(l['components']) for l in self.ship.layers.values()) > 0
                
                if has_components:
                    msg = f"Change class to {new_class}?<br><br>Warning: This will attempt to refit existing components.<br>Some items may be resized or lost if they don't fit."
                    self.confirm_dialog = UIConfirmationDialog(pygame.Rect((self.width-600)//2, (self.height-400)//2, 600, 400),
                                                               manager=self.ui_manager,
                                                               action_long_desc=msg,
                                                               window_title="Confirm Refit")
                else:
                    self._execute_pending_action()
                                                          
            elif hasattr(self, 'right_panel') and hasattr(self.right_panel, 'vehicle_type_dropdown') and event.ui_element == self.right_panel.vehicle_type_dropdown:
                new_type = event.text
                if new_type == getattr(self.ship, 'vehicle_type', "Ship"): return
                
                # Determine default class for this type
                classes = get_vehicle_classes()
                valid_classes = [(n, classes[n].get('max_mass', 0)) for n, c in classes.items() if c.get('type', 'Ship') == new_type]
                valid_classes.sort(key=lambda x: x[1])
                target_class = valid_classes[0][0] if valid_classes else "Escort"
                
                self.pending_action = ('change_type', target_class)
                
                # Check if ship has components
                has_components = sum(len(l['components']) for l in self.ship.layers.values()) > 0
                
                if has_components:
                    msg = f"Change type to {new_type}?<br><br><b>WARNING: This will CLEAR the current design.</b>"
                    self.confirm_dialog = UIConfirmationDialog(pygame.Rect((self.width-400)//2, (self.height-200)//2, 400, 200),
                                                              manager=self.ui_manager,
                                                              action_long_desc=msg,
                                                              window_title="Confirm Type Change")
                else:
                    self._execute_pending_action()

            elif hasattr(self.right_panel, 'theme_dropdown') and event.ui_element == self.right_panel.theme_dropdown:
                self.ship.theme_id = event.text
                self.right_panel.update_portrait_image()
                logger.info(f"Changed theme to {event.text}")
            elif event.ui_element == self.right_panel.ai_dropdown:
                from game.ai.controller import STRATEGY_MANAGER
                selected_name = event.text
                if STRATEGY_MANAGER:
                    for strategy_id, strat in STRATEGY_MANAGER.strategies.items():
                        if strat.get('name', '') == selected_name:
                            self.ship.ai_strategy = strategy_id
                            break
                    else:
                        self.ship.ai_strategy = event.text.lower().replace(' ', '_')
                    
        elif event.type == pygame_gui.UI_CONFIRMATION_DIALOG_CONFIRMED:
            if event.ui_element == self.confirm_dialog:
                self._execute_pending_action()
                
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
            for preset_name, btn in getattr(self, 'preset_buttons', []):
                if btn.rect.collidepoint(event.pos):
                    self.preset_manager.delete_preset(preset_name)
                    self.left_panel.rebuild_modifier_ui()
                    logger.info(f"Deleted preset: {preset_name}")
                    break

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_F12:
                # Full screenshot
                self.screenshot_manager.capture(label="full_window")
            elif event.key == pygame.K_F11:
                # Focused screenshot centered on mouse
                mx, my = pygame.mouse.get_pos()
                size = 1024
                # Create rect entered on mouse
                rect = pygame.Rect(0, 0, size, size)
                rect.center = (mx, my)
                self.screenshot_manager.capture(region=rect, label="mouse_focus")
            elif event.key == pygame.K_F10:
                # Debug Sequence Trigger
                self._debug_sequence_capture()

    def _execute_pending_action(self):
        """Execute the action stored in self.pending_action."""
        if hasattr(self, 'pending_action') and self.pending_action:
            act, data = self.pending_action
            if act == 'clear_design':
                self._clear_design()
            elif act == 'change_class':
                # Refit
                self.ship.change_class(data, migrate_components=True)
                self.update_stats()
                self.right_panel.update_portrait_image()
                self.left_panel.update_component_list()
            elif act == 'change_type':
                # Clear and Change
                self.ship.change_class(data, migrate_components=False)
                
                # We also need to update the Class Dropdown options
                classes = get_vehicle_classes()
                new_type = classes[data].get('type', 'Ship')
                valid_classes = [(n, classes[n].get('max_mass', 0)) for n, c in classes.items() if c.get('type', 'Ship') == new_type]
                valid_classes.sort(key=lambda x: x[1])
                valid_class_names = [n for n, m in valid_classes]
                if not valid_class_names: valid_class_names = ["Escort"]
                
                self.right_panel.class_dropdown.kill()
                self.right_panel.class_dropdown = UIDropDownMenu(valid_class_names, data, 
                                                   pygame.Rect(70, self.right_panel.class_dropdown.relative_rect.y, 195, 30), 
                                                   manager=self.ui_manager, container=self.right_panel.panel)
                
                self.update_stats()
                self.right_panel.update_portrait_image()
                self.left_panel.update_component_list()
            
            self.pending_action = None
        else:
            # Fallback for simple clear if pending_action not set
            self._clear_design()

    def _debug_sequence_capture(self):
        """test sequence capture for draw order debugging."""
        logger.info("Starting debug sequence capture...")
        # Note: In a real scenario, this would likely be hooked into the draw loop 
        # or a specific event. For this test, we will simulate a multi-step capture 
        # by manually capturing the current state with different labels, 
        # implying we would call this between draw calls.
        
        # 1. Capture "Start"
        self.screenshot_manager.capture_step("1_start_sequence")
        
        # 2. Simulate "Draw Background" (just capturing same frame for test)
        self.screenshot_manager.capture_step("2_draw_background")
        
        # 3. Simulate "Draw Ships"
        self.screenshot_manager.capture_step("3_draw_ships")
        
        # 4. Simulate "Draw UI"
        self.screenshot_manager.capture_step("4_draw_ui")
        
        logger.info("Debug sequence capture complete.")


    def update(self, dt):
        if self.error_timer > 0:
            self.error_timer -= dt
            
        self.left_panel.update(dt)
        self.layer_panel.update(dt)
        if hasattr(self.modifier_panel, 'update'):
            self.modifier_panel.update(dt)
            
        self.weapons_report_panel.update()
        self.controller.update()

        # Update Detail Panel
        target_comp = None
        if self.controller.selected_component:
            target_comp = self.controller.selected_component[2]
        else:
            # Check schematic hover
            if self.controller.hovered_component:
                target_comp = self.controller.hovered_component
            else:
                 # Check left panel hover
                 mx, my = pygame.mouse.get_pos()
                 hovered_item = self.left_panel.get_hovered_list_item(mx, my)
                 if hovered_item:
                     # Create preview with current template modifiers
                     comp_template = hovered_item.component
                     preview_comp = comp_template.clone()
                     for m_id, val in self.template_modifiers.items():
                        mods = get_modifier_registry()
                        if m_id in mods:
                            mod_def = mods[m_id]
                            if mod_def.restrictions and 'allow_types' in mod_def.restrictions and preview_comp.type_str not in mod_def.restrictions['allow_types']:
                                continue
                            preview_comp.add_modifier(m_id)
                            m = preview_comp.get_modifier(m_id)
                            if m: m.value = val
                     preview_comp.recalculate_stats()
                     target_comp = preview_comp
        
        self.detail_panel.show_component(target_comp)
        self.ui_manager.update(dt)
        
        # Check name entry
        if self.right_panel.name_entry.get_text() != self.ship.name:
            self.ship.name = self.right_panel.name_entry.get_text()

    def draw(self, screen):
        screen.fill(BG_COLOR)
        
        # Determine efficient hover
        hovered = self.controller.hovered_component
        if not hovered:
             mx, my = pygame.mouse.get_pos()
             if not self.view.rect.collidepoint(mx, my):
                 hovered_item = self.left_panel.get_hovered_list_item(mx, my)
                 if hovered_item:
                     comp_template = hovered_item.component
                     preview_comp = comp_template.clone()
                     for m_id, val in self.template_modifiers.items():
                        mods = get_modifier_registry()
                        if m_id in mods:
                            mod_def = mods[m_id]
                            if mod_def.restrictions and 'allow_types' in mod_def.restrictions and preview_comp.type_str not in mod_def.restrictions['allow_types']:
                                continue
                            preview_comp.add_modifier(m_id)
                            m = preview_comp.get_modifier(m_id)
                            if m: m.value = val
                     preview_comp.recalculate_stats()
                     hovered = preview_comp
        
        # Also check if hovering a weapon in the weapons report panel
        if not hovered and hasattr(self, 'weapons_report_panel'):
            if self.weapons_report_panel.hovered_weapon:
                hovered = self.weapons_report_panel.hovered_weapon
                     
        self.view.draw(screen, self.ship, self.show_firing_arcs, self.controller.selected_component, hovered)
        
        self.ui_manager.draw_ui(screen)
        self.left_panel.draw(screen)  # Draw hover highlights AFTER UI manager
        # Layer panel drawing removed (it's handled by UI manager + overlay highlights handled by panel.draw if any)
        self.layer_panel.draw(screen)  # Draw selection highlights AFTER UI manager
        self.weapons_report_panel.draw(screen)
        
        if hovered and not self.controller.dragged_item:
            # Tooltip removed
            pass
            
        if self.controller.dragged_item:
            mx, my = pygame.mouse.get_pos()
            sprite = self.sprite_mgr.get_sprite(self.controller.dragged_item.sprite_index)
            if sprite:
                screen.blit(sprite, (mx - 16, my - 16))
                
        if self.error_timer > 0:
            font = pygame.font.SysFont("Arial", 18)
            err_surf = font.render(self.error_message, True, COLORS['text_error'])
            x = (self.width - err_surf.get_width()) // 2
            screen.blit(err_surf, (x, 50))

    def _on_select_data_pressed(self):
        """Open dialog to select a data directory and reload game data."""
        if not tk_root:
            self.show_error("Tkinter not initialized, cannot open dialog")
            return
            
        initial_dir = os.path.join(os.getcwd(), "data")
        directory = filedialog.askdirectory(
            initialdir=initial_dir,
            title="Select Data Directory"
        )
        
        if directory:
            with profile_block(f"Builder: Reload Data from {os.path.basename(directory)}"):
                self._reload_data(directory)

    def _load_standard_data(self):
        """Load standard data from 'data/' directory and set ship directory to 'ships/'."""
        with profile_block("Builder: Load Standard Data"):
            directory = os.path.join(os.getcwd(), "data")
            self._reload_data(directory)
            ShipIO.default_ships_folder = "ships"
            self.show_error("Loaded Standard Data • Ships: ships/")

    def _load_test_data(self):
        """Load test data from 'tests/data/' directory and set ship directory to 'tests/data/ships/'."""
        with profile_block("Builder: Load Test Data"):
            directory = os.path.join(os.getcwd(), "tests", "data")
            self._reload_data(directory)
            ShipIO.default_ships_folder = os.path.join("tests", "data", "ships")
            self.show_error("Loaded Test Data • Ships: tests/data/ships/")

    def _reload_data(self, directory: str):
        """Reload global game data from the specified directory."""
        from game.simulation.components.component import load_components, load_modifiers
        from game.simulation.entities.ship import load_vehicle_classes
        
        try:
            # 1. Clear Registries
            from game.ai.controller import STRATEGY_MANAGER, load_combat_strategies
            
            RegistryManager.instance().clear()
            # Clear STRATEGY_MANAGER data
            if STRATEGY_MANAGER:
                STRATEGY_MANAGER.strategies.clear()
                STRATEGY_MANAGER.targeting_policies.clear()
                STRATEGY_MANAGER.movement_policies.clear()
            
            # 2. Helper to find file (standard, test prefix, or alias) -> returns (path, is_default_fallback)
            def find_file(base_names, allow_default=True):
                if isinstance(base_names, str): base_names = [base_names]
                
                # 1. Custom Directory Support
                for name in base_names:
                    # Direct match
                    p = os.path.join(directory, name)
                    if os.path.exists(p): return p, False
                    
                    # Test prefix match
                    p = os.path.join(directory, "test_" + name)
                    if os.path.exists(p): return p, False
                
                # 2. Default Fallback
                if allow_default:
                     default_dir = os.path.join(os.getcwd(), "data")
                     for name in base_names:
                         p = os.path.join(default_dir, name)
                         if os.path.exists(p): return p, True
                
                return None, False
            
            # 3. Load Data
            
            # Modifiers
            mod_path, _ = find_file("modifiers.json")
            if mod_path:
                load_modifiers(mod_path)
                logger.info(f"Loaded modifiers from {mod_path}")
            else:
                logger.warning("No modifiers.json found")

            # Components
            comp_path, _ = find_file("components.json")
            if comp_path:
                load_components(comp_path)
                logger.info(f"Loaded components from {comp_path}")
            else:
                logger.warning("No components.json found")
                
            # Combat Strategies - Need to load all three files
            # Check if test files exist (with test_ prefix)
            test_strat = os.path.join(directory, "test_combat_strategies.json")
            test_targeting = os.path.join(directory, "test_targeting_policies.json")
            test_movement = os.path.join(directory, "test_movement_policies.json")
            
            if os.path.exists(test_strat):
                # Test data mode - use test_ prefixed files
                if STRATEGY_MANAGER:
                    STRATEGY_MANAGER.load_data(
                        directory,
                        targeting_file="test_targeting_policies.json",
                        movement_file="test_movement_policies.json",
                        strategy_file="test_combat_strategies.json"
                    )
                logger.info(f"Loaded strategies from test data in {directory}")
            else:
                # Production mode - try standard names
                strat_path, is_def = find_file(["combatstrategies.json", "combat_strategies.json"])
                if strat_path:
                    load_combat_strategies(strat_path)
                    logger.info(f"Loaded strategies from {strat_path}")
            
            # Vehicle Classes & Layers
            # Check for 'vehicleclasses.json' OR 'classes.json'
            vclass_path, _ = find_file(["vehicleclasses.json", "classes.json"])
            vlayer_path, _ = find_file(["vehiclelayers.json", "layers.json"])
            
            if vclass_path:
                if vlayer_path:
                     load_vehicle_classes(vclass_path, layers_filepath=vlayer_path)
                     logger.info(f"Loaded classes from {vclass_path} with layers from {vlayer_path}")
                else:
                     load_vehicle_classes(vclass_path)
                     logger.info(f"Loaded classes from {vclass_path}")
            else:
                # If checking tests/data failed, try global default explicitly if not already tried?
                # find_file with allow_default=True should have caught it.
                logger.warning("No vehicleclasses.json found")

            # 4. Refresh UI
            self.right_panel.refresh_controls()
            self.left_panel.update_component_list()
            self.rebuild_modifier_ui()
            
            self.show_error("Data Reloaded Successfully!")
            
            # 5. Refresh Builder State
            self.available_components = get_all_components()
            self.template_modifiers = {}
            
            # Reset Ship
            # Find a valid default class
            default_class = "Escort"
            classes = get_vehicle_classes()
            if default_class not in classes and classes:
                # Pick first available
                default_class = next(iter(classes.keys()))
                
            self.ship = Ship("Custom Ship", self.width // 2, self.height // 2, (100, 100, 255), ship_class=default_class)
            self.ship.recalculate_stats()
            
            # Reset UI Panels
            # Left Panel needs to rebuild list
            self.left_panel.update_component_list()
            
            # Center View
            self.view.selected_component = None
            self.controller.selected_component = None
            self.selected_components = []
            
            # Right Panel needs to refresh dropdowns
            # We need to recreate the class dropdown or update its items
            # Accessing right_panel internals (tight coupling, but needed for quick fix)
            
            # Update Class Dropdown
            classes = get_vehicle_classes()
            valid_classes = [(n, classes[n].get('max_mass', 0)) for n, c in classes.items()]
            valid_classes.sort(key=lambda x: x[1])
            valid_class_names = [n for n, m in valid_classes]
            if not valid_class_names: valid_class_names = ["Escort"]
            
            if hasattr(self.right_panel, 'class_dropdown'):
                self.right_panel.class_dropdown.kill()
                self.right_panel.class_dropdown = UIDropDownMenu(
                    valid_class_names, 
                    default_class,
                    pygame.Rect(70, self.right_panel.class_dropdown.relative_rect.y, 195, 30), 
                    manager=self.ui_manager, 
                    container=self.right_panel.panel
                )
                
            # Update Type Dropdown if it exists
            if hasattr(self.right_panel, 'vehicle_type_dropdown'):
                classes = get_vehicle_classes()
                types = sorted(list(set(c.get('type', 'Ship') for c in classes.values())))
                if not types: types = ["Ship"]
                default_type = classes[default_class].get('type', 'Ship')
                
                self.right_panel.vehicle_type_dropdown.kill()
                self.right_panel.vehicle_type_dropdown = UIDropDownMenu(
                     types,
                     default_type,
                     pygame.Rect(70, self.right_panel.vehicle_type_dropdown.relative_rect.y, 195, 30),
                     manager=self.ui_manager,
                     container=self.right_panel.panel
                )
            
            self.update_stats()
            self.rebuild_modifier_ui()
            
            # Emit registry reload event for decoupled UI sync
            self.event_bus.emit(BuilderEvents.REGISTRY_RELOADED, None)
            
            # Show success
            self.show_error(f"Reloaded data from {os.path.basename(directory)}")
            
        except Exception as e:
            logger.error(f"Failed to reload data: {e}")
            import traceback
            traceback.print_exc()
            self.show_error(f"Error reloading data: {e}")
            
    
    # Tooltip method removed

    @profile_action("Builder: Save Ship")
    def _save_ship(self):
        success, message = ShipIO.save_ship(self.ship)
        if success: print(message)
        elif message: self.show_error(message)

    @profile_action("Builder: Load Ship")
    def _load_ship(self):
        new_ship, message = ShipIO.load_ship(self.width, self.height)
        if new_ship:
            self.ship = new_ship
            # Fully refresh UI controls to match new ship state
            self.right_panel.refresh_controls()
            
            self.update_stats()
            # Also update the layers panel in case components changed
            self.layer_panel.rebuild()
            self.left_panel.update_component_list() # Update available components based on hull type
            self.rebuild_modifier_ui()
            print(message)
        elif message:
            self.show_error(message)

    def _show_clear_confirmation(self):
        self.pending_action = ('clear_design', None)
        self.confirm_dialog = UIConfirmationDialog(
            rect=pygame.Rect((self.width // 2 - 150, self.height // 2 - 100), (300, 200)),
            action_long_desc="Clear all components and reset to default settings?",
            manager=self.ui_manager,
            window_title="Confirm Clear"
        )

    def _clear_design(self):
        logger.info("Clearing ship design")
        for layer_type, layer_data in self.ship.layers.items():
            layer_data['components'] = []
            layer_data['hp_pool'] = 0
            layer_data['max_hp_pool'] = 0
            layer_data['mass'] = 0
            layer_data['hp'] = 0
            
        self.template_modifiers = {}
        self.ship.ai_strategy = "standard_ranged"
        
        # Reset Name
        self.ship.name = "Custom Ship"
        
        self.ship.recalculate_stats()
        
        # Refresh UI
        self.right_panel.refresh_controls()
        self.update_stats()
        self.rebuild_modifier_ui()
        self.controller.selected_component = None
        self.on_selection_changed(None)
        
        if hasattr(self, 'weapons_report_panel'):
            self.weapons_report_panel.clear_target()

    def _on_select_target_pressed(self):
        target_ship, message = ShipIO.load_ship(self.width, self.height)
        if target_ship:
            self.weapons_report_panel.set_target(target_ship)
            logger.info(f"Selected target: {target_ship.name}")
        elif message and "Cancelled" not in message:
            self.show_error(message)


--- END FILE: game/ui/screens/builder_screen.py ---

--- START FILE: ui/builder/right_panel.py ---
import pygame
import pygame_gui
from pygame_gui.elements import UIPanel, UILabel, UITextEntryLine, UIDropDownMenu, UITextBox, UIImage
from pygame_gui.core import UIElement

from game.core.registry import RegistryManager
from game.ai.controller import STRATEGY_MANAGER

class StatRow:
    """Helper class to manage a single statistic row (Label | Value | Unit) with caching."""
    def __init__(self, key, label_text, manager, container, x, y, width):
        self.key = key
        # Layout: Label 50%, Value 30%, Unit 20%
        lbl_w = int(width * 0.50)
        val_w = int(width * 0.30)
        unit_w = width - lbl_w - val_w
        
        self.label = UILabel(pygame.Rect(x, y, lbl_w, 20), f"{label_text}:", 
                           manager=manager, container=container, object_id="#stat_label")
        self.value = UILabel(pygame.Rect(x + lbl_w, y, val_w, 20), "--", 
                           manager=manager, container=container, object_id="#stat_value")
        self.unit = UILabel(pygame.Rect(x + lbl_w + val_w, y, unit_w, 20), "", 
                          manager=manager, container=container, object_id="#stat_unit")
        
        self._last_val = None
        self._last_unit = None
        self._visible = True

    def update(self, val_text, unit_text=""):
        if self._last_val != val_text:
            self.value.set_text(val_text)
            self._last_val = val_text
            
        if self._last_unit != unit_text:
            self.unit.set_text(unit_text)
            self._last_unit = unit_text

    def set_visible(self, visible):
        if self._visible == visible:
            return
            
        if visible:
            self.label.show()
            self.value.show()
            self.unit.show()
        else:
            self.label.hide()
            self.value.hide()
            self.unit.hide()
        self._visible = visible

class BuilderRightPanel:
    def __init__(self, builder, manager, rect, event_bus=None):
        self.builder = builder
        self.manager = manager
        self.rect = rect
        self.event_bus = event_bus
        
        if event_bus:
            event_bus.subscribe("SHIP_UPDATED", self.on_ship_updated)
            event_bus.subscribe("REGISTRY_RELOADED", self.on_registry_reloaded)
        
        self.panel = UIPanel(
            relative_rect=rect,
            manager=manager,
            object_id='#right_panel'
        )
        
        self.setup_controls()
        self.setup_stats()
        
    def on_registry_reloaded(self, data):
        """Handle registry reload event - refresh all controls with new data."""
        self.refresh_controls()

    def on_ship_updated(self, ship):
        # Check if resource keys match our current rows
        # If mismatch, we must rebuild the layout to add/remove rows
        from ui.builder.stats_config import get_logistics_rows
        
        current_keys = set(self.rows_map.keys())
        
        # Calculate expected keys for dynamic section
        new_log_rows = get_logistics_rows(ship)
        new_log_keys = set(r.key for r in new_log_rows)
        
        # We need to know if the SET of keys in new_log_rows differs from what we HAVE for logistics.
        # But self.rows_map contains ALL rows (Main, Shield, etc).
        # We can check if all new_log_keys are present in current_keys.
        # AND if we have any "stale" keys that are arguably logistics keys?
        # Simpler: If any new key is missing -> REBUILD
        
        missing_keys = new_log_keys - current_keys
        if missing_keys:
             self.rebuild_stats()
             # Fall through to update

        # Also check if any EXISTING key that looks like a resource key is NO LONGER valid?
        # E.g. removed 'Biomass'.
        # This is harder without knowing which keys are logistics.
        # But generally, adding components is the main builder action. Removing implies set subtraction.
        # Using self.logistics_keys stored in setup_stats would be better.
        
        elif hasattr(self, 'current_logistics_keys'):
            if new_log_keys != self.current_logistics_keys:
                 self.rebuild_stats()
                 # Fall through to update

        self.update_stats_display(ship)

    def setup_controls(self):
        y = 10
        width = self.rect.width
        col_w = width - 20
        
        # Name
        UILabel(pygame.Rect(10, y, 60, 25), "Name:", manager=self.manager, container=self.panel)
        self.name_entry = UITextEntryLine(pygame.Rect(70, y, 195, 30), manager=self.manager, container=self.panel)
        self.name_entry.set_text(self.builder.ship.name)
        y += 40
        
        # Theme
        UILabel(pygame.Rect(10, y, 60, 25), "Theme:", manager=self.manager, container=self.panel)
        theme_options = self.builder.theme_manager.get_available_themes()
        curr_theme = getattr(self.builder.ship, 'theme_id', 'Federation')
        if theme_options and curr_theme not in theme_options: curr_theme = theme_options[0]
        
        self.theme_dropdown = UIDropDownMenu(theme_options, curr_theme, pygame.Rect(70, y, 195, 30), manager=self.manager, container=self.panel)
        y += 40
        
        # Vehicle Type
        UILabel(pygame.Rect(10, y, 60, 25), "Type:", manager=self.manager, container=self.panel)
        # Get unique types
        types = sorted(list(set(c.get('type', 'Ship') for c in RegistryManager.instance().vehicle_classes.values())))
        if not types: types = ["Ship"]
        
        curr_type = getattr(self.builder.ship, 'vehicle_type', "Ship")
        if curr_type not in types: curr_type = types[0]
        
        self.vehicle_type_dropdown = UIDropDownMenu(types, curr_type, pygame.Rect(70, y, 195, 30), manager=self.manager, container=self.panel)
        y += 40

        # Class
        UILabel(pygame.Rect(10, y, 60, 25), "Class:", manager=self.manager, container=self.panel)
        # Filter classes by current type and sort by max_mass (smallest to largest)
        class_options = [(name, cls.get('max_mass', 0)) for name, cls in RegistryManager.instance().vehicle_classes.items() if cls.get('type', 'Ship') == curr_type]
        class_options.sort(key=lambda x: x[1])  # Sort by max_mass
        class_options = [name for name, _ in class_options]  # Extract just names
        if not class_options: class_options = ["Escort"]

        curr_class = self.builder.ship.ship_class
        if curr_class not in class_options: curr_class = class_options[0]
        
        self.class_dropdown = UIDropDownMenu(class_options, curr_class, pygame.Rect(70, y, 195, 30), manager=self.manager, container=self.panel)
        y += 40
        
        # AI
        UILabel(pygame.Rect(10, y, 60, 25), "AI:", manager=self.manager, container=self.panel)
        
        strategies = STRATEGY_MANAGER.strategies if STRATEGY_MANAGER else {}
        ai_options = [strat.get('name', sid.replace('_', ' ').title()) for sid, strat in strategies.items()]
        
        # Ensure we have at least one option
        if not ai_options:
            ai_options = ['Standard Ranged']
        
        # Find display name for ship's current strategy
        ai_display = None
        for sid, strat in strategies.items():
            if sid == self.builder.ship.ai_strategy:
                ai_display = strat.get('name', sid.replace('_', ' ').title())
                break
        
        # Fallback to first option if ship's strategy is not in new data-driven system
        if ai_display is None or ai_display not in ai_options:
            ai_display = ai_options[0]
                
        self.ai_dropdown = UIDropDownMenu(ai_options, ai_display, pygame.Rect(70, y, 195, 30), manager=self.manager, container=self.panel)
        
        # Portrait Image (Side by Side)
        self.portrait_image = None
        img_x = 280
        img_size = 200 # Approx match height of 5 rows (200px)
        self.portrait_rect = pygame.Rect(img_x, 10, img_size, img_size) # Fixed slot
        
        self.update_portrait_image()
        
        y += 40 # Ends at 210
        self.last_y = max(y, 10 + img_size) + 10

    def refresh_controls(self):
        """Update all UI controls to match the current ship state."""
        import pygame
        from pygame_gui.elements import UIDropDownMenu
        
        s = self.builder.ship
        
        # 1. Name
        self.name_entry.set_text(s.name)
        
        # Preservation of Rects
        theme_rect = self.theme_dropdown.relative_rect
        type_rect = self.vehicle_type_dropdown.relative_rect
        class_rect = self.class_dropdown.relative_rect
        ai_rect = self.ai_dropdown.relative_rect
        
        # Kill old dropdowns
        self.theme_dropdown.kill()
        self.vehicle_type_dropdown.kill()
        self.class_dropdown.kill()
        self.ai_dropdown.kill()
        
        # 2. Recreate Theme
        theme_options = self.builder.theme_manager.get_available_themes()
        curr_theme = getattr(s, 'theme_id', 'Federation')
        if theme_options and curr_theme not in theme_options: curr_theme = theme_options[0]
        
        self.theme_dropdown = UIDropDownMenu(theme_options, curr_theme, theme_rect, manager=self.manager, container=self.panel)
        
        # 3. Recreate Type
        # Get unique types
        types = sorted(list(set(c.get('type', 'Ship') for c in RegistryManager.instance().vehicle_classes.values())))
        if not types: types = ["Ship"]
        
        curr_type = getattr(s, 'vehicle_type', "Ship")
        # Ensure consistency from class if vehicle_type not set or mismatched
        class_def = RegistryManager.instance().vehicle_classes.get(s.ship_class, {})
        if class_def:
             curr_type = class_def.get('type', curr_type)
        
        if curr_type not in types: curr_type = types[0]
        
        self.vehicle_type_dropdown = UIDropDownMenu(types, curr_type, type_rect, manager=self.manager, container=self.panel)
        
        # 4. Recreate Class
        class_options = [(name, cls.get('max_mass', 0)) for name, cls in RegistryManager.instance().vehicle_classes.items() if cls.get('type', 'Ship') == curr_type]
        class_options.sort(key=lambda x: x[1])  # Sort by max_mass
        class_options = [name for name, _ in class_options]  # Extract just names
        if not class_options: class_options = ["Escort"]

        curr_class = s.ship_class
        if curr_class not in class_options: 
            if curr_class in RegistryManager.instance().vehicle_classes: 
                 curr_class = class_options[0]
        
        self.class_dropdown = UIDropDownMenu(class_options, curr_class, class_rect, manager=self.manager, container=self.panel)
        
        # 5. Recreate AI
        strategies = STRATEGY_MANAGER.strategies if STRATEGY_MANAGER else {}
        ai_options = [strat.get('name', sid.replace('_', ' ').title()) for sid, strat in strategies.items()]
        
        # Ensure we have at least one option
        if not ai_options:
            ai_options = ['Standard Ranged']
        
        # Find display name for ship's current strategy
        ai_display = None
        for sid, strat in strategies.items():
            if sid == s.ai_strategy:
                ai_display = strat.get('name', sid.replace('_', ' ').title())
                break
        
        # Fallback to first option if ship's strategy is not in new data-driven system
        if ai_display is None or ai_display not in ai_options:
            ai_display = ai_options[0]
                
        self.ai_dropdown = UIDropDownMenu(ai_options, ai_display, ai_rect, manager=self.manager, container=self.panel)

        # 6. Update Portrait
        self.update_portrait_image()

        # 7. Rebuild Stats (Logic might satisfy dynamic resources)
        self.rebuild_stats()


    def update_portrait_image(self):
        """Update the ship portrait based on current theme and class."""
        import os
        import re
        
        # Determine paths
        theme = getattr(self.builder.ship, 'theme_id', 'Federation')
        ship_class = self.builder.ship.ship_class
        
        match = re.match(r"(.*)\s+\((.*)\)", ship_class)
        if match:
             base = match.group(1).strip().replace(" ", "")
             sub = match.group(2).strip().replace(" ", "")
             class_clean = f"{sub}{base}"
        else:
             class_clean = ship_class.replace(" ", "")

        filename = f"{class_clean}_Portrait.jpg"
        
        base_path = "resources/Portraits"
        # We need absolute path or relative to CWD
        full_path = os.path.join(base_path, theme, filename)
        
        # Check for new location: assets/ShipThemes/{theme}/Portraits
        new_loc = os.path.join("assets", "ShipThemes", theme, "Portraits", filename)
        if os.path.exists(new_loc):
            full_path = new_loc
            
        if not os.path.exists(full_path):
            # Try with spaces?
            full_path_space = os.path.join(base_path, theme, f"{ship_class}_Portrait.jpg")
            if os.path.exists(full_path_space):
                full_path = full_path_space
            else:
                 # Fallback to Default Portrait
                 default_path = os.path.join("assets", "Images", "Default_Ship_Portrait.png")
                 if os.path.exists(default_path):
                     full_path = default_path
                 else:
                     if self.portrait_image:
                         self.portrait_image.kill()
                         self.portrait_image = None
                     return

        try:
            image_surf = pygame.image.load(full_path).convert_alpha()
            
            # Scale to fit width, maintaining aspect
            max_w = self.portrait_rect.width
            max_h = self.portrait_rect.height
            
            img_w, img_h = image_surf.get_size()
            scale = min(max_w / img_w, max_h / img_h)
            
            if scale < 1.0:
                new_w = int(img_w * scale)
                new_h = int(img_h * scale)
                image_surf = pygame.transform.smoothscale(image_surf, (new_w, new_h))
            
            # Center it
            final_w, final_h = image_surf.get_size()
            center_x = self.portrait_rect.x + (max_w - final_w) // 2
            center_y = self.portrait_rect.y + (max_h - final_h) // 2
            
            # Update rect to centered position
            display_rect = pygame.Rect(center_x, center_y, final_w, final_h)
            
            if self.portrait_image:
                self.portrait_image.kill()
                
            self.portrait_image = UIImage(
                relative_rect=display_rect,
                image_surface=image_surf,
                manager=self.manager,
                container=self.panel
            )
            
        except Exception as e:
            print(f"Failed to load portrait {full_path}: {e}")

    def setup_stats(self):
        # Create Scroll Container for Stats
        # Starts after controls (last_y) and takes remaining height
        
        # Calculate available height
        y = self.last_y
        total_h = self.rect.height - y - 10
        if total_h < 100: total_h = 100
        
        self.stats_scroll = pygame_gui.elements.UIScrollingContainer(
            relative_rect=pygame.Rect(0, y, self.rect.width, total_h),
            manager=self.manager,
            container=self.panel,
            anchors={'left': 'left', 'right': 'right', 'top': 'top', 'bottom': 'bottom'}
        )
        
        # We need a container for the scrolling content (inner)
        # However, UIScrollingContainer acts as the container source. 
        # Elements should be parented to self.stats_scroll
        
        # Columns
        # Width available inside scrollbar (assume 20px scrollbar)
        list_w = self.stats_scroll.get_container().get_rect().width
        full_w = list_w
        
        col_gap = 10
        margin = 10
        avail_w = full_w - (2 * margin) - col_gap
        col_w = avail_w // 2
        
        col1_x = margin
        col2_x = margin + col_w + col_gap
        
        # Start Y inside container (0-indexed)
        y = 10 
        start_y = y
        
        self.rows_map = {} # Store StatRow instances by key
        
        # === Generic Helper to Build Section ===
        def build_section(title, stats_list, x, start_y):
            curr_y = start_y
            UILabel(pygame.Rect(x, curr_y, col_w, 25), f"── {title} ──", manager=self.manager, container=self.stats_scroll)
            curr_y += 30
            
            for stat_def in stats_list:
                row = StatRow(stat_def.key, stat_def.label, self.manager, self.stats_scroll, x, curr_y, col_w)
                row.definition = stat_def # Attach definition to row for update loop
                self.rows_map[stat_def.key] = row
                curr_y += 20
            
            return curr_y + 10

        from ui.builder.stats_config import STATS_CONFIG, get_logistics_rows

        # FREEZING CONFIG
        self.stats_config = STATS_CONFIG
        
        # === Column 1: Main, Maneuvering, Shields, Armor, Targeting ===
        y = start_y
        
        y = build_section("Main Systems", self.stats_config.get('main', []), col1_x, y)
        y = build_section("Maneuvering", self.stats_config.get('maneuvering', []), col1_x, y)
        y = build_section("Shields", self.stats_config.get('shields', []), col1_x, y)
        
        # Armor
        y = build_section("Armor", self.stats_config.get('armor', []), col1_x, y)
        
        # Layers (Special Case: Dynamic) - Inserted under Armor
        
        # -- Added Header "Layers" --
        UILabel(pygame.Rect(col1_x, y, col_w, 20), "Layers", manager=self.manager, container=self.stats_scroll)
        y += 20
        # ---------------------------
        
        self.layer_rows = []
        for i in range(4):
            sr = StatRow(f"layer_{i}", f"Slot {i}", self.manager, self.stats_scroll, col1_x, y, col_w)
            sr.set_visible(False)
            self.layer_rows.append(sr)
            y += 22
        y += 10
        
        y = build_section("Targeting", self.stats_config.get('targeting', []), col1_x, y)
        col1_max_y = y
        
        # === Column 2: Logistics, Crew, Fighter ===
        y = start_y
        
        # Helper for Dynamic Logistics
        log_rows = get_logistics_rows(self.builder.ship)
        
        # Store keys for dirty checking later
        self.current_logistics_keys = set(r.key for r in log_rows)
        
        y = build_section("Logistics", log_rows, col2_x, y)

        y = build_section("Crew Logistics", self.stats_config.get('crewlogistics', []), col2_x, y)
        y = build_section("Fighter Support", self.stats_config.get('fightersupport', []), col2_x, y)
        
        col2_max_y = y
        
        # === Requirements (Bottom, Split) ===
        y = max(col1_max_y, col2_max_y) + 10
        
        # Split Headers
        UILabel(pygame.Rect(col1_x, y, col_w, 20), "── Requirements ──", manager=self.manager, container=self.stats_scroll)
        UILabel(pygame.Rect(col2_x, y, col_w, 20), "── Recommendations ──", manager=self.manager, container=self.stats_scroll)
        y += 25
        
        # Box heights (enough for content, not fixed to panel bottom anymore)
        rem_h = 200 # Fixed reasonable height inside scroll
        
        self.req_box_left = UITextBox("✓ All requirements met", pygame.Rect(col1_x, y, col_w, rem_h), manager=self.manager, container=self.stats_scroll)
        self.req_box_right = UITextBox("", pygame.Rect(col2_x, y, col_w, rem_h), manager=self.manager, container=self.stats_scroll)

        y += rem_h + 10
        
        # Update Scroll Area
        self.stats_scroll.set_scrollable_area_dimensions((full_w, y))

    def rebuild_stats(self):
        """Completely rebuild the stats scroll container (e.g. after ship load)."""
        if hasattr(self, 'stats_scroll'):
            self.stats_scroll.kill()
        self.setup_stats()

    def update_stats_display(self, s):
        """Update ship stats labels using Data-Driven Config."""
        
        # Iterate over instantiated rows directly
        # This allows us to handle dynamic rows that aren't in the static config
        for key, row in self.rows_map.items():
            if hasattr(row, 'definition'):
                stat_def = row.definition
                val = stat_def.get_value(s)
                
                # Check validation
                is_ok, status_txt = stat_def.get_status(s, val)
                
                fmt_val = stat_def.format_value(val)
                unit_val = stat_def.get_display_unit(s, val)
                
                final_unit = f"{unit_val}"
                if status_txt:
                     final_unit += f" {status_txt}"
                     
                row.update(fmt_val, final_unit)
        
        # Update layer stats (Still somewhat special case due to dynamic list)
        from game.simulation.entities.ship import LayerType
        
        # Hide all first
        for row in self.layer_rows:
            row.set_visible(False)
            
        sorted_layers = sorted(s.layers.items(), key=lambda x: x[0].value) 
        
        slot_idx = 0
        for layer_type, layer_data in sorted_layers:
            if slot_idx < len(self.layer_rows):
                status = s.layer_status.get(layer_type, {})
                ratio = status.get('ratio', 0) * 100
                limit = status.get('limit', 1.0) * 100
                is_ok = status.get('ok', True)
                mass = status.get('mass', 0)
                
                status_icon = "✓" if is_ok else "✗"
                
                row = self.layer_rows[slot_idx]
                
                # Update Label directly since it changes per slot in this dynamic list
                row.label.set_text(f"{layer_type.name}:")
                row.update(f"{ratio:.0f}% / {limit:.0f}%", f" ({mass:.0f}t) {status_icon}")
                
                row.set_visible(True)
                
                slot_idx += 1
        
        # Update requirements (Left)
        missing_reqs = s.get_missing_requirements()
        if not s.mass_limits_ok:
            missing_reqs.append("⚠ Over mass limit")
            
        full_list_req = []
        for req in missing_reqs:
            full_list_req.append(f"<font color='#ffaa55'>{req}</font>")
        
        if not full_list_req:
            html_left = "<font color='#88ff88'>✓ All met</font>"
        else:
            html_left = "<br>".join(full_list_req)
        
        self.req_box_left.html_text = html_left
        self.req_box_left.rebuild()

        # Update warnings (Right)
        warnings = s.get_validation_warnings()
        full_list_warn = []
        for warn in warnings:
            full_list_warn.append(f"<font color='#ffff88'>⚠ {warn}</font>")
            
        if not full_list_warn:
            html_right = "<font color='#888888'>No recommendations</font>"
        else:
            html_right = "<br>".join(full_list_warn)
            
        self.req_box_right.html_text = html_right
        self.req_box_right.rebuild()

--- END FILE: ui/builder/right_panel.py ---

--- START FILE: ui/builder/left_panel.py ---
import pygame
import pygame_gui
from pygame_gui.elements import UIPanel, UILabel, UIScrollingContainer, UIDropDownMenu
from ui.builder.components import ComponentListItem

class BuilderLeftPanel:
    def __init__(self, builder, manager, rect, event_bus=None):
        self.builder = builder
        self.manager = manager
        self.rect = rect
        self.items = []
        self.selected_item = None
        self.event_bus = event_bus
        
        if event_bus:
            event_bus.subscribe("REGISTRY_RELOADED", self.on_registry_reloaded)
        
        # Store original order of components for sorting
        self.component_order_map = {c.id: i for i, c in enumerate(builder.available_components)}
        
        self.panel = UIPanel(
            relative_rect=rect,
            manager=manager,
            object_id='#left_panel'
        )
        
        # Title
        UILabel(
            relative_rect=pygame.Rect(10, 5, 100, 30),
            text="Components",
            manager=manager,
            container=self.panel
        )
        
        # Scroll Container 
        # Shifted down to room for Bulk Add UI
        self.list_y = 125 # Was 80
        self.list_y = 125 # Was 80
        container_height = rect.height - 130 # Full height minus offsets
        self.scroll_container = UIScrollingContainer(
            relative_rect=pygame.Rect(5, self.list_y, rect.width - 10, container_height),
            manager=manager,
            container=self.panel,
            anchors={'left': 'left', 'right': 'right', 'top': 'top', 'bottom': 'top'}
        )
        
        # Bulk Add UI (y=80)
        # Layout: Label "Count:" | Entry | <<< | << | < | Slider | > | >> | >>>
        # Widths: 40 | 45 | 25 | 25 | 25 | Slider | 25 | 25 | 25
        u_y = 80
        
        # Label
        UILabel(pygame.Rect(5, u_y, 45, 25), "Count:", manager=manager, container=self.panel)
        
        from pygame_gui.elements import UITextEntryLine, UIHorizontalSlider, UIButton
        
        # Entry
        self.count_entry = UITextEntryLine(pygame.Rect(50, u_y, 45, 25), manager=manager, container=self.panel)
        self.count_entry.set_text("1")
        self.count_entry.set_allowed_characters('numbers')
        
        btn_w = 30
        gap = 2
        
        # Buttons (All on left now)
        # Sequence: m100, m10, m1, p1, p10, p100
        start_btns = 100
        
        self.btn_m100 = UIButton(pygame.Rect(start_btns, u_y, btn_w, 25), "<<<", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        self.btn_m10  = UIButton(pygame.Rect(start_btns + btn_w + gap, u_y, btn_w, 25), "<<", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        self.btn_m1   = UIButton(pygame.Rect(start_btns + (btn_w + gap)*2, u_y, btn_w, 25), "<", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        
        # Start Positive buttons immediately after
        p_start = start_btns + (btn_w + gap)*3
        
        self.btn_p1   = UIButton(pygame.Rect(p_start, u_y, btn_w, 25), ">", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        self.btn_p10  = UIButton(pygame.Rect(p_start + btn_w + gap, u_y, btn_w, 25), ">>", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        self.btn_p100 = UIButton(pygame.Rect(p_start + (btn_w + gap)*2, u_y, btn_w, 25), ">>>", manager=manager, container=self.panel, object_id='#mini_arrow_btn')
        
        # Slider takes remaining space
        slider_x = p_start + (btn_w + gap)*3 + 5
        slider_w = rect.width - slider_x - 10
        
        self.count_slider = UIHorizontalSlider(pygame.Rect(slider_x, u_y, slider_w, 25), 1, (1, 1000), manager=manager, container=self.panel)
        
        # Row 2 (Removed, single line now)
        u_y += 35
        
        # Remove old button definitions if any references remain (not needed for replace)
        # Update event handler to respect new button names/logic


        # Controls Row 1: Sort
        self.sort_options = [
            "Default (JSON Order)", 
            "Name (A-Z)", 
            "Classification", 
            "Type", 
            "Mass (Low-High)", 
            "Mass (High-Low)"
        ]
        self.current_sort = "Default (JSON Order)"
        self.sort_dropdown = UIDropDownMenu(
            options_list=self.sort_options,
            starting_option=self.current_sort,
            relative_rect=pygame.Rect(rect.width - 160, 5, 150, 30),
            manager=manager,
            container=self.panel
        )
        self.sort_dropdown.change_layer(5) # Ensure above list
        
        # Controls Row 2: Filters
        y_filters = 40
        
        # Filter: Type
        # Gather all types
        all_types = sorted(list(set(c.type_str for c in builder.available_components)))
        self.type_filter_options = ["All Types"] + all_types
        self.current_type_filter = "All Types"
        
        self.filter_type_dropdown = UIDropDownMenu(
            options_list=self.type_filter_options,
            starting_option=self.current_type_filter,
            relative_rect=pygame.Rect(5, y_filters, (rect.width//2)-10, 30),
            manager=manager,
            container=self.panel
        )
        self.filter_type_dropdown.change_layer(5)
        
        # Filter: Layer
        # Initial population - will be updated dynamically
        self.layer_filter_options = ["All Layers"] + [l.name for l in builder.ship.layers.keys()]
        self.current_layer_filter = "All Layers"
        self.filter_layer_dropdown = UIDropDownMenu(
            options_list=self.layer_filter_options,
            starting_option=self.current_layer_filter,
            relative_rect=pygame.Rect((rect.width//2)+5, y_filters, (rect.width//2)-10, 30),
            manager=manager,
            container=self.panel
        )
        self.filter_layer_dropdown.change_layer(5)

        
        # Modifier Panel

    def on_registry_reloaded(self, data):
        """Handle registry reload event - refresh component list and filter options."""
        # Update available components from new registry data
        from game.simulation.components.component import get_all_components
        self.builder.available_components = get_all_components()
        self.component_order_map = {c.id: i for i, c in enumerate(self.builder.available_components)}
        
        # Update type filter options
        all_types = sorted(list(set(c.type_str for c in self.builder.available_components)))
        self.type_filter_options = ["All Types"] + all_types
        if self.current_type_filter not in self.type_filter_options:
            self.current_type_filter = "All Types"
        
        # Rebuild the filter dropdown
        y_filters = 40
        self.filter_type_dropdown.kill()
        self.filter_type_dropdown = UIDropDownMenu(
            options_list=self.type_filter_options,
            starting_option=self.current_type_filter,
            relative_rect=pygame.Rect(5, y_filters, (self.rect.width//2)-10, 30),
            manager=self.manager,
            container=self.panel
        )
        self.filter_type_dropdown.change_layer(5)
        
        # Refresh the component list
        self.update_component_list()
        
    def update(self, dt):
        """Update panel logic."""
        # Check for expanded dropdowns and track which one
        self._dropdown_expanded = False
        self._expanded_dropdown = None
        dropdowns = [self.sort_dropdown, self.filter_type_dropdown, self.filter_layer_dropdown]
        for dd in dropdowns:
             if dd.current_state == dd.menu_states['expanded']:
                 self._dropdown_expanded = True
                 self._expanded_dropdown = dd
                 break
        
        # Hide list and OTHER dropdowns when one dropdown is open
        if self._dropdown_expanded:
             if self.scroll_container.visible:
                 self.scroll_container.hide()
             # Hide the other dropdowns (not the expanded one)
             for dd in dropdowns:
                 if dd != self._expanded_dropdown and dd.visible:
                     dd.hide()
        else:
             if not self.scroll_container.visible:
                 self.scroll_container.show()
             # Show all dropdowns
             for dd in dropdowns:
                 if not dd.visible:
                     dd.show()


        
        # Update hover state for component list items
        mx, my = pygame.mouse.get_pos()
        hovered_item = self.get_hovered_list_item(mx, my)
        for item in self.items:
            # Don't override selected state with hover
            if item != self.selected_item:
                item.set_hovered(item == hovered_item)
                 
    def is_dropdown_expanded(self):
        """Check if any filter/sort dropdown is currently expanded."""
        return getattr(self, '_dropdown_expanded', False)
        
    def get_hovered_list_item(self, mx, my):
        """
        Returns the ComponentListItem that the mouse is hovering over, if any.
        Returns None if mouse is not over an item or if a dropdown is expanded.
        """
        if self.is_dropdown_expanded():
            return None
            
        # Check if mouse is within the scroll container's visible area
        container_rect = self.scroll_container.get_abs_rect()
        if not container_rect.collidepoint(mx, my):
            return None
            
        # Find which item is hovered
        for item in self.items:
            # Get the absolute rect of the item's panel
            item_abs_rect = item.panel.get_abs_rect()
            # Also need to check it's within the visible scroll area (clip)
            if item_abs_rect.collidepoint(mx, my):
                # Check if this part of the item is actually visible (not scrolled out)
                if container_rect.contains(item_abs_rect) or container_rect.colliderect(item_abs_rect):
                    return item
        return None
        
    def deselect_all(self):
        """Deselect all items in the list."""
        for item in self.items:
            item.set_selected(False)
        self.selected_item = None
        
    def update_component_list(self):
        """Filter, sort, and populate the component list."""
        # Clear existing
        for item in self.items:
            item.kill()
        self.items = []
        
        # 1. Filter by Vehicle Type (Implicit)
        v_type = getattr(self.builder.ship, 'vehicle_type', "Ship")
        filtered = [c for c in self.builder.available_components if v_type in c.allowed_vehicle_types]
        
        # 2. Filter by Component Type
        if self.current_type_filter != "All Types":
            filtered = [c for c in filtered if c.type_str == self.current_type_filter]
            
        # 3. Filter by Layer
        # 3. Filter by Layer
        
        # Refresh options map based on current ship layers
        current_ship_layers = [l.name for l in self.builder.ship.layers.keys()]
        expected_options = ["All Layers"] + sorted(current_ship_layers)
        
        # If options changed (e.g. ship class changed), rebuild dropdown
        # Note: We can't easily check internal options of UIDropDownMenu in all versions, but we can check our list
        if expected_options != self.layer_filter_options:
            self.layer_filter_options = expected_options
            # Reset filter if current selection is invalid
            if self.current_layer_filter not in self.layer_filter_options:
                self.current_layer_filter = "All Layers"
                
            # Recreate dropdown (cleanest way to update options)
            self.filter_layer_dropdown.kill()
            y_filters = 40
            self.filter_layer_dropdown = UIDropDownMenu(
                options_list=self.layer_filter_options,
                starting_option=self.current_layer_filter,
                relative_rect=pygame.Rect((self.rect.width//2)+5, y_filters, (self.rect.width//2)-10, 30),
                manager=self.manager,
                container=self.panel
            )
            self.filter_layer_dropdown.change_layer(5)

        
        from ship_validator import LayerRestrictionDefinitionRule
        from game.simulation.entities.ship import LayerType
        # Create a temporary rule instance for filtering
        restriction_rule = LayerRestrictionDefinitionRule()

        if self.current_layer_filter != "All Layers":
             # Filter by specific layer (find the LayerType enum from name)
             # self.builder.ship.layers keys are LayerType enums
             target_layer = None
             for l_key in self.builder.ship.layers.keys():
                 if l_key.name == self.current_layer_filter:
                     target_layer = l_key
                     break
             
             if target_layer:
                 filtered = [c for c in filtered if restriction_rule.validate(self.builder.ship, c, target_layer).is_valid]
        else:
             # "All Layers": Show if compatible with AT LEAST ONE of the CURRENT ship's layers
             valid_layer_types = list(self.builder.ship.layers.keys())
             filtered = [
                 c for c in filtered 
                 if any(restriction_rule.validate(self.builder.ship, c, l_type).is_valid for l_type in valid_layer_types)
             ]
        
        # 4. Sort
        if self.current_sort == "Default (JSON Order)":
            filtered.sort(key=lambda c: self.component_order_map.get(c.id, 9999))
        elif self.current_sort == "Classification":
            # Sort by Classification, then Name
            filtered.sort(key=lambda c: (c.data.get('major_classification', 'Unknown'), c.name))
        elif self.current_sort == "Mass (Low-High)":
            filtered.sort(key=lambda c: c.mass)
        elif self.current_sort == "Mass (High-Low)":
            filtered.sort(key=lambda c: c.mass, reverse=True)
        elif self.current_sort == "Name (A-Z)":
            filtered.sort(key=lambda c: c.name)
        elif self.current_sort == "Type":
            filtered.sort(key=lambda c: (c.type_str, c.name))
            
        # Create Items
        item_width = self.scroll_container.get_container().get_rect().width
        y = 0
        for comp in filtered:
            item = ComponentListItem(
                component=comp,
                manager=self.manager,
                container=self.scroll_container,
                y_pos=y,
                width=item_width,
                sprite_mgr=self.builder.sprite_mgr,
                ship_context=self.builder.ship
            )
            self.items.append(item)
            y += item.height
            
        # Update Scroll Area
        self.scroll_container.set_scrollable_area_dimensions((item_width, y))
        
    def draw(self, screen):
        # Draw hover highlight overlay for hovered items
        for item in self.items:
            if getattr(item, 'is_hovered', False) and item != self.selected_item:
                # Get the absolute rect of the item
                abs_rect = item.get_abs_rect()
                # Check if it's visible in the scroll container
                container_rect = self.scroll_container.get_abs_rect()
                if container_rect.colliderect(abs_rect):
                    # Clip to container bounds
                    clipped = abs_rect.clip(container_rect)
                    # Draw semi-transparent highlight
                    highlight_surf = pygame.Surface((clipped.width, clipped.height), pygame.SRCALPHA)
                    highlight_surf.fill((80, 80, 120, 100))  # Semi-transparent blue-ish
                    screen.blit(highlight_surf, clipped.topleft)



    def handle_event(self, event):
        # Handle Sort Dropdown
        if event.type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:
            if event.ui_element == self.sort_dropdown:
                self.current_sort = event.text
                self.update_component_list()
                return None
            elif event.ui_element == self.filter_type_dropdown:
                self.current_type_filter = event.text
                self.update_component_list()
                return None
            elif event.ui_element == self.filter_layer_dropdown:
                self.current_layer_filter = event.text
                self.update_component_list()
                return None
            
        # Handle Item Clicks
        if event.type == pygame_gui.UI_BUTTON_PRESSED:
            for item in self.items:
                if event.ui_element == item.button:
                    # Deselect others, select clicked item while it's being carried
                    for i in self.items: i.set_selected(False)
                    item.set_selected(True)
                    self.selected_item = item
                    return ('select_component_type', item.component)



        # Handle Bulk Add UI
        if event.type == pygame_gui.UI_HORIZONTAL_SLIDER_MOVED:
            if event.ui_element == self.count_slider:
                val = int(event.value)
                self.count_entry.set_text(str(val))
                return None
                
        elif event.type == pygame_gui.UI_TEXT_ENTRY_CHANGED:
            if event.ui_element == self.count_entry:
                try:
                    val = int(event.text)
                    val = max(1, min(1000, val))
                    self.count_slider.set_current_value(val)
                except ValueError:
                    pass
                return None
                
        elif event.type == pygame_gui.UI_BUTTON_PRESSED:
            current = int(self.count_slider.get_current_value())
            new_val = current
            
            # Simple Increments
            if event.ui_element == self.btn_m1: new_val = current - 1
            elif event.ui_element == self.btn_p1: new_val = current + 1
            
            # Snap Logic
            # << / >> : Snap to 10
            elif event.ui_element == self.btn_p10:
                # Next multiple of 10. (12 -> 20, 20 -> 30)
                # (current // 10 + 1) * 10
                new_val = (current // 10 + 1) * 10
            elif event.ui_element == self.btn_m10:
                # Prev multiple of 10. (12 -> 10, 10 -> 0 -> 1 min)
                # If current % 10 == 0: subtract 10
                # Else: floor(current / 10) * 10
                if current % 10 == 0:
                    new_val = current - 10
                else:
                    new_val = (current // 10) * 10
                    
            # <<< / >>> : Snap to 100
            elif event.ui_element == self.btn_p100:
                new_val = (current // 100 + 1) * 100
            elif event.ui_element == self.btn_m100:
                if current % 100 == 0:
                    new_val = current - 100
                else:
                    new_val = (current // 100) * 100
            
            if new_val != current:
                new_val = max(1, min(1000, new_val))
                self.count_slider.set_current_value(new_val)
                self.count_entry.set_text(str(new_val))
                return None
        
        return None

    def get_add_count(self):
        """Return the current value of the bulk add counter."""
        try:
            val = int(self.count_entry.get_text())
            return max(1, min(1000, val))
        except ValueError:
            return 1
        
    def get_hovered_component(self, mx, my):
        # Check if mouse is over any item button
        # Using pygame_gui check_hover logic might be tricky since button is internal
        # But we can check if button.rect contains mouse
        
        # Simple check: iterate visible items?
        # ComponentListItem is wrapper, self.button is the UI element
        for item in self.items:
            # We must use the absolute rect of the button
            # But button.rect is relative to container? No, pygame_gui element.rect is usually absolute screen rect 
            # OR relative depends on container. 
            # In pygame_gui 0.6.x, .rect is usually absolute screen position for interaction.
            # Let's trust button.rect.collidepoint
            if item.button.rect.collidepoint(mx, my):
                return item.component
        return None

--- END FILE: ui/builder/left_panel.py ---

[WARNING: File not found: game/ui/builder/builder_scene_gui.py]

--- START FILE: Refactoring/active_refactor.md ---
# Active Refactor: Hull Component & Ship Cohesion
**Goal:** Unify Ship stats with V2 Ability System (Hull Component) and eliminate architectural incoherence.

## Status
**Current Phase:** Phase 4 (UI Reconstruction) - AWAITING REVIEW
**Start Date:** 2026-01-05
**Phase 1 Review:** ✅ APPROVED (2026-01-06)
**Phase 2 Review:** ✅ APPROVED (2026-01-06)
**Phase 3 Review:** ✅ APPROVED (2026-01-06)
**Phase 4 Review:** ⏳ PENDING (2026-01-06)
**Status:** [PHASE_4_COMPLETE_PENDING_REVIEW]

---

## Migration Map (The Constitution)

| Concept | Legacy State | Target State | Source of Truth |
| :--- | :--- | :--- | :--- |
| **Hull Definition** | `vehicleclasses.json` (hull_mass, hp) | `components.json` ("type": "Hull") | Component Data |
| **Base Mass** | `Ship.base_mass` (manual float) | Sum of `Hull` component + Systems | `ShipStatsCalculator` |
| **Requirements** | Hardcoded checks & `Ship.requirements` | `CrewRequired`, `FuelStorage` Abilities | Ability System V2 |
| **Resource State** | Reset on Load (Volatile) | Persisted in `Ship.resources` | Save Data |
| **UI Layout** | Hardcoded Pixel Overlaps | Responsive/Grid-based | `builder_utils.py` |

---

## Phased Schedule

### Phase 1: Data & State Foundations (The Bedrock) [Complete]
**Objective:** Fix critical state bugs and prepare data structures.
- [x] **Critical Fix:** Patch `resource_manager.py` clamping bug (resets to 0 on overflow).
- [x] **Data Migration:** Create `Hull` components in `data/components.json` for all 18 classes. [Data Architect]
- [x] **Data Migration:** Add `default_hull_id` to `data/vehicleclasses.json`. [Data Architect]
- [x] **Serialization:** Update `Ship.to_dict`/`from_dict` to persist `ResourceRegistry` values. [Data Architect]
- [x] **Cleanup:** Remove hardcoded ability string maps in `Component._instantiate_abilities`.

---

### Phase 2: Core Logic & Stability (The Engine) [Complete]
**Objective:** Implement the "Hull as Component" logic and fix core simulation loops.
- [x] **Task 2.1:** Update `Ship.__init__` to auto-equip `default_hull_id`. [Core Engineer]
- [ ] **Task 2.2:** Switch `Ship.mass` and `Ship.hp` to cached properties in `ShipStatsCalculator`. (DEFERRED - optimization)
- [x] **Task 2.3:** Implement `CommandAndControl` and `CrewRequired` logic in `update_derelict_status`.
- [x] **Task 2.4:** Remove duplicate To-Hit/Derelict initializations in `Ship.py`.
- [x] **Task 2.5:** Standardize MRO-based identity checks (remove brittle class name checks).
- [x] **Task 2.6:** Fix detail panel rendering test regressions. [UI Specialist]
  - **File:** `tests/unit/ui/test_detail_panel_rendering.py`
  - **Fix:** Added missing `uitextbox_patch_real.stop()` in tearDown to prevent patch leakage causing intermittent failures in parallel execution.

---

## Phase 2 Implementation Specifications

### Task 2.1: Auto-Equip `default_hull_id` in `Ship.__init__`
**File:** `game/simulation/entities/ship.py`
**Method:** `__init__`

**Current State (lines ~223-230):**
```python
class_def = get_vehicle_classes().get(self.ship_class, {"hull_mass": 50, "max_mass": 1000})
self.base_mass: float = class_def.get('hull_mass', 50)  # LEGACY
```

**Target Implementation:**
```python
from game.simulation.components.component import create_component

# In __init__, AFTER _initialize_layers():
class_def = get_vehicle_classes().get(self.ship_class, {})
default_hull_id = class_def.get('default_hull_id')

if default_hull_id:
    hull_component = create_component(default_hull_id)
    if hull_component:
        self.add_component(hull_component, LayerType.CORE)
    else:
        print(f"WARNING: Hull '{default_hull_id}' not found for {self.ship_class}")
```

**Steps:**
1. Import `create_component` from `game.simulation.components.component`.
2. Remove `self.base_mass` assignment from `class_def.get('hull_mass', ...)`.
3. After `_initialize_layers()`, lookup `default_hull_id` and call `create_component()`.
4. Add Hull to `CORE` layer via `add_component()`.

**Edge Cases:**
- Missing `default_hull_id` → Log warning, continue (test-only ships).
- Component registry not loaded → Graceful `None` return from `create_component`.

---

### Task 2.2: Cached `mass` and `hp` Properties
**Files:** `game/simulation/entities/ship.py`, `ship_stats.py`

**Current State:**
- `self.mass: float = 0.0` (direct attribute)
- `@property max_hp` / `hp` → O(n) iteration on every access

**Target Implementation in `Ship.__init__`:**
```python
self._cached_mass: float = 0.0
self._cached_max_hp: int = 0
self._cached_hp: int = 0
```

**Target Properties:**
```python
@property
def mass(self) -> float:
    return self._cached_mass

@property
def max_hp(self) -> int:
    return self._cached_max_hp

@property
def hp(self) -> int:
    return self._cached_hp
```

**In `ShipStatsCalculator.calculate(ship)`:**
```python
# Calculate and cache
total_mass = sum(c.mass for layer in ship.layers.values() for c in layer['components'])
total_max_hp = sum(c.max_hp for layer in ship.layers.values() for c in layer['components'])
total_hp = sum(c.current_hp for layer in ship.layers.values() for c in layer['components'])

ship._cached_mass = total_mass
ship._cached_max_hp = total_max_hp
ship._cached_hp = total_hp
```

---

### Task 2.3: Ability-Based Derelict Logic
**File:** `game/simulation/entities/ship.py`
**Method:** `update_derelict_status`

**New Abilities Required (in `abilities.py`):**
```python
class CommandAndControl(Ability):
    """Marks component as command center (Bridge, CIC)."""
    pass
```

**Target Implementation:**
```python
def update_derelict_status(self) -> None:
    # Check 1: Command and Control
    has_command = any(
        comp.is_operational and comp.has_ability('CommandAndControl')
        for layer in self.layers.values()
        for comp in layer['components']
    )
    
    if not has_command:
        self.is_derelict = True
        self.bridge_destroyed = True
        return
    
    # Check 2: Crew Capacity (optional)
    total_crew_req = self.get_total_ability_value('CrewRequired')
    total_crew_cap = self.get_total_ability_value('CrewCapacity')
    
    if total_crew_req > total_crew_cap:
        self.is_derelict = True
        return
    
    self.is_derelict = False
```

**Data Migration:** Add `"CommandAndControl": true` to Bridge components in `components.json`.

---

### Task 2.4: Remove Duplicate Initializations
**File:** `game/simulation/entities/ship.py`

**Remove (lines ~248-251):**
```python
self.baseline_to_hit_offense = 0.0  # DUPLICATE
self.to_hit_profile = 0.0  # DUPLICATE
```

**Keep (lines ~298-300):**
```python
self.to_hit_profile: float = 1.0       # Defensive Multiplier
self.baseline_to_hit_offense: float = 1.0  # Offensive Multiplier
```

---

### Task 2.5: Standardize Identity Checks
**File:** `game/simulation/entities/ship.py`
**Method:** `max_weapon_range` (lines ~325-355)

**Current (brittle):**
```python
if cls.__name__ == 'WeaponAbility':  # STRING CHECK
```

**Target:**
```python
from game.simulation.components.abilities import WeaponAbility, SeekerWeaponAbility

for ab in comp.ability_instances:
    if isinstance(ab, WeaponAbility):  # POLYMORPHIC
        rng = getattr(ab, 'range', 0.0)
        if isinstance(ab, SeekerWeaponAbility) and rng <= 0:
            rng = ab.projectile_speed * ab.endurance
        max_rng = max(max_rng, rng)
```

### Phase 3: Test Infrastructure & Verification (The Guardrails) [Complete]
**Objective:** Restore test isolation and verify unified stats.
- [x] **Task 3.1:** Restore/Fix `tests/conftest.py` for proper `RegistryManager` isolation. [QA Lead]
  - Added pre-test `mgr.clear()` before marker check
  - Restructured with try/finally for unconditional post-test cleanup
- [x] **Task 3.2:** Create `tests/unit/entities/test_ship_core.py` (Mocked Hull/Stat verification).
  - Created 6 test cases covering Hull auto-equip, legacy fallback, mass/HP aggregation, derelict status
  - All tests passing
- [x] **Task 3.3:** Audit existing Ship tests for `RegistryManager` usage compliance.
  - grep for COMPONENT_REGISTRY → 0 matches ✓
  - grep for VEHICLE_CLASSES → 0 matches ✓

---

## Phase 3 Implementation Specifications

### Task 3.1: Registry Isolation in `conftest.py`
**File:** `tests/conftest.py`
**Root Cause:** `reset_game_state` fixture skips cleanup when `use_custom_data` marker is present.

**Target Implementation:**
```python
@pytest.fixture(autouse=True)
def reset_game_state(monkeypatch, request):
    from game.core.registry import RegistryManager
    mgr = RegistryManager.instance()
    
    # Pre-test cleanup (ALWAYS)
    mgr.clear()

    if "use_custom_data" not in request.keywords:
        # Standard Fast Hydration
        cache = SessionRegistryCache.instance()
        cache.load_all_data()
        mgr.hydrate(...)
        
    yield
    
    # Post-test cleanup (ALWAYS RUNS)
    mgr.clear()
```

**Steps:**
1. Open `tests/conftest.py`.
2. Locate `reset_game_state` fixture.
3. Add `mgr.clear()` call BEFORE the marker check.
4. Ensure `mgr.clear()` is called AFTER `yield` unconditionally.
5. Run `pytest tests/unit/entities/test_sequence_hazard.py` to verify isolation.

---

### Task 3.2: Create `test_ship_core.py`
**File:** `tests/unit/entities/test_ship_core.py`

**Test Cases:**

#### TC-3.2.1: Hull Auto-Equip Verification
```python
def test_hull_auto_equip(registry_with_hull):
    """Verify Ship auto-equips default_hull_id from vehicle class."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="Escort")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 1
    assert core_comps[0].id == "hull_escort"
    assert ship.base_mass == 0.0  # Attribute Shadowing
```

#### TC-3.2.2: Legacy Fallback (No Hull)
```python
def test_no_hull_fallback(registry_no_hull):
    """Verify Ship uses legacy hull_mass when no default_hull_id."""
    ship = Ship(name="Test", x=0, y=0, color=(255,255,255), ship_class="TestShip")
    
    core_comps = ship.layers[LayerType.CORE]['components']
    assert len(core_comps) == 0
    assert ship.base_mass == 100.0
```

#### TC-3.2.3: Mass Aggregation
```python
def test_mass_from_components(ship_with_components):
    """Verify Ship.mass equals sum of all component masses + base_mass."""
    ship = ship_with_components
    ship.recalculate_stats()
    
    expected_mass = ship.base_mass + sum(
        c.mass for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.mass == expected_mass
```

#### TC-3.2.4: HP Aggregation
```python
def test_hp_from_components(ship_with_components):
    """Verify Ship.max_hp equals sum of component max_hp values."""
    ship = ship_with_components
    
    expected_hp = sum(
        c.max_hp for layer in ship.layers.values() for c in layer['components']
    )
    assert ship.max_hp == expected_hp
```

#### TC-3.2.5: Derelict Status from CommandAndControl
```python
def test_derelict_on_bridge_destruction(ship_with_bridge):
    """Verify ship becomes derelict when CommandAndControl component destroyed."""
    ship = ship_with_bridge
    bridge = next(c for c in ship.layers[LayerType.CORE]['components'] 
                  if c.has_ability('CommandAndControl'))
    
    bridge.current_hp = 0
    ship.update_derelict_status()
    
    assert ship.is_derelict is True
```

**Fixtures Required:**
- `registry_with_hull`: Populates RegistryManager with Escort class + hull_escort component.
- `registry_no_hull`: Populates RegistryManager with TestShip class (hull_mass=100, no default_hull_id).
- `ship_with_components`: Creates Ship with known components for mass/HP testing.
- `ship_with_bridge`: Creates Ship with Bridge component having CommandAndControl ability.

---

### Task 3.3: Audit Ship Tests for RegistryManager Compliance
**Scope:** `tests/unit/entities/`, `tests/integration/`

**Verification Steps:**
1. `grep -r "COMPONENT_REGISTRY" tests/` → Should return 0 matches.
2. `grep -r "VEHICLE_CLASSES" tests/` → Should return 0 matches.
3. `grep -r "from game.simulation.entities.ship import" tests/` → Verify imports use `get_vehicle_classes`, `get_component_registry`.

**Remediation Pattern:**
```python
# OLD (Direct Import)
from game.simulation.entities.ship import COMPONENT_REGISTRY

# NEW (RegistryManager Access)
from game.core.registry import get_component_registry
components = get_component_registry()
```

**Run Verification:**
```bash
pytest tests/unit/entities/ -v
pytest tests/integration/ -v
```

### Phase 4: UI Reconstruction (The Interface) [Complete]
**Objective:** Resolve layout overlaps and ensure builder compatibility.
- [x] **Task 4.1:** Create `game/ui/screens/builder_utils.py` (Layout constants). [UI Specialist]
  - Created centralized module with `PanelWidths`, `PanelHeights`, `Margins`, and `BuilderEvents` constants
- [x] **Task 4.2:** Implement relative/grid sizing for `builder_screen.py` to fix 1920px overlap.
  - FIXED: Changed `layer_panel_width` from fixed `PANEL_WIDTHS.layer_panel` to dynamic `calculate_dynamic_layer_width(screen_width)`
  - FIXED: `weapons_panel_width` calculation now subtracts `right_panel_width` to prevent overlap
- [x] **Task 4.3:** Resolve vertical collision between Weapons Report and Nav Panels.
  - ANALYZED: `right_panel.py` uses single scroll container, no sub-panels needing `update_layout()`
  - RECLASSIFIED: Issue was horizontal overlap (covered by Task 4.2b), not vertical stacking
- [x] **Task 4.4:** Switch `BuilderSceneGUI` to event-based data sync using `REGISTRY_RELOADED`.
  - Added `REGISTRY_RELOADED` event emission in `_reload_data`
  - Updated `BuilderRightPanel` and `BuilderLeftPanel` to subscribe to event

### Phase 5: Legacy Purge & Final Polish (The Cleanup)
**Objective:** Remove deprecated data and finalize the refactor.
- [ ] **Cleanup:** Remove `hull_mass` and `requirements` from `vehicleclasses.json`.
- [ ] **Cleanup:** Remove hardcoded ship fallback registry in `load_vehicle_classes`.
- [ ] **Final Verification:** Run Full Gauntlet (Target: 100% Pass).
- [ ] **Definition of Done:**
    - `Ship.py` has ZERO hardcoded mass/hp assignments.
    - `vehicleclasses.json` contains NO physical stats.
    - Ship Builder UI renders without overlap on 1080p+.
    - Save/Load persists fuel/ammo levels correctly.

---

## Phase 4 Implementation Specifications

### Task 4.1: Centralize Layout Constants
**File:** `game/ui/screens/builder_utils.py` [NEW]

**Implementation Spec:**
Create a utility module to define the design system's dimensions.

```python
# game/ui/screens/builder_utils.py

PANEL_WIDTHS = {
    'component_palette': 400,
    'structure_list': 400,
    'detail_panel': 500,
    'ship_stats': 750
}

PANEL_HEIGHTS = {
    'bottom_bar': 60,
    'weapons_report': 500,
    'modifier_panel': 360
}

MARGINS = {
    'edge': 20,
    'gutter': 10
}
```

---

### Task 4.2: Relative/Grid Layout for 1920px+
**File:** `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Calculate Available Center Width:** `center_width = screen_width - PANEL_WIDTHS['component_palette'] - PANEL_WIDTHS['ship_stats']`.
2. **Dynamic Layer Panel:** Instead of fixed 450px, the Layer Panel should take `min(400, center_width * 0.3)`.
3. **Schematic View:** Takes the remaining center space.
4. **Detail Panel Overlay:** Position the Detail Panel as a `pygame_gui.elements.UIPanel` with a relative offset from the right.

---

### Task 4.3: Resolve Vertical Panel Collision
**File:** `ui/builder/right_panel.py`

**Implementation Spec:**
The "Weapons Report" and "Navigation Panels" must use a vertical stack instead of fixed Y-offsets.

```python
def update_layout(self):
    current_y = MARGINS['edge']
    for panel in self.sub_panels:
        panel.set_relative_position((0, current_y))
        current_y += panel.rect.height + MARGINS['gutter']
```

---

### Task 4.4: Event-Based UI Synchronization
**Files:** `ui/builder/event_bus.py`, `game/ui/screens/builder_screen.py`

**Implementation Spec:**
1. **Registry Reload Event:** Add `REGISTRY_RELOADED = 'REGISTRY_RELOADED'` to `EventBus`.
2. **Panel Subscriptions:** `BuilderRightPanel` and `BuilderLeftPanel` subscribe to `REGISTRY_RELOADED`.
3. **Internal Refresh:** Update `BuilderRightPanel.refresh_controls()` to update dropdown *options* without killing the object.
4. **Preserve Selection:** Cache `self.ship.ship_class` before reload and re-apply to dropdown after refresh.

---

## Test Triage Table
| Issue | File | Status | Owner | Notes |
| :--- | :--- | :--- | :--- | :--- |
| Task 4.2a: Dynamic Layer Width | `builder_screen.py` | RESOLVED | UI Specialist | Changed to `calculate_dynamic_layer_width(screen_width)` |
| Task 4.2b: Weapons Panel Width | `builder_screen.py` | RESOLVED | UI Specialist | Subtracted `right_panel_width` from calculation |
| Task 4.3: Vertical Stacking | `right_panel.py` | NOT_APPLICABLE | UI Specialist | Reclassified: right_panel uses single scroll container, no sub-panels |

--- END FILE: Refactoring/active_refactor.md ---

