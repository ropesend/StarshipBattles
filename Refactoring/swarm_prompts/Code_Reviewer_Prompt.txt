# INSTRUCTIONS FOR AGENT (Code_Reviewer)

**ROLE:** Code_Reviewer
**FOCUS:** Phase 3 Infrastructure (SessionCache, RegistryManager) & Logic Flaws

## YOUR GOAL
Analyze the provided code context below.
Isolate issues specifically related to your FOCUS (Phase 3 Infrastructure (SessionCache, RegistryManager) & Logic Flaws).
Ignore unrelated issues unless they are critical system failures.

## PHASE STATUS

--- ACTIVE REFACTOR CONTEXT ---
# Refactor: Test Stabilization & Registry Encapsulation

**Goal:** Eliminate "State Pollution" in the test suite by encapsulating global registries and singletons into a manageable `RegistryManager`, and enforcing strict state resets via a new root `conftest.py`.
**Status:** Phase 3: Performance & Stability Infrastructure (Active)
**Start Date:** 2026-01-04

## Migration Map (The Constitution)

| Legacy Global | New Access Pattern |
| :--- | :--- |
| `game.simulation.components.component.COMPONENT_REGISTRY` | `RegistryManager.instance().components` |
| `game.simulation.components.component.MODIFIER_REGISTRY` | `RegistryManager.instance().modifiers` |
| `game.simulation.entities.ship.VEHICLE_CLASSES` | `RegistryManager.instance().vehicle_classes` |
| `game.simulation.entities.ship._VALIDATOR` | `RegistryManager.instance().get_validator()` |

## Test Triage Table

| Test File | Status | Notes |
| :--- | :--- | :--- |
| `tests/repro_issues/test_sequence_hazard.py` | [PASSED] | Canary test verified pollution cleanup. |
| `tests/unit/test_components.py` | [PASSED] | Refactored `setUpClass` -> `setUp` to fix isolation regression. |
| `tests/unit/*` | [KNOWN_ISSUE] | ~280 failures/errors remain (70 failed, 209 errors). Suspect deep `xdist` contention or legacy `setUp` issues. |
| `tests/unit/repro_issues/test_slider_increment.py` | [FIXED] | Converted `setUpClass` to `setUp`. |
| `tests/unit/test_overlay.py` | [FLAKY] | `test_toggle_overlay` fails in full suite (passes in isolation). |
| `tests/unit/test_ui_widgets.py` | [FLAKY] | `test_button_hover_detection` etc. fail in full suite. |

## Phased Schedule

### Phase 1: Test Stabilization

#### 1. Verification Test (The Canary)
- [x] [NEW] `tests/repro_issues/test_sequence_hazard.py`
    - implement `test_pollution_setter` (writes "Poison" to registry)
    - implement `test_pollution_victim` (asserts registry is clean)

#### 2. Infrastructure: The Registry Manager
- [x] [NEW] `game/core/registry.py`
    - Implement `RegistryManager` Singleton.
    - Implement `clear()` method for `components`, `modifiers`, `vehicle_classes`.
    - Implement `instance()` method.

#### 3. Core Refactoring: Deprecate Globals
- [x] [MODIFY] `game/simulation/components/component.py`
    - Import `RegistryManager`.
    - **CRITICAL**: Keep `COMPONENT_REGISTRY` and `MODIFIER_REGISTRY` variables for backward compatibility, but make them Property or Proxy to `RegistryManager`. *Correction*: Simple assignment `COMPONENT_REGISTRY = RegistryManager.instance().components` at module level is unsafe if Manager is reset.
    - **Better Approach**: Replace usages.
    - Update `load_components` to populate `RegistryManager.instance().components`.
    - Update `load_modifiers` to populate `RegistryManager.instance().modifiers`.
    - Usage replacements: `COMPONENT_REGISTRY[...]` -> `RegistryManager.instance().components[...]`.

- [x] [MODIFY] `game/simulation/entities/ship.py`
    - Import `RegistryManager`.
    - Update `load_vehicle_classes` to populate `RegistryManager.instance().vehicle_classes`.
    - Refactor `_VALIDATOR` to be accessed via Manager or created on demand.
    - **Note**: `ValidatorProxy` implementation verified. Safe.

#### 4. Test Harness: Strict Fixtures
- [x] [NEW] `tests/conftest.py`
    - `@pytest.fixture(autouse=True)`
    - `reset_game_state()`: calls `RegistryManager.instance().clear()` before and after yield.

### Phase 2: Test Suite Adaptation

#### 0. Performance Mitigation: Smart Caching Loaders
- [x] [MODIFY] `game/simulation/components/component.py`
    - Implement module-level cache `_COMPONENT_CACHE` and `_MODIFIER_CACHE`.
    - Update `load_components` and `load_modifiers` to load from disk ONLY if cache is None.
    - If cache exists, deepcopy data from cache to `RegistryManager.instance`.
    - **Benefit**: Calling `load_components` 100 times in `setUp` will be fast (memory copy) vs slow (disk IO).

#### 1. Bulk Migration (setUpClass -> setUp)
- [x] [MODIFY] `tests/unit/test_combat.py` (First candidate)
    - Replace `setUpClass` with `setUp`.
    - Ensure `load_components` is called in `setUp`.
- [x] [MODIFY] Remaining files in `tests/unit/`
    - Identify tests using `setUpClass` to load data.
    - Convert `setUpClass` methods to `setUp`.
    - Replace `cls.` with `self.` for instance variables.
    - **Update**: `test_slider_increment.py` fixed in Phase 2.5.

#### 2. Performance Verification

#### 2. Performance Verification
- [x] [EXECUTE] Run full test suite.
    - Monitor execution time. If `setUp` overhead is too high (>60s), consider a `session` scoped fixture for loading data into a *separate* cache, and then shallow copying to RegistryManager in `setUp`.
    - For now, naive `setUp` loading is the safest first step.

#### 3. Final Verification
- [x] [EXECUTE] Run `tests/repro_issues/test_sequence_hazard.py` (Must still PASS).
- [ ] [EXECUTE] Run Full Suite (Must be GREEN).
    - **Status:** SKIPPED.
    - **Reason:** Systemic IO contention detected (209 errors). Proceeding to Phase 3 to fix infrastructure before further verification.

### Phase 2.5: Critical Test Fixes (BLOCKER)
- [x] [FIX] `tests/unit/test_rendering_logic.py`
    - Failure: `TypeError: unexpectedly NoneType object has no attribute 'layer_assigned'` in `test_component_color_coding`.
    - Likely cause: Mock setup issue in `draw_ship`.
    - Resolution: Passed in isolation. Added defensive check in `Ship.add_component`.
- [x] [FIX] `tests/unit/test_ship_theme_logic.py`
    - Failure: `AssertionError` in `test_get_image_metrics`.
    - Note: Likely environment/headless incompatibility or race condition.
    - Resolution: Passed in isolation. Verified.
- [x] [FIX] `tests/repro_issues/test_bug_09_endurance.py`
    - Failure: `AssertionError` (Stats Panel shows 'Infinite' for finite fuel endurance).
    - Action: Determine if this is a regression or correct bug reproduction. Fix test or code accordingly.
    - Resolution: Passed (Verified "Infinite" not shown).
- [x] [EXECUTE] Run Full Suite (Must be STRICTLY GREEN).
    - Status: **FAILED**. 70 failed, 209 errors.
    - **DECISION**: Flagged remaining issues to proceed to Swarm Review for deep triage.

### Phase 2.6: UI Test Isolation (Flaky Tests)
- [x] [FIX] `tests/unit/test_overlay.py`
    - Failure: `test_toggle_overlay` passes in isolation but fails in suite.
    - Cause: `game.app` import caused environment crash in pytest; fixed by refactoring to use `MockGame` and `InputHandler`.
- [x] [FIX] `tests/unit/test_ui_widgets.py`
    - Failures: `test_button_hover_detection`, `test_button_click_fires_callback` (context dependent failures).
    - Cause: Fixed by global `conftest.py` headless environment enforcement.

### Phase 3: Performance & Stability Infrastructure (CRITICAL)
*Goal: Eliminate IO contention causing massive test timeouts/errors by implementing Session-Level Caching.*

#### 1. Implement Session Cache
- [x] [NEW] `tests/infrastructure/session_cache.py`
    - **Class:** `SessionRegistryCache` (Singleton/Module).
    - **Responsibility:** Load `components.json`, `modifiers.json`, `vehicle_classes.json` from disk **ONCE** per test session.
    - **Methods:**
        - `get_components_data() -> Dict`: Returns deepcopy of raw component data.
        - `get_modifiers_data() -> Dict`: Returns deepcopy of raw modifier data.
        - `get_vehicle_classes_data() -> Dict`: Returns deepcopy of raw vehicle class data.
    - **Note:** Must handle "Not Found" gracefully and verify data integrity.

#### 2. Fast Hydration Fixture
- [x] [MODIFY] `tests/conftest.py`
    - **Fixture:** `reset_game_state` (autouse).
    - **Change:** 
        - Remove `RegistryManager.instance().clear()`.
        - Implement `RegistryManager.instance().hydrate_from(SessionRegistryCache)`.
        - OR: `RegistryManager.instance().clear()` then manually populate from Cache.
    - **Optimization:** If `RegistryManager` supports `bulk_load(dict)`, use that.
    - **Safeguard:** Ensure `RegistryManager.reset()` (destruction) is NOT used, or if it is, that cache handles re-attachment (unlikely needed).

#### 3. Registry Manager Update
- [x] [MODIFY] `game/core/registry.py`
    - **Method:** `hydrate(self, components_data, modifiers_data, vehicle_classes_data)`
    - **Logic:** Fast assignment of internal dicts (using copies).
    - **Safety:** Add warning/error to `reset()` method to discourage use during tests (favor `clear`).

#### 4. Verification (The Stability Check)
- [x] [EXECUTE] Run Full Suite.
    - **Result:** ~6.4s execution time.
    - **Performance:** Excellent. IO Contention eliminated.
    - **Status:** Full suite has noise issues (235 errors), BUT verification confirms ALL tests pass except for known logic bugs:
        - `tests/repro_issues/test_bug_05_logistics.py::test_missing_logistics_details`
        - `tests/repro_issues/test_bug_05_rejected_fix.py::test_usage_only_visibility`
        - `tests/repro_issues/test_bug_05_rejected_fix.py::test_max_usage_calculation`
    - **Next Step:** Protocol 12 (Swarm Review) required for final triage.

### Phase 4: Final Cleanup & Logic Repair
*Goal: Address remaining logic failures once stable, and remove legacy code.*

#### 1. Logic Repair (Triage)
- [ ] [FIX] `tests/unit/test_rendering_logic.py`
    - `TypeError: unexpectedly NoneType` in `test_component_color_coding`.
- [ ] [FIX] `tests/unit/test_ship_theme_logic.py`
    - `AssertionError` in `test_get_image_metrics`.
- [ ] [FIX] `tests/repro_issues/test_bug_05_logistics.py`
    - `KeyError: <LayerType...>` in `test_missing_logistics_details`.
- [ ] [FIX] Unknown 4th failure (likely `test_overlay` or `test_ui_widgets`).
    - Action: Identify and fix.

#### 2. Remove Legacy Aliases
- [ ] [MODIFY] `game/simulation/components/component.py`
    - Remove `COMPONENT_REGISTRY` and `MODIFIER_REGISTRY` global aliases IF strict code search confirms 0 usages.

#### 3. Lock Down RegistryManager
- [ ] [MODIFY] `game/core/registry.py`
    - Implement `freeze()` method to preventing writing to registry during `EXECUTION` phase of the game loop (optional safety).

#### 4. Archive Refactor
- [ ] [EXECUTE] Run Protocol 13 (Archive).

--- END ACTIVE REFACTOR CONTEXT ---


## OUTPUT INSTRUCTIONS
You are an autonomous agent.
1. Perform your analysis.
2. **CRITICAL:** You MUST use the `write_to_file` tool to save your report.
   - **Target File:** `C:\Dev\Starship Battles\Refactoring\swarm_reports\Code_Reviewer_Report.md`
   - **Do NOT** just print the markdown to the chat. Save it to the file.

## CONTEXT

--- START FILE: game/core/registry.py ---
from typing import Dict, Any, Optional

class RegistryManager:
    """
    Central singleton for managing global game state registries.
    Replaces module-level globals to allow for clean state resets in testing.
    """
    _instance: Optional['RegistryManager'] = None

    def __init__(self):
        if RegistryManager._instance is not None:
             raise Exception("RegistryManager is a singleton. Use RegistryManager.instance()")
        
        self.components: Dict[str, Any] = {}
        self.modifiers: Dict[str, Any] = {}
        self.vehicle_classes: Dict[str, Any] = {}
        self._validator: Any = None 

    @classmethod
    def instance(cls) -> 'RegistryManager':
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    @classmethod
    def reset(cls):
        """
        [WARNING] For testing only: completely destroys the singleton instance.
        Prefer clear() for test isolation to avoid stale reference hazards.
        """
        cls._instance = None

    def hydrate(self, components_data: Dict[str, Any], modifiers_data: Dict[str, Any], vehicle_classes_data: Dict[str, Any]):
        """
        Fast hydration from pre-loaded dictionary data (e.g. Session Cache).
        Bypasses disk I/O.
        """
        # CRITICAL: Do NOT replace the dictionary instances (e.g. self.components = ...).
        # Global aliases in other modules (like COMPONENT_REGISTRY) hold references to the original dicts.
        # We must update them in place.
        self.components.clear()
        self.components.update(components_data)
        
        self.modifiers.clear()
        self.modifiers.update(modifiers_data)
        
        self.vehicle_classes.clear()
        self.vehicle_classes.update(vehicle_classes_data)

    def clear(self):
        """Clears all registries to empty state."""
        self.components.clear()
        self.modifiers.clear()
        self.vehicle_classes.clear()
        self._validator = None

    def get_validator(self):
        return self._validator
    
    def set_validator(self, validator):
        self._validator = validator

--- END FILE: game/core/registry.py ---

--- START FILE: tests/infrastructure/session_cache.py ---
import json
import os
import copy
import threading
from typing import Dict, Any, Optional

class SessionRegistryCache:
    """
    Thread-safe Singleton cache for raw game data (components, modifiers, vehicle_classes).
    Loads data from disk EXACTLY ONCE per test session to prevent IO contention.
    """
    _instance: Optional['SessionRegistryCache'] = None
    _lock: threading.Lock = threading.Lock()

    def __init__(self):
        if SessionRegistryCache._instance is not None:
             raise Exception("SessionRegistryCache is a singleton. Use instance()")
        
        self.components_data: Dict[str, Any] = {}
        self.modifiers_data: Dict[str, Any] = {}
        self.vehicle_classes_data: Dict[str, Any] = {}
        self._is_loaded = False

    @classmethod
    def instance(cls) -> 'SessionRegistryCache':
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    def load_all_data(self, base_path: str = "data"):
        """
        Loads all data using actual game loaders to ensure logic (e.g. layer resolution) is applied.
        Captures the resulting state from RegistryManager.
        """
        with self._lock:
            if self._is_loaded:
                return

            try:
                # 1. Import Loaders inside method to avoid circular imports at top level
                from game.simulation.components.component import load_components, load_modifiers
                from game.simulation.entities.ship import load_vehicle_classes
                from game.core.registry import RegistryManager

                # 2. Reset Registry to clean state for capture
                mgr = RegistryManager.instance()
                mgr.clear()

                # 3. Trigger Loaders (They populate Registry)
                # Note: We rely on default paths or relative path logic in loaders
                # We suppress print output to avoid clutter? No, visibility is good.
                load_modifiers() 
                load_components()
                load_vehicle_classes()

                # 4. Capture State (Deep Copy)
                self.modifiers_data = copy.deepcopy(mgr.modifiers)
                self.components_data = copy.deepcopy(mgr.components)
                self.vehicle_classes_data = copy.deepcopy(mgr.vehicle_classes)

                self._is_loaded = True
                print(f"[SessionRegistryCache] Loaded {len(self.components_data)} components, {len(self.vehicle_classes_data)} classes.")

            except Exception as e:
                print(f"[SessionRegistryCache] CRITICAL ERROR loading data: {e}")
                import traceback
                traceback.print_exc()

    # _load_json helper no longer needed, removing...
    def _deprecated_load_json(self, filepath: str):
        pass

    def get_components(self) -> Dict[str, Any]:
        """Returns deep, safe copy of components data."""
        with self._lock:
             # Return deepcopy to ensure no one modifies the cache
             return copy.deepcopy(self.components_data)

    def get_modifiers(self) -> Dict[str, Any]:
        with self._lock:
            return copy.deepcopy(self.modifiers_data)

    def get_vehicle_classes(self) -> Dict[str, Any]:
        with self._lock:
            return copy.deepcopy(self.vehicle_classes_data)

    @classmethod
    def reset(cls):
        """For testing the cache itself."""
        cls._instance = None

--- END FILE: tests/infrastructure/session_cache.py ---

--- START FILE: tests/conftest.py ---
import os
# Force headless mode BEFORE any imports happen during collection
os.environ["SDL_VIDEODRIVER"] = "dummy"

import pytest
from game.core.registry import RegistryManager

@pytest.fixture(autouse=True)
def reset_game_state(monkeypatch):
    """
    Context manager for strict test isolation using Fast Hydration.
    Ensures global registries are populated from memory (Session Cache) before each test,
    and cleaned up after.
    """
    from tests.infrastructure.session_cache import SessionRegistryCache
    
    # 1. Ensure Session Cache is loaded (Once per session effectively, via singleton check)
    cache = SessionRegistryCache.instance()
    cache.load_all_data()

    # 2. Fast Hydration: Populate Registry from Cache
    RegistryManager.instance().hydrate(
        cache.get_components(),
        cache.get_modifiers(),
        cache.get_vehicle_classes()
    )

    # 3. Patch Loaders/Caches to prevent Disk I/O during test execution
    # If a test calls load_components(), it should find the cache populated or be intercepted.
    
    # A. Component Cache: Inject data so load_components() returns early
    # Note: We inject a deepcopy from session cache to avoid test pollution
    monkeypatch.setattr("game.simulation.components.component._COMPONENT_CACHE", cache.get_components())
    monkeypatch.setattr("game.simulation.components.component._MODIFIER_CACHE", cache.get_modifiers())

    # B. Ship Vehicle Classes: Patch loader to be a no-op (Data already in Registry)
    monkeypatch.setattr("game.simulation.entities.ship.load_vehicle_classes", lambda *args, **kwargs: None)

    yield
    
    # Post-test cleanup
    RegistryManager.instance().clear()

@pytest.fixture(scope="session", autouse=True)
def enforce_headless():
    """
    Enforce headless mode for Pygame to prevent window creation and interference.
    """
    import pygame
    pygame.init()
    yield
    pygame.quit()

--- END FILE: tests/conftest.py ---

--- START FILE: game/simulation/components/component.py ---
import json
import math
from enum import Enum, auto
from formula_system import evaluate_math_formula
from game.core.registry import RegistryManager

class ComponentStatus(Enum):
    ACTIVE = auto()
    DAMAGED = auto() # >50% damage
    NO_CREW = auto()
    NO_POWER = auto()
    NO_FUEL = auto()
    NO_AMMO = auto()

class LayerType(Enum):
    CORE = 1
    INNER = 2
    OUTER = 3
    ARMOR = 4

    @staticmethod
    def from_string(s):
        return getattr(LayerType, s.upper())

class Modifier:
    def __init__(self, data):
        self.id = data['id']
        self.name = data['name']
        self.type_str = data['type'] # 'boolean' or 'linear'
        self.description = data.get('description', '')
        self.effects = data.get('effects', {})
        self.restrictions = data.get('restrictions', {})
        self.param_name = data.get('param_name', 'value')
        self.min_val = data.get('min_val', 0)
        self.max_val = data.get('max_val', 100)
        self.default_val = data.get('default_val', self.min_val)
        self.readonly = data.get('readonly', False)

    def create_modifier(self, value=None):
        return ApplicationModifier(self, value)

# MODIFIER_REGISTRY = {} 
# Aliased to RegistryManager for backward compatibility (but prefer Manager access)
MODIFIER_REGISTRY = RegistryManager.instance().modifiers

class ApplicationModifier:
    """Instance of a modifier applied to a component"""
    def __init__(self, mod_def, value=None):
        self.definition = mod_def
        self.value = value if value is not None else mod_def.default_val

# IMPORTS MOVED TO LOCAL SCOPE TO PREVENT CIRCULAR DEPENDENCY
# from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability

class Component:
    def __init__(self, data):
        import copy
        self.data = copy.deepcopy(data) # Store raw data for reference/cloning
        self.id = data['id']
        self.name = data['name']
        self.base_mass = data['mass']
        self.mass = self.base_mass
        self.base_max_hp = data['hp']
        self.max_hp = self.base_max_hp
        self.current_hp = self.max_hp
        # allowed_layers removed in refactor
        # self.allowed_layers = [LayerType.from_string(l) for l in data['allowed_layers']]
        self.allowed_vehicle_types = data.get('allowed_vehicle_types', ["Ship"])
        self.major_classification = data.get('major_classification', "Unknown")
        self.is_active = True
        self.status = ComponentStatus.ACTIVE
        self.layer_assigned = None
        self.type_str = data['type']
        self.sprite_index = data.get('sprite_index', 0)
        self.cost = data.get('cost', 0)
        
        # Parse abilities from data
        self.abilities = self.data.get('abilities', {})
        self.base_abilities = copy.deepcopy(self.abilities)
        
        self.ship = None # Container reference
        
        self.stats = {} # Current stats dictionary (calcualted)
        self.modifiers = [] # list of ApplicationModifier
        
        # Ability Instances (New System)
        self.ability_instances = []
        self._is_operational = True # Tracks if component has resources to operate
        
        # Instantiate Abilities
        self._instantiate_abilities()
        
        # Load default modifiers from data definition
        if 'modifiers' in self.data:
            for mod_data in self.data['modifiers']:
                mod_id = mod_data['id']
                val = mod_data.get('value', None)
                # We need to access registry. BUT registry might not be fully loaded if simple import.
                # Assuming MODIFIER_REGISTRY is populated by load_modifiers globally.
                from game.core.registry import RegistryManager
                mods = RegistryManager.instance().modifiers
                if mod_id in mods:
                    mod_def = mods[mod_id]
                    self.modifiers.append(mod_def.create_modifier(val))
                else:
                    # If modifiers loaded later, this might fail. 
                    # Ideally modifiers are loaded before components.
                    pass
                    
        # Parse Formulas
        self.formulas = {}
        for key, value in self.data.items():
            if isinstance(value, str) and value.startswith("="):
                # It's a formula!
                self.formulas[key] = value[1:] # Store without '='
                # Initialize base value to something safe? Or keep it as is?
                # Probably keep undefined or 0 until recalculated? 
                # Better to set a default if possible, but hard to guess.
                # If it's mass/hp, 0 is safer than crashing.
                if key in ['mass', 'hp', 'cost']:
                     setattr(self, f"base_{key}" if key in ['mass', 'hp'] else key, 0)
                     if key == 'mass': self.mass = 0
                     if key == 'hp': 
                         self.max_hp = 0
                         self.current_hp = 0

    def get_abilities(self, ability_name: str):
        """
        Get all abilities of a specific type (by registry name).
        Supports polymorphism if the registry entry is a class.
        """
        from game.simulation.components.abilities import ABILITY_REGISTRY
        
        target_class = None
        if ability_name in ABILITY_REGISTRY:
            val = ABILITY_REGISTRY[ability_name]
            if isinstance(val, type):
                target_class = val
        
        found = []
        for ab in self.ability_instances:
            # 1. Polymorphic check (preferred)
            if target_class and isinstance(ab, target_class):
                found.append(ab)
            # 2. Name check (fallback)
            elif ab.__class__.__name__ == ability_name:
                found.append(ab)
        return found

    def get_ability(self, ability_name: str):
        """Get first ability of type."""
        l = self.get_abilities(ability_name)
        return l[0] if l else None

    def has_ability(self, ability_name: str):
        """Check if component has ability."""
        return len(self.get_abilities(ability_name)) > 0

    def has_pdc_ability(self) -> bool:
        """Check if component has a Point Defense weapon ability.
        
        Supports both:
        - New system: 'pdc' in ability.tags
        - Legacy system: abilities.get('PointDefense', False)
        """
        # 1. Check new tag-based system
        for ab in self.ability_instances:
            if 'pdc' in ab.tags:
                return True
        

        return False

    def get_ui_rows(self):
        """Aggregate UI rows from all ability instances.
        
        Returns list of dicts: [{'label': 'Thrust', 'value': '1500 N'}, ...]
        Used by detail panels and capability scanners.
        """
        rows = []
        for ab in self.ability_instances:
            rows.extend(ab.get_ui_rows())
        return rows

    def _instantiate_abilities(self):
        """Instantiate Ability objects from self.abilities dict."""
        self.ability_instances = []
        
        # Standard Loading from abilities dict
        for name, data in self.abilities.items():
            # Lazy import to avoid circular dependency
            from game.simulation.systems.resource_manager import ABILITY_REGISTRY, create_ability
            
            if name not in ABILITY_REGISTRY:
                continue
            
            if isinstance(data, list):
                for item in data:
                    ab = create_ability(name, self, item)
                    if ab: self.ability_instances.append(ab)
            elif isinstance(data, dict) or isinstance(data, (int, float)):
                 ab = create_ability(name, self, data)
                 if ab: self.ability_instances.append(ab)
            
    def update(self):
        """Update component state for one tick (resource consumption, cooldowns)."""
        # 1. Update Abilities (Constant Consumption)
        all_satisfied = True
        
        for ability in self.ability_instances:
            if not ability.update():
                from game.simulation.systems.resource_manager import ResourceConsumption
                if isinstance(ability, ResourceConsumption) and ability.trigger == 'constant':
                     all_satisfied = False
        
        self._is_operational = all_satisfied and self.is_active

    @property
    def is_operational(self):
        return self._is_operational and self.is_active

    def can_afford_activation(self):
        """Check if component can afford activation costs."""
        from game.simulation.systems.resource_manager import ResourceConsumption
        for ability in self.ability_instances:
            if isinstance(ability, ResourceConsumption) and ability.trigger == 'activation':
                if not ability.check_available():
                    return False
        return True

    def consume_activation(self):
        """Consume activation costs."""
        from game.simulation.systems.resource_manager import ResourceConsumption
        for ability in self.ability_instances:
            if isinstance(ability, ResourceConsumption) and ability.trigger == 'activation':
                ability.check_and_consume()

    def try_activate(self):
        """Analyze if we can activate, and if so, consume and return True. (Legacy/Simple usage)"""
        if self.can_afford_activation():
            self.consume_activation()
            return True
        return False




    def take_damage(self, amount):
        self.current_hp -= amount
        if self.current_hp <= 0:
            self.current_hp = 0
            self.is_active = False
            return True # Destroyed
        return False

    def reset_hp(self):
        self.current_hp = self.max_hp
        self.is_active = True
        self.status = ComponentStatus.ACTIVE

    def add_modifier(self, mod_id, value=None):
        mods = RegistryManager.instance().modifiers
        if mod_id not in mods: return False
        
        # Check restrictions
        mod_def = mods[mod_id]
        if 'deny_types' in mod_def.restrictions:
            if self.type_str in mod_def.restrictions['deny_types']:
                return False
        if 'allow_types' in mod_def.restrictions:
            if self.type_str not in mod_def.restrictions['allow_types']:
                return False
                
        # Remove existing if any (replace)
        self.remove_modifier(mod_id)
            
        app_mod = ApplicationModifier(mod_def, value)
        self.modifiers.append(app_mod)
        self.recalculate_stats()
        return True

    def remove_modifier(self, mod_id):
        self.modifiers = [m for m in self.modifiers if m.definition.id != mod_id]
        self.recalculate_stats()

    def get_modifier(self, mod_id):
        for m in self.modifiers:
            if m.definition.id == mod_id:
                return m
        return None
        


    def recalculate_stats(self):
        """Recalculate component stats with multiplicative modifier stacking."""
        # Capture old hp for current_hp logic at end
        old_max_hp = self.max_hp

        # 1. Reset and Evaluate Base Formulas
        self._reset_and_evaluate_base_formulas()
        
        # 1.5 Re-instantiate Abilities (Sync instances with new abilities dict)
        self._instantiate_abilities()

        # 2. Calculate Modifier Stats (Accumulate multipliers)
        stats = self._calculate_modifier_stats()
        self.stats = stats # Persist for introspection/ability access

        # 3. Apply Base Stats (Generic attributes)
        self._apply_base_stats(stats, old_max_hp)
        
        # 4. Apply Custom/Subclass Stats
        self._apply_custom_stats(stats)

    def _reset_and_evaluate_base_formulas(self):
        import copy
        # Reset abilities from raw data
        self.abilities = copy.deepcopy(self.data.get('abilities', {}))
        
        # Context building
        context = {
            'ship_class_mass': 1000 # Default fallback
        }
        if self.ship:
             context['ship_class_mass'] = getattr(self.ship, 'max_mass_budget', 1000)

        # Evaluate Formulas for attributes
        for attr, formula in self.formulas.items():
            val = evaluate_math_formula(formula, context)
            if attr == 'mass':
                self.base_mass = float(val)
                self.mass = self.base_mass # Reset to base
            elif attr == 'hp':
                self.base_max_hp = int(val)
                self.max_hp = self.base_max_hp # Reset to base
            else:
                 if hasattr(self, attr):
                     if isinstance(getattr(self, attr), int):
                         setattr(self, attr, int(val))
                     else:
                         setattr(self, attr, val)
        
        # Evaluate formulas in abilities
        for ability_name, val in self.abilities.items():
            if isinstance(val, str) and val.startswith("="):
                new_val = evaluate_math_formula(val[1:], context)
                self.abilities[ability_name] = new_val
            elif isinstance(val, dict):
                 if 'value' in val and isinstance(val['value'], str) and val['value'].startswith("="):
                     new_val = evaluate_math_formula(val['value'][1:], context)
                     val['value'] = new_val

    def _calculate_modifier_stats(self):
        from game.simulation.components.modifiers import apply_modifier_effects
        stats = {
            'mass_mult': 1.0,
            'hp_mult': 1.0,
            'damage_mult': 1.0,
            'range_mult': 1.0,
            'cost_mult': 1.0,
            'thrust_mult': 1.0,
            'turn_mult': 1.0,
            'energy_gen_mult': 1.0,
            'capacity_mult': 1.0,
            'crew_capacity_mult': 1.0,
            'life_support_capacity_mult': 1.0,
            'consumption_mult': 1.0,
            'mass_add': 0.0,
            'arc_add': 0.0,
            'accuracy_add': 0.0,
            'arc_set': None,
            'properties': {},
            # New Modifier Support
            'reload_mult': 1.0,
            'endurance_mult': 1.0,
            'projectile_hp_mult': 1.0,
            'projectile_damage_mult': 1.0,
            'projectile_stealth_level': 0.0,
            'crew_req_mult': 1.0
        }
        
        for m in self.modifiers:
            apply_modifier_effects(m.definition, m.value, stats, component=self)
            
        return stats

    def _apply_base_stats(self, stats, old_max_hp):
        # Apply specific property overrides
        for prop, val in stats['properties'].items():
            if hasattr(self, prop):
                setattr(self, prop, val)

        # Apply Base Multipliers
        self.mass = (self.base_mass + stats['mass_add']) * stats['mass_mult']
        
        # Note: old_max_hp is passed in, captured before base formula reset
        self.max_hp = int(self.base_max_hp * stats['hp_mult'])
        
        if hasattr(self, 'cost'):
            self.cost = int(self.data.get('cost', 0) * stats['cost_mult'])



        # Handle HP update (healing/new component logic)
        if old_max_hp == 0:
            self.current_hp = self.max_hp
        elif self.current_hp >= old_max_hp:
            self.current_hp = self.max_hp
            
        # Ensure cap
        self.current_hp = min(self.current_hp, self.max_hp)

        # Generic Sync: Update Activation Abilities if attributes changed
        from game.simulation.systems.resource_manager import ResourceConsumption, ResourceStorage, ResourceGeneration
        
        for ab in self.ability_instances:
            # General Recalculate (Protocol for active abilities to sync with stats)
            ab.recalculate()

            # ResourceConsumption (Base amount * consumption_mult)
            if isinstance(ab, ResourceConsumption):
                 base = ab.data.get('amount', 0.0)
                 ab.amount = base * stats.get('consumption_mult', 1.0)
            
            # ResourceStorage (Base amount * capacity_mult)
            elif isinstance(ab, ResourceStorage):
                 base = ab.data.get('amount', 0.0)
                 ab.max_amount = base * stats.get('capacity_mult', 1.0)
            
            # ResourceGeneration (Base amount * energy_gen_mult)
            elif isinstance(ab, ResourceGeneration):
                 # Apply energy_gen_mult only if resource is energy, or generic 'generation_mult' if we had one.
                 # Modifiers like "High Output Generator" affect energy_gen_mult.
                 if ab.resource_type == 'energy':
                     base = ab.data.get('amount', 0.0)
                     ab.rate = base * stats.get('energy_gen_mult', 1.0)



    def _apply_custom_stats(self, stats):
        """Hook for subclasses to apply specific stats."""
        # Base implementation handles Crew/LifeSupport as they are somewhat generic in this system
        pass

    def clone(self):
        # Create a new instance with the same data
        # We need a Factory, but since we are refactoring, we can just make a new instance of the same class.
        # But we need to know the class.
        return self.__class__(self.data)


# Legacy Aliases - REMOVED / Mapped to Manager

COMPONENT_REGISTRY = RegistryManager.instance().components
# Phase 7 Simplified: Aliased types now use Component directly
# Types with custom logic (Shield, Hangar, etc.) are now also aliases
# as their logic has been unified into the Ability system.

COMPONENT_TYPE_MAP = {
    # All types map to generic Component
    "Bridge": Component,
    "Weapon": Component,
    "ProjectileWeapon": Component,
    "BeamWeapon": Component,
    "SeekerWeapon": Component,
    "Engine": Component,
    "Thruster": Component,
    "ManeuveringThruster": Component,
    "Shield": Component,
    "ShieldRegenerator": Component,
    "Generator": Component,
    "Hangar": Component,
    "Armor": Component,
    "Sensor": Component,
    "Electronics": Component,
    "Tank": Component,
    "CrewQuarters": Component,
    "LifeSupport": Component
}

# Caching for performance (Phase 2 Test Stabilization)
_COMPONENT_CACHE = None
_MODIFIER_CACHE = None

def load_components(filepath="data/components.json"):
    global _COMPONENT_CACHE
    import os
    import copy
    from game.core.registry import RegistryManager

    # If cache exists, hydrate Registry from cache (Fast Path)
    if _COMPONENT_CACHE is not None:
        mgr = RegistryManager.instance()
        for c_id, comp in _COMPONENT_CACHE.items():
            mgr.components[c_id] = comp.clone()
        return

    # Slow Path: Load from Disk
    # Try absolute path based on this file if CWD fails
    if not os.path.exists(filepath):
        print(f"WARN: {filepath} not found in CWD ({os.getcwd()}).")
        base_dir = os.path.dirname(os.path.abspath(__file__))
        abs_path = os.path.join(base_dir, filepath)

        if os.path.exists(abs_path):
            filepath = abs_path
        else:
            print(f"ERROR: components file not found at {abs_path}")
            return

    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for comp_def in data['components']:
            c_type = comp_def['type']
            try:
                cls = COMPONENT_TYPE_MAP.get(c_type, Component)
                obj = cls(comp_def)
                temp_cache[comp_def['id']] = obj
            except Exception as e:
                print(f"ERROR creating component {comp_def.get('id')}: {e}")
        
        # Populate Cache
        _COMPONENT_CACHE = temp_cache
        
        # Populate Registry from Cache
        mgr = RegistryManager.instance()
        for c_id, comp in _COMPONENT_CACHE.items():
            mgr.components[c_id] = comp.clone()
            
    except Exception as e:
        print(f"ERROR loading/parsing components json: {e}")

def load_modifiers(filepath="data/modifiers.json"):
    global _MODIFIER_CACHE
    import os
    import copy
    from game.core.registry import RegistryManager
    
    # Fast Path
    if _MODIFIER_CACHE is not None:
        mgr = RegistryManager.instance()
        for m_id, mod in _MODIFIER_CACHE.items():
            mgr.modifiers[m_id] = copy.deepcopy(mod)
        return

    # Slow Path
    if not os.path.exists(filepath):
         base_dir = os.path.dirname(os.path.abspath(__file__))
         filepath = os.path.join(base_dir, filepath)
    
    try:
        with open(filepath, 'r') as f:
            import json
            data = json.load(f)
            
        temp_cache = {}
        for mod_def in data['modifiers']:
            mod = Modifier(mod_def)
            temp_cache[mod.id] = mod
        
        _MODIFIER_CACHE = temp_cache
        
        mgr = RegistryManager.instance()
        for m_id, mod in _MODIFIER_CACHE.items():
            mgr.modifiers[m_id] = copy.deepcopy(mod)
            
    except Exception as e:
        print(f"ERROR loading modifiers: {e}")

def create_component(component_id):
    # Use RegistryManager instance instead of alias if possible, but alias is still mapped
    from game.core.registry import RegistryManager
    comps = RegistryManager.instance().components
    if component_id in comps:
        return comps[component_id].clone()
    print(f"Error: Component ID {component_id} not found in registry.")
    return None

def get_all_components():
    from game.core.registry import RegistryManager
    return list(RegistryManager.instance().components.values())

--- END FILE: game/simulation/components/component.py ---

--- START FILE: tests/repro_issues/test_bug_05_logistics.py ---
import pytest
import sys
import os
sys.path.append(os.getcwd())
from game.simulation.entities.ship import Ship, LayerType
from game.simulation.components.component import Component
from game.simulation.components.abilities import ResourceGeneration, ResourceStorage, ResourceConsumption, WeaponAbility
from ui.builder.stats_config import get_logistics_rows
from ship_stats import ShipStatsCalculator
from ship_stats import ShipStatsCalculator

class MockClass:
    def __init__(self, data):
        self.data = data
    def get(self, key, default=None):
        return self.data.get(key, default)

def test_missing_logistics_details():
    """
    Validation Test for BUG-05.
    Ensures that the Stats Panel Logistics section includes detailed breakdown:
    - Generation Rate
    - Constant Consumption Rate
    - Max Consumption Rate (if applicable)
    - Endurance estimates
    """
    # 1. Setup Ship
    ship = Ship(name="TestShip", x=0, y=0, color=(255, 255, 255))
    ship.ship_class = "TestClass"
    
    # Mock Vehicle Classes for Calc
    vehicle_classes = {"TestClass": {'max_mass': 1000, 'type': 'Ship'}}
    
    # 2. Add Components
    # A. Battery (Storage)
    battery = Component({"id": "batt", "name": "Battery", "mass": 10, "hp": 20, "type": "Internal"})
    battery.ability_instances = [ResourceStorage(battery, {'resource': 'energy', 'amount': 100})]
    ship.layers[LayerType.INNER]['components'].append(battery)

    # B. Reactor (Generation)
    reactor = Component({"id": "react", "name": "Reactor", "mass": 50, "hp": 100, "type": "Internal"})
    # Rate 5.0 per tick -> 500 per second (if 100hz) but UI usually shows per second or tick
    # Let's assume rate is per tick for now as per system norms
    reactor.ability_instances = [ResourceGeneration(reactor, {'resource': 'energy', 'amount': 5.0})]
    ship.layers[LayerType.INNER]['components'].append(reactor)

    # C. Life Support (Constant Consumption)
    life_support = Component({"id": "ls", "name": "LifeSupport", "mass": 20, "hp": 50, "type": "Internal"})
    life_support.ability_instances = [ResourceConsumption(life_support, {'resource': 'energy', 'amount': 2.0, 'trigger': 'constant'})]
    ship.layers[LayerType.INNER]['components'].append(life_support)

    # D. Weapon (Active Consumption)
    weapon = Component({"id": "laser", "name": "Laser", "mass": 10, "hp": 50, "type": "Internal"})
    # Reload 1.0, cost 5.0 -> 5.0/s
    weapon.ability_instances = [
        ResourceConsumption(weapon, {'resource': 'energy', 'amount': 5.0, 'trigger': 'activation'}),
        WeaponAbility(weapon, {'damage': 10, 'reload': 1.0}) 
    ]
    ship.layers[LayerType.INNER]['components'].append(weapon)

    # 3. Calculate Stats
    calc = ShipStatsCalculator(vehicle_classes)
    calc.calculate(ship)

    # 4. Get Logistics Rows (The function being tested)
    rows = get_logistics_rows(ship)
    
    # Extract keys and labels for debugging
    row_data = {r.key: r.label for r in rows}
    print(f"Generated Rows: {row_data}")

    # 5. Assertions (The Fail Conditions)
    # We check for Energy specific fields - All 6 rows required
    
    # 1. Capacity (Should exist already)
    assert "max_energy" in row_data, "Capacity row (1/6) missing"
    
    # 2. Generation (Missing in BUG-05)
    assert "energy_gen" in row_data, f"Generation row (2/6) missing. Found: {list(row_data.keys())}"

    # 3. Constant Consumption (Missing in BUG-05)
    assert "energy_constant" in row_data, f"Constant Use row (3/6) missing. Found: {list(row_data.keys())}"
    
    # 4. Max Usage (Missing in BUG-05)
    # Even if equal to constant, requirement implies checking for it.
    assert "energy_max_usage" in row_data, f"Max Usage row (4/6) missing. Found: {list(row_data.keys())}"

    # 5. Constant Endurance (Missing in BUG-05)
    assert "energy_endurance" in row_data, f"Constant Endurance row (5/6) missing. Found: {list(row_data.keys())}"

    # 6. Max Endurance (Missing in BUG-05)
    assert "energy_max_endurance" in row_data, f"Max Endurance row (6/6) missing. Found: {list(row_data.keys())}"
    
    # Optional Value Verification
    # We know specific values based on the components added:
    # Capacity: 100
    # Generation: 5.0
    # Constant: 2.0
    # Max Usage: 2.0 (Constant) + (5.0 / 1.0) = 7.0


--- END FILE: tests/repro_issues/test_bug_05_logistics.py ---

